{"version":1,"state":{"16554bc1-e93e-4a0b-8cd3-dfd772319672":{"id":"16554bc1-e93e-4a0b-8cd3-dfd772319672","space":"shared","tags":{"abVersion":"10.34","system":"ab.personality.version","abPersonalityMajorVersion":"1","onSkillUpdate":"@const versionString = tags.abPersonalityMajorVersion + \".\" + tags.abPersonalityMinorVersion;\n\nconsole.log(\"[ABPersonality] Loaded AB Personality version \" + versionString);","abPersonality":"true","abIgnore":"true","form":"nothing","abPersonalityMinorVersion":"25"}},"3c74c9f1-82dc-4655-8b38-e7f11de8978e":{"id":"3c74c9f1-82dc-4655-8b38-e7f11de8978e","space":"shared","tags":{"system":"ab.personality.arm_tool","onAnyBotDrag":"@const dragBot = that.bot;\nconst dimension = that.from.dimension;\n\nif (dragBot.tags.armSelection) {\n    if (dragBot.links.armBot) {\n        if (dragBot.links.armBot.tags.multiSelect && dragBot.links.armSelectedBots && dragBot.tags.armGroupDrag) {\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] enable custom dragging`);\n            }\n\n            os.enableCustomDragging();\n            return;\n        } else {\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] destroy previous armBot: ${dragBot.masks.armBot}`);\n            }\n\n            destroy(dragBot.links.armBot);\n            dragBot.masks.armBot = null;\n        }\n    }\n\n    const multiSelectKeyHeld = os.getInputState('keyboard', 'Shift');\n    const multiSelectAllowed = dragBot.tags.armMultiSelect ?? true;\n\n    const armBot = thisBot.abCreateArm({\n        originBot: dragBot,\n        dimension,\n        multiSelect: multiSelectKeyHeld && multiSelectAllowed,\n    })\n\n    os.replaceDragBot(armBot);\n}\n","debug":"false","listening":"true","abCreateArm":"@const originBot = that.originBot;\nassert(ab.links.utils.isBot(originBot), `[${tags.system}.${tagName}] originBot is a required Bot parameter.`);\n\nconst dimension = that.dimension;\nassert(typeof dimension === 'string', `[${tags.system}.${tagName}] dimension is a required string parameter.`);\n\nconst position = that.position ?? getBotPosition(originBot, dimension);\nconst armColor = that.armColor ?? originBot.tags.armColor ?? originBot.tags.strokeColor ?? originBot.tags.color;\nconst multiSelect = that.multiSelect ?? false;\n\nconst arm = {\n    space: 'tempLocal',\n    [dimension]: true,\n    [dimension + 'X']: position.x,\n    [dimension + 'Y']: position.y,\n    [dimension + 'Z']: position.z,\n    creator: originBot.id,\n    isArmBot: true,\n    pointable: true,\n    multiSelect,\n    debug: tags.debug,\n    originBot: getLink(originBot),\n    dimension,\n    scale: 0.9,\n    scaleZ: 0.01,\n    color: 'clear',\n    armColor,\n    strokeColor: armColor,\n    lineColor: armColor,\n    lineTo: originBot.id,\n    onCreate: ListenerString(() => {\n        // Destroy previous arm if it is still around.\n        if (links.originBot.links.armBot) {\n            destroy(links.originBot.links.armBot);\n        }\n\n        tags.system = `arm.${thisBot.id.substring(0, 5)}`;\n        links.originBot.masks.armBot = getLink(thisBot);\n        links.originBot.masks.draggable = tags.multiSelect;\n\n        if (tags.multiSelect) {\n            tags.form = 'sphere';\n            tags.color = tags.armColor;\n        }\n\n        // Make the origin bot unselectable for 1/4 of a second.\n        // This helps prevent unintentional self-selection of the origin bot.\n        links.originBot.masks.pointable = false;\n        os.sleep(250).then(() => {\n            links.originBot.masks.pointable = null;\n        })\n\n        thisBot.originClearSelection();\n\n        whisper(links.originBot, 'onArmCreate');\n    }),\n    setArmVisible: ListenerString(() => {\n        let visible = that;\n\n        if (visible) {\n            masks.strokeColor = null;\n            masks.lineColor = null;\n            masks.lineTo = links.originBot.id; \n            masks.pointable = null;\n\n            if (tags.multiSelect) {\n                masks.color = null;\n            }\n        } else {\n            masks.strokeColor = 'clear';\n            masks.lineColor = 'clear';\n            masks.lineTo = false;\n            masks.pointable = false;\n\n            if (tags.multiSelect) {\n                masks.color = 'clear';\n            }\n        }\n    }),\n    onClick: ListenerString(() => {\n        const { dimension } = that;\n\n        if (links.originBot?.tags.armTeleport ?? true) {\n            links.originBot.tags[dimension] = true;\n            links.originBot.tags[dimension + 'X'] = tags[dimension + 'X'];\n            links.originBot.tags[dimension + 'Y'] = tags[dimension + 'Y'];\n            links.originBot.tags[dimension + 'Z'] = tags[dimension + 'Z'];\n        }\n\n        whisper(links.originBot, 'onArmClick', { dimension });\n\n        destroy(thisBot);\n    }),\n    onDropEnter: ListenerString(() => {\n        if (that.dragBot !== thisBot) return;\n        if (!links.originBot) return;\n\n        const dropBot = that.to.bot;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n\n        links.originBot.masks.lineColor = tags.armColor;\n\n        if (tags.multiSelect) {\n            let lineToBots = links.originBot.links.lineTo;\n\n            if (lineToBots == null) {\n                links.originBot.masks.lineTo = getLink(dropBot);\n            } else {\n                lineToBots = Array.isArray(lineToBots) ? lineToBots : [lineToBots];\n\n                if (!lineToBots.includes(dropBot)) {\n                    links.originBot.masks.lineTo = getLink(...lineToBots, dropBot);\n                }\n            }\n        } else {\n            thisBot.setArmVisible(false);\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] hide arm`);\n            }\n\n            links.originBot.masks.lineTo = dropBot.id;\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] show selection on origin bot.`);\n            }\n        }\n    }),\n    onDropExit: ListenerString(() => {\n        if (that.dragBot !== thisBot) return;\n        if (!links.originBot) return;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n\n        const dropBot = that.to.bot;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] dropBot:`, dropBot);\n        }\n\n        if (!tags.multiSelect) {\n            thisBot.setArmVisible(true);\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] show arm`);\n            }\n\n            links.originBot.masks.lineTo = null;\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] show selection on origin bot.`);\n            }\n        }\n    }),\n    onDrop: ListenerString(() => {\n        if (that.bot !== thisBot) return;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n        \n        const dropBot = that.to.bot;\n        \n        if (tags.multiSelect && links.originBot.links.lineTo) {\n            thisBot.setArmVisible(false);\n            thisBot.originSetSelection(links.originBot.links.lineTo);\n        } else if (dropBot) {\n            thisBot.setArmVisible(false);\n            thisBot.originSetSelection(dropBot);\n        } else {\n            // Dropped on grid.\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] dropped on grid.`);\n            }\n\n            whisper(links.originBot, 'onArmPlaced', { dimension: that.to.dimension, x: that.to.x, y: that.to.y, z: that.to.z });\n        }\n        \n    }),\n    onGridClick: ListenerString(() => {\n        thisBot.originClearSelection();\n        destroy(thisBot);\n    }),\n    originClearSelection: ListenerString(() => {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n        \n        links.originBot.masks.armSelectedBots = null;\n        links.originBot.masks.lineColor = null;\n        links.originBot.masks.lineTo = null;\n    }),\n    originSetSelection: ListenerString(() => {\n        const selectedBots = that;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n\n        links.originBot.masks.armSelectedBots = selectedBots ? getLink(selectedBots) : null;\n        links.originBot.masks.lineColor = tags.armColor;\n        links.originBot.masks.lineTo = links.originBot.tags.armSelectedBots;\n        \n        if (links.originBot.links.armSelectedBots) {\n            whisper(links.originBot, 'onArmSelectedBots', links.originBot.links.armSelectedBots)\n        }\n    }),\n    onDestroy: ListenerString(() => {\n        links.originBot.masks.armBot = null;\n        links.originBot.masks.draggable = null;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] that:`, that);\n        }\n\n        whisper(links.originBot, 'onArmDestroy');\n    }),\n};\n\nconst armBot = create(arm);\n\nreturn armBot;","onAnyBotDragging":"@const dragBot = that.bot;\nconst dimension = that.from.dimension;\n\nif (dragBot.links.armBot) {\n    if (dragBot.tags.armGroupDrag && dragBot.links.armSelectedBots) {\n        let dragCoordinatorBot = links.dragCoordinatorBot;\n        \n        if (!dragCoordinatorBot) {\n            const dragCoordinatorMod = {\n                space: \"tempLocal\",\n                manager: getLink(thisBot),\n                dimension: dimension,\n                [dimension]: true,\n                [dimension + \"X\"]: 0,\n                [dimension + \"Y\"]: 0,\n                [dimension + \"Z\"]: -1,\n                pointable: false,\n                debug: tags.debug,\n                color: \"clear\",\n                system: `armGroupDrag.${thisBot.id.substring(0, 5)}.coordinator`,\n                onAnyBotPointerUp: ListenerString(() => {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}.${tagName}] destroying drag coordinator`);\n                    }\n\n                    links.manager.masks.dragCoordinatorBot = null; \n                    shout('onArmStopGroupDrag', { x: tags[tags.dimension + 'X'], y: tags[tags.dimension + 'Y'] });\n                    destroy(thisBot);\n                }),\n            };\n\n            dragCoordinatorBot = create(dragCoordinatorMod);\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] created drag coordinator bot:`, dragCoordinatorBot);\n            }\n\n            masks.dragCoordinatorBot = getLink(dragCoordinatorBot);\n\n            const armSelectedBots = dragBot.links.armSelectedBots;\n            const onArmStopGroupDrag = `@\n                masks.transformer = null;\n                masks.onArmStopGroupDrag = null;\n                tags.${dimension}X = tags.${dimension}X + that.x;\n                tags.${dimension}Y = tags.${dimension}Y + that.y;\n            `\n\n            dragBot.masks.transformer = dragCoordinatorBot.id;\n            dragBot.masks.onArmStopGroupDrag = onArmStopGroupDrag;\n\n            setTagMask(armSelectedBots, \"transformer\", dragCoordinatorBot.id, \"tempLocal\");\n            setTagMask(armSelectedBots, \"onArmStopGroupDrag\", onArmStopGroupDrag, \"tempLocal\");\n        }\n\n        const xChange = that.to.x - that.from.x;\n        const yChange = that.to.y - that.from.y;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] xChange: ${xChange}, yChange: ${yChange}`);\n        }\n\n        dragCoordinatorBot.tags[dimension + \"X\"] = xChange;\n        dragCoordinatorBot.tags[dimension + \"Y\"] = yChange;\n        dragCoordinatorBot.tags[dimension + \"Z\"] = -1;\n    } else {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] drag bot with arm does not qualify for group dragging.`);\n        }\n    }\n}","abPersonality":"true","abIgnore":"true","form":"nothing","abVersion":"10.34"}},"b26e1089-172d-45a9-8d22-05c3f58c2bf7":{"id":"b26e1089-172d-45a9-8d22-05c3f58c2bf7","space":"shared","tags":{"system":"ab.personality.animation","form":"nothing","abIgnore":"true","manifestation":"ðŸ”—dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","animation_abGridManifest":"@shout(\"reset\");\n\nconst positionX = that?.position.x ?? 0;\nconst positionY = that?.position.y ?? 0;\nconst dimension = that?.dimension ?? \"home\";\nconst gridScale = that?.scale ?? 5;\nconst momentCount = 0;\nconst gridBot = {};\n\ngridBot.space = \"tempLocal\";\ngridBot.color = \"clear\";\ngridBot.strokeColor = abPersonality.tags.abBaseStrokeColor;\ngridBot.scale = 0.001;\ngridBot.scaleZ = 0.1;\ngridBot.reset = \"@ destroy(thisBot);\";\ngridBot[dimension] = true;\ngridBot.pointable = false;\ngridBot.killTimer = \"@ await os.sleep(400); destroy(thisBot);\";\n\nlet roundBots;\n\nfor (let i = gridScale; i > 0; i--)\n{\n    const botCount = i * 8;\n\n    let sideCount = 0;\n    let phaseFactor = 0;\n\n    for (let j = 0; j < botCount; j++)\n    {\n        if (phaseFactor == 0)\n        {\n            gridBot[dimension + \"X\"] = ((i + positionX) * -1) + sideCount;\n            gridBot[dimension + \"Y\"] = i + positionY;\n        }\n        else if (phaseFactor == 1)\n        {\n            gridBot[dimension + \"X\"] = i + positionX;\n            gridBot[dimension + \"Y\"] = (i + positionY) - sideCount;  \n        }\n        else if (phaseFactor == 2)\n        {\n            gridBot[dimension + \"X\"] = (i + positionX) - sideCount;\n            gridBot[dimension + \"Y\"] = ((i + positionY) * -1) ;\n        }\n        else\n        {\n            gridBot[dimension + \"X\"] = ((i + positionX) * -1) ;\n            gridBot[dimension + \"Y\"] = ((i + positionY) * -1) + sideCount;  \n        }\n\n        const newGridBot = await create(gridBot);\n\n        animateTag(newGridBot, \"scale\", {\n            toValue: 1,\n            easing: {\n                type: \"elastic\",\n                mode: \"out\"\n            },\n            duration: 0.01\n        }).catch(() => {});\n\n        newGridBot.killTimer();\n\n        sideCount++;\n\n        if (sideCount == botCount / 4)\n        {\n            sideCount = 0;\n\n            phaseFactor++;\n        }\n\n        await os.sleep(8);\n    }\n}","abVersion":"10.34","onChat":"@// if (that.message == \"@test\")\n// {\n//     thisBot.animation_abGridManifest();\n// }","personality":"ðŸ”—b76dfbc4-854b-4f6d-a91f-a948694774db","abPersonality":"true"}},"b76dfbc4-854b-4f6d-a91f-a948694774db":{"id":"b76dfbc4-854b-4f6d-a91f-a948694774db","space":"shared","tags":{"system":"ab.personality.config","abIgnore":"true","form":"nothing","abBaseColor":"#00D9CD","abBaseStrokeColor":"#00D9CD","abBlueprintColor":"#00827B","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abBuilderIdentity":"casual.bot","abVersion":"10.34","changePersonalityConfig":"@if (!that) {\r\n    return;\r\n}\r\n\r\nif (!authBot) {\r\n    await os.requestAuthBotInBackground();\r\n}\r\n\r\nif (!authBot) {\r\n    return;\r\n}\r\n\r\nawait os.grantInstAdminPermission(authBot.id);\r\n\r\nlet abPersonalityConfigData = await os.getData(authBot.id, \"abPersonalityConfig\");\r\n\r\nif (abPersonalityConfigData.success == false) {\r\n    abPersonalityConfigData = {};\r\n} else {\r\n    abPersonalityConfigData = abPersonalityConfigData.data;\r\n}\r\n\r\nif (that.name) {\r\n    abPersonalityConfigData[\"abBuilderIdentity\"] = that.name;\r\n    setTagMask(thisBot, \"abBuilderIdentity\", that.name, \"local\");\r\n}\r\n\r\nif (that.color) {\r\n    abPersonalityConfigData[\"abBaseColor\"] = that.color;\r\n    abPersonalityConfigData[\"abBaseStrokeColor\"] = that.color;\r\n    setTagMask(thisBot, \"abBaseColor\", that.color, \"local\");\r\n    setTagMask(thisBot, \"abBaseStrokeColor\", that.color, \"local\");\r\n}\r\n\r\nif (that.portalColor) {\r\n    abPersonalityConfigData[\"abBaseGridPortalColor\"] = that.portalColor;\r\n    setTagMask(thisBot, \"abBaseGridPortalColor\", that.portalColor, \"local\");\r\n}\r\n\r\nif (that.menuColor) {\r\n    abPersonalityConfigData[\"abBaseMenuColor\"] = that.menuColor;\r\n    setTagMask(thisBot, \"abBaseMenuColor\", that.menuColor, \"local\");\r\n}\r\n\r\nif (that.menuLabelColor) {\r\n    abPersonalityConfigData[\"abBaseLabelColor\"] = that.menuLabelColor;\r\n    setTagMask(thisBot, \"abBaseLabelColor\", that.menuLabelColor, \"local\");\r\n    abPersonalityConfigData[\"abBaseShadowColor\"] = that.menuLabelColor;\r\n    setTagMask(thisBot, \"abBaseShadowColor\", that.menuLabelColor, \"local\");\r\n}\r\n\r\nif (that.form) {\r\n    abPersonalityConfigData[\"abForm\"] = that.form;\r\n    setTagMask(thisBot, \"abForm\", that.form, \"local\");\r\n}\r\n\r\nif (that.aiModel) {\r\n    abPersonalityConfigData[\"abPreferredAIModel\"] = that.aiModel;\r\n    setTagMask(thisBot, \"abPreferredAIModel\", that.aiModel, \"local\");\r\n}\r\n\r\nif (that.defaultPersonality) {\r\n    abPersonalityConfigData = {};\r\n    thisBot.updatePersonality({});\r\n}\r\n\r\nif (that.mapBasemap) {\r\n    abPersonalityConfigData[\"abMapPortalBase\"] = that.mapBasemap;\r\n    setTagMask(thisBot, \"abMapPortalBase\", that.mapBasemap, \"local\");\r\n}\r\n\r\nconst result = await os.recordData(authBot.id, \"abPersonalityConfig\", abPersonalityConfigData);\r\n\r\nif (result.success) {\r\n    ab.links.utils.abLog({ message: `updated personality config in user record`, logType: 'log'});\r\n} else {\r\n    ab.links.utils.abLog({ message: `failed to update personality config in user record.\\n${JSON.stringify(result, undefined, 2)}`, logType: 'error'});\r\n}\r\n\r\nshout('onABPersonalityChanged', { bot: thisBot });","abBaseMenuColor":"#00D9CD","updatePersonality":"@if (tags.debug) {\r\n    console.log(`[${tags.system}.${tagName}] update start`);\r\n}\r\n\r\nif (thisBot.vars.updatingPersonality) {\r\n    return;\r\n}\r\n\r\nthisBot.vars.updatingPersonality = true;\r\n\r\nlet abPersonalityConfigData;\r\n\r\nif (that && that == {}) {\r\n    abPersonalityConfigData = {};\r\n} else {\r\n    if (!authBot) {\r\n        await os.requestAuthBotInBackground();\r\n    }\r\n\r\n    if (authBot) {\r\n        abPersonalityConfigData = await os.getData(authBot.id, \"abPersonalityConfig\");\r\n        if (!links.remember && abPersonalityConfigData.success == false) {\r\n            thisBot.vars.updatingPersonality = false;\r\n            return;\r\n        }\r\n\r\n        if (abPersonalityConfigData.success) {\r\n            abPersonalityConfigData = abPersonalityConfigData.data;\r\n        }\r\n    }\r\n}\r\n\r\nif (tags.debug) {\r\n    console.log(`[${tags.system}.${tagName}] abPersonalityConfigData:`, {...abPersonalityConfigData});\r\n}\r\n\r\n//abBluePrintColor\r\n//abBaseAccentColor\r\nconst abTags = [\r\n    \"abBaseColor\",\r\n    \"abBaseMenuColor\",\r\n    \"abBuilderIdentity\",\r\n    \"abBaseStrokeColor\",\r\n    \"abBaseGridPortalColor\",\r\n    \"abBaseLabelColor\",\r\n    \"abBaseShadowColor\",\r\n    \"abPreferredAIModel\",\r\n    \"abCatalogName\",\r\n    \"abMapPortalBase\"\r\n];\r\n\r\nclearTagMasks(thisBot);\r\n\r\n// Ryan (Aug 29, 2025): im not sure exactly what is happening here but without sleeping on these big tag mask changes, they dont all seem to come in properly.\r\nawait os.sleep(100);\r\n\r\nfor (let i = 0; i < abTags.length; ++i) {\r\n    if (abPersonalityConfigData && abPersonalityConfigData[abTags[i]]) {\r\n        if (tags[abTags[i]] != abPersonalityConfigData[abTags[i]]) {\r\n            if (tags.debug) {\r\n                console.log(`[${tags.system}.${tagName}] setting ${abTags[i]} local mask from abPersonalityConfigData: ${abPersonalityConfigData[abTags[i]]}`);\r\n            }\r\n            setTagMask(thisBot, abTags[i], abPersonalityConfigData[abTags[i]], \"local\");\r\n        }\r\n    } else if (links.remember && links.remember.tags[abTags[i]]) {\r\n        if (links.remember.tags[abTags[i]] != tags[abTags[i]]) {\r\n            if (tags.debug) {\r\n                console.log(`[${tags.system}.${tagName}] setting ${abTags[i]} local mask from ab remember bot:`, links.remember.tags[abTags[i]]);\r\n            }\r\n            setTagMask(thisBot, abTags[i], links.remember.tags[abTags[i]], \"local\");\r\n        }\r\n    }\r\n\r\n    if (abTags[i] == \"abBaseGridPortalColor\") {\r\n        gridPortalBot.tags.portalColor = tags.abBaseGridPortalColor;\r\n    }\r\n\r\n    if (abTags[i] == \"abMapPortalBase\") {\r\n        mapPortalBot.tags.mapPortalBasemap = tags.abMapPortalBase;\r\n        miniMapPortalBot.tags.mapPortalBasemap = tags.abMapPortalBase;\r\n    }\r\n}\r\n\r\n// Ryan (Aug 29, 2025): im not sure exactly what is happening here but without sleeping on these big tag mask changes, they dont all seem to come in properly.\r\nawait os.sleep(100);\r\n\r\nthisBot.vars.updatingPersonality = false;\r\nshout('onABPersonalityUpdated', { bot: thisBot });","abPersonality":"true","onSkillUpdate":"@thisBot.updatePersonality();","abBaseShadowColor":"black","abBaseLabelColor":"black","mapOptions":"ðŸ§¬[\r\n    {\r\n        \"name\":  \"satellite\",\r\n        \"id\": \"satellite\"\r\n    },\r\n    {\r\n        \"name\":  \"hybrid\",\r\n        \"id\": \"hybrid\"\r\n    },\r\n    {\r\n        \"name\":  \"oceans\",\r\n        \"id\": \"oceans\"\r\n    },\r\n    {\r\n        \"name\":  \"open street map\",\r\n        \"id\": \"osm\"\r\n    },\r\n    {\r\n        \"name\":  \"terrain\",\r\n        \"id\": \"terrain\"\r\n    },\r\n    {\r\n        \"name\":  \"dark gray canvas\",\r\n        \"id\": \"dark-gray\"\r\n    },\r\n    {\r\n        \"name\":  \"gray canvas\",\r\n        \"id\": \"gray\"\r\n    },\r\n    {\r\n        \"name\":  \"streets\",\r\n        \"id\": \"streets\"\r\n    },\r\n    {\r\n        \"name\":  \"streets (dark)\",\r\n        \"id\": \"streets-night-vector\"\r\n    },\r\n    {\r\n        \"name\":  \"streets (navigation)\",\r\n        \"id\": \"streets-navigation-vector\"\r\n    },\r\n    {\r\n        \"name\":  \"topographic\",\r\n        \"id\": \"topo\"\r\n    },\r\n    {\r\n        \"name\":  \"streets (relief)\",\r\n        \"id\": \"streets-relief-vector\"\r\n    }\r\n]","showABBasemapOptions":"@shout(\"clearABBasemapOptionsMenu\");\r\n\r\nshout(\"abMenuRefresh\");\r\nconfigBot.tags.menuPortal = 'abBasemapOptionsMenu';\r\n\r\nfor (const option of tags.mapOptions) {\r\n    if (option.id == mapPortalBot.tags.mapPortalBasemap) {\r\n        continue;\r\n    }\r\n    const optionObj = \r\n    {\r\n        abBasemapOptionsMenu: true,\r\n        clearABBasemapOptionsMenu: `@destroy(thisBot);`,\r\n        mapID: option.id,\r\n        label: option.name,\r\n        onClick: `@\r\n            mapPortalBot.tags.mapPortalBasemap = tags.mapID;\r\n            shout('changePersonalityConfig', {'mapBasemap': tags.mapID}); \r\n            shout(\"clearABBasemapOptionsMenu\");\r\n        `\r\n    }\r\n\r\n    ab.links.menu.abCreateMenuButton(optionObj);\r\n}","onGridClick":"@shout(\"clearABBasemapOptionsMenu\");\r\n","debug":"false"}},"b9b82819-1f14-4392-88a9-52f67a9f8e55":{"id":"b9b82819-1f14-4392-88a9-52f67a9f8e55","space":"shared","tags":{"system":"ab.personality.arm_nudge","onABArmPlaced":"@setTagMask(thisBot, 'hasArmBeenPlaced', true, 'local');","onABAwake":"@await os.sleep(250);\nthisBot.abStartArmNudge();","abIgnore":"true","abPersonality":"true","form":"nothing","learn":"ðŸ”—6657b865-e983-4401-9fc9-f5418d18a7f7","manifestation":"ðŸ”—dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","debug":"false","armNudgeWaitMS":"5000","onABInitialized":"@thisBot.abStartArmNudge();","abStartArmNudge":"@if (thisBot.vars.nudgeActive) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] there is already a nudge in progress.`);\n    }\n    return;\n}\n\nthisBot.vars.nudgeActive = true;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] starting nudge...`)\n}\n\nfunction canNudge(): boolean {\n    // Can't have placed the arm already.\n    if (tags.hasArmBeenPlaced) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] cannot nudge: arm placement has already occured.`);\n        }\n        return false;\n    }\n\n    // AB manifestation bot must be active.\n    if (!links.manifestation.links.abBot) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] cannot nudge: ab manifestation bot is inactive.`);\n        }\n        return false;\n    }\n\n    // The inst must be empty of all bots. The exceptions are ab bots and built-in bots.\n    const userMadeBot = getBot((b) => {\n        return !b.tags.system?.startsWith('ab.') &&\n                b.space === 'shared' &&\n                !b.tags.abEgg // Don't include abEgg bots as \"user made\".\n    })\n    \n    if (userMadeBot) {\n        if (tags.debug) {\n            if (tags.debugUserMadeBots) {\n                const userMadeBots = getBots((b) => {\n                    return !b.tags.system?.startsWith('ab.') &&\n                            b.space === 'shared' &&\n                            !b.tags.abEgg // Don't include abEgg bots as \"user made\".\n                })\n                console.log(`[${tags.system}.${tagName}] cannot nudge: inst contains user made bots.`, userMadeBots);\n            } else {\n                console.log(`[${tags.system}.${tagName}] cannot nudge: inst contains user made bots.`);\n            }\n        }\n        return false;\n    }\n\n    // Menu portal must either be inactive or not have any bots in the currently active menu portal.\n    if (configBot.tags.menuPortal) {\n        const botInMenuPortal = getBot((b) => {\n            return b.tags[configBot.tags.menuPortal] === true\n        });\n\n        if (botInMenuPortal) {\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] cannot nudge: menuPortal is currently open and has bots in it.`);\n            }\n            return false;\n        }\n    }\n\n    return true;\n}\n\nif (canNudge()) {\n    // Start nudge for arm placement.\n    await os.sleep(tags.armNudgeWaitMS);\n\n    if (canNudge()) {\n        const abPositionX = links.manifestation.links.abBot.tags[links.remember.tags.abActiveDimension + 'X'];\n        const abPositionY = links.manifestation.links.abBot.tags[links.remember.tags.abActiveDimension + 'Y'];\n\n        const gridClickParams = {\n            dimension: links.remember.tags.abActiveDimension,\n            position: { x: abPositionX + 5, y: abPositionY },\n            forceArmPlacement: true,\n        }\n\n        if (configBot.tags.mapPortal === links.remember.tags.abActiveDimension) {\n            // Map portal is in different coordinate space and scale.\n            gridClickParams.position.x = abPositionX + 0.0003574340684053823;\n        }\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] whispering onGridClick to the ab manifestation bot with the params:`, gridClickParams)\n        }\n\n        // Force ab arm placement using the onGridClick listener of the manifestation bot.\n        whisper(links.manifestation, 'onGridClick', gridClickParams);\n    }\n}\n\nthisBot.vars.nudgeActive = false;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] done`);\n}","abVersion":"10.34","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'menuPortal') {\n    if (!dimension) {\n        thisBot.abStartArmNudge();\n    }\n}","abMenuRefresh":"@thisBot.abStartArmNudge();","debugUserMadeBots":"false"}},"dca5d987-c4d8-46e4-b60c-daa7b2f4ddad":{"id":"dca5d987-c4d8-46e4-b60c-daa7b2f4ddad","space":"shared","tags":{"system":"ab.personality.manifestation","form":"nothing","description":"This skill controls the actual bot for the ab interface.","learn":"ðŸ”—6657b865-e983-4401-9fc9-f5418d18a7f7","onPortalChanged":"@const PORTALS_THAT_HIDE = new Set([\n    \"systemPortal\",\n    \"sheetPortal\"\n])\n\nconst PORTALS_THAT_MANIFEST = new Set([\n    \"gridPortal\",\n    \"mapPortal\"\n]);\n\nasync function getDefaultManifestPosition(portal: 'map' | 'grid'): { x: number, y: number } {\n    if (portal === 'grid') {\n        return { x: 0, y: 0 }\n    } else if (portal === 'map') {\n        if (typeof links.remember.tags.mapZoomPosition?.x === 'number' &&  typeof links.remember.tags.mapZoomPosition?.y === 'number') {\n            return links.remember.tags.mapZoomPosition;\n        } else {\n            let currentPosition = undefined;\n            let hasGeolocationPermission = await links.utils.hasGeolocationPermission();\n\n            // Current work-around for allowing geolocation for iOS app\n            if (getBot(\"system\", \"ab.iosbridge.messenger\")) {\n                hasGeolocationPermission = true;\n            }\n\n            if (hasGeolocationPermission) {\n                const geolocation = await os.getGeolocation();\n                if (geolocation.success) {\n                    currentPosition = { x: geolocation.longitude, y: geolocation.latitude }\n                }\n            }\n\n            if (currentPosition) {\n                return currentPosition;\n            } else {\n                // GRPM Position\n                return { x: -85.6761894822434, y: 42.9656756756756 };\n            }\n        }\n    } else {\n        console.error(`[${tags.system}.${tagName}] unrecongized portal type provided to getDefaultManifestPosition:`, portal);\n        return { x: 0, y: 0 }\n    }\n}\n\nconst MAP_LOAD_WAIT_TIME = 1000;\n\nfor (const portal of PORTALS_THAT_HIDE) {\n    if (configBot.tags[portal] != null) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] a portal that hides ab is open - hiding abBot and ignoring.`);\n        }\n\n        if (tags.abBot) {\n            destroy(links.abBot);\n        }\n\n        return;\n    }\n}\n\nif (configBot.tags.sheetPortal != null || configBot.tags.systemPortal != null) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] sheet portal or system portal opened - hiding abBot and ignoring.`);\n    }\n\n    if (tags.abBot) {\n        destroy(links.abBot);\n    }\n\n    return;\n}\n\nif (!tags.abAwake) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] ab is not awake - ignoring.`);\n    }\n    return;\n}\n\nif (that.portal == \"tagPortal\") {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] tagPortal changed - ignoring.`);\n    }\n    return;\n}\n\nif (that.portal == \"menuPortal\") {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] menuPortal changed - ignoring.`);\n    }\n    return;\n}\n\nif (that.portal == \"gridPortal\" && configBot.tags.mapPortal) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] gridPortal changed, but also already in the mapPortal - ignoring.`);\n    }\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\n// The map portal is tough. It seems to vary in loading speed on\n// various hardware and networks and has by the time onPortalChanged is called it doesnt\n// seem guarenteed to be actually ready. Adding a hardcoded wait time to give the portal space to get\n// the map portal fully loaded before continuing with manifesting ab.\n//\n// At some point this can go away if we ever get a shout or some other gaurentee that the map portal is loaded/ready.\nif (that.portal === 'mapPortal') {\n    if (that.dimension) {\n        if (!thisBot.vars.mapPortalLoaded) {\n            if (!thisBot.vars.mapPortalLoadWaiter) {\n                thisBot.vars.mapPortalLoadWaiter = os.sleep(MAP_LOAD_WAIT_TIME)\n            }\n\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] waiting for map portal to finish loading: ${MAP_LOAD_WAIT_TIME}ms`);\n            }\n\n            await thisBot.vars.mapPortalLoadWaiter;\n            thisBot.vars.mapPortalLoadWaiter = null;\n            thisBot.vars.mapPortalLoaded = true;\n        } else {\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] map portal is already loaded.`);\n            }\n        }\n    } else {\n        thisBot.vars.mapPortalLoaded = false;\n        thisBot.vars.mapPortalLoadWaiter = null;\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] map portal has been unloaded.`);\n        }\n    }\n}\n\n// Start checks for if/where we need to manifest ab.\nlet newAB = false;\nlet newABPortal;\nlet newABPosition;\nlet focusCamera = true;\n\nif (PORTALS_THAT_MANIFEST.has(that.portal) && that.dimension) {\n    // A portal that manifests ab has just changed dimension.\n    // Manifest ab in the new dimension.\n    if (that.portal == \"mapPortal\" || that.portal == \"miniMapPortal\") {;\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] manifesting ab bot in map portal dimension '${that.dimension}'.`);\n        }\n\n        newABPosition = await getDefaultManifestPosition('map');\n        newABPortal = that.portal;\n        newAB = await thisBot.abManifestBot({ dimension: that.dimension, position: newABPosition });\n    }\n    else {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] manifesting ab bot dimension '${that.dimension}'.`);\n        }\n\n        newABPosition = await getDefaultManifestPosition('grid');\n        newABPortal = that.portal;\n        newAB = await thisBot.abManifestBot({ dimension: that.dimension, position: newABPosition });\n    }\n} else if ((PORTALS_THAT_MANIFEST.has(that.portal) || PORTALS_THAT_HIDE.has(that.portal)) && \n           !that.dimension && \n           (configBot.tags.gridPortal || configBot.tags.mapPortal)\n) {\n    // A portal that typically hides or re-manifests ab just closed, but either the grid or map portal are still open.\n    // Summon ab in either the mapPortal or gridPortal.\n    let summonDimension;\n\n    if (configBot.tags.mapPortal) {\n        summonDimension = configBot.tags.mapPortal;\n        newABPortal = 'mapPortal';\n        \n        if (links.remember.tags[summonDimension + 'ABLastPosition']) {\n            // Use last known position.\n            newABPosition = links.remember.tags[summonDimension + 'ABLastPosition'];\n        } else {\n            // Use default map position.\n            newABPosition = await getDefaultManifestPosition('map');\n        }\n    } else if (configBot.tags.gridPortal) {\n        summonDimension = configBot.tags.gridPortal;\n        newABPortal = 'gridPortal';\n\n        if (links.remember.tags[summonDimension + 'ABLastPosition']) {\n            // Use last known position.\n            newABPosition = links.remember.tags[summonDimension + 'ABLastPosition'];\n        } else {\n            // Use default grid position.\n            newABPosition = await getDefaultManifestPosition('grid');\n        }\n    }\n\n    if (summonDimension) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] summoning ab bot in ${newABPortal} dimension '${summonDimension}'.`);\n        }\n\n        newAB = await thisBot.abManifestBot({ dimension: summonDimension, position: newABPosition });\n\n        if (PORTALS_THAT_HIDE.has(that.portal)) {\n            // If the portal that closed was a portal that hides ab, then dont run the camera focus.\n            // This will just use the previous camera position already stored in memory.\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] will not focus camera on ab because we are just assuming the previous camera position.`);\n            }\n            focusCamera = false;\n        }\n    } else {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] both the map and grid portal are both closed, cannot summon ab in either.`);\n        }\n    }\n} else {\n    return;\n}\n\nif (newAB && focusCamera) {\n    let zoom = 10;\n\n    if (newABPortal === 'mapPortal' || newABPortal === 'miniMapPortal') {\n        zoom = 2000;\n    }\n    try {\n        await os.focusOn(newABPosition, { zoom, rotation: { x: 45, y: 45 }, portal: newABPortal })\n    } catch (e) {\n        if (tags.debug) {\n            console.warn(`[${tags.system}.${tagName}] focusOn error occured:`, e);\n        }\n    }\n}","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","abManifestBot":"@const dimension = that?.dimension;\nconst position = that?.position;\n\nif (thisBot.vars.abBotLastId) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] destroying abBot`);\n    }\n    destroy(thisBot.vars.abBotLastId);\n}\n\nconst abMod = {\n    space: 'tempLocal',\n    color: links.personality.tags.abBaseColor,\n    formOpacity: '0.33',\n    dimension,\n    [dimension]: true,\n    [dimension + 'X']: position.x,\n    [dimension + 'Y']: position.y,\n    strokeColor: links.personality.tags.abBaseStrokeColor,\n    manager: getLink(thisBot),\n    remember: tags.remember,\n    label: links.remember.tags.abBaseLabel,\n    labelPosition: 'front',\n    labelColor: links.personality.tags.abBaseStrokeColor,\n    labelSize: 0.61,\n    draggable: false,\n    scale: 0.9,\n    armSelection: true,\n    armGroupDrag: true,\n    armTeleport: true,\n    armColor: links.personality.tags.abBaseStrokeColor,\n    onCreate: ListenerString(() => {\n        thisBot.animateBot();\n        masks.interval = setInterval(() => thisBot.animateBot(), 2000);\n    }),\n    onClick: ListenerString(() => {\n        if (that.modality == 'mouse' && that.buttonId == 'right') {\n            return;\n        }\n        \n        if (links.armBot) {\n            destroy(links.armBot);\n        }\n\n        links.manager.abClick();\n    }),\n    onPointerEnter:ListenerString(() => {\n        if (that.modality === 'mouse') {\n            tags.mouseOver = true;\n            thisBot.updatePortalCursor();\n        }\n    }),\n    onPointerExit: ListenerString(() => {\n        if (that.modality === 'mouse') {\n            tags.mouseOver = false;\n            thisBot.updatePortalCursor();\n        }\n    }),\n    onPointerDown: ListenerString(() => {\n        if (that.modality === 'mouse' && that.buttonId === 'left') {\n            tags.mouseLeftButtonDown = true;\n            thisBot.updatePortalCursor();\n        }\n    }),\n    onPointerUp: ListenerString(() => {\n        if (that.modality === 'mouse' && that.buttonId === 'left') {\n            tags.mouseLeftButtonDown = false;\n            tags.mouseLeftDragging = false;\n            thisBot.updatePortalCursor();\n        }\n    }),\n    onDrag: ListenerString(() => {\n        if (tags.mouseLeftButtonDown) {\n            tags.mouseLeftDragging = true;\n            thisBot.updatePortalCursor();  \n        }\n    }),\n    onKeyDown: ListenerString(() => {\n        if (that.keys.includes('Shift')) {\n            tags.shiftHeld = true;\n            thisBot.updatePortalCursor();  \n        }\n    }),\n    onKeyUp: ListenerString(() => {\n        if (that.keys.includes('Shift')) {\n            tags.shiftHeld = false;\n            thisBot.updatePortalCursor();  \n        }\n    }),\n    updatePortalCursor: ListenerString(() => {\n        let cursor = null;\n\n        if (tags.mouseLeftDragging) {\n            cursor = 'grabbing';    \n        } else if (tags.mouseOver) {\n            if (tags.shiftHeld) {\n                cursor = 'context-menu';\n            } else {\n                cursor = 'pointer';\n            }\n        }\n\n        gridPortalBot.masks.portalCursor = cursor;\n    }),\n    animateBot: ListenerString(async () => { \n        if (configBot.tags.abOptimized) {\n            return;\n        }\n\n        const rotZ = tags.dimension + 'RotationZ';\n        let targetScale = 0.65;\n\n        await animateTag(thisBot,\n        {\n            fromValue: {\n                [rotZ]: 0,\n            },\n            toValue: {\n                [rotZ]: 6.3,\n            },\n            easing: {\n                type: 'sinusoidal',\n                mode: 'inout'\n            },\n            duration: 2\n        }).catch(e => {});\n    }),\n    onArmCreate: ListenerString(() => {\n        if (!tags.interval) {\n            links.manager.abClick({ reset: true });\n        }\n    }),\n    onArmPlaced: ListenerString(() => {\n        links.remember.masks.abGridFocus = {\n            dimension: that.dimension, \n            position: {\n                x: that.x,\n                y: that.y\n            }\n        }\n\n        links.manager.abClick({ menu: 'grid' });\n\n        shout('onABArmPlaced', that);\n    }),\n    onArmClick: ListenerString(() => {\n        links.manager.abClick({ reset: true });\n        shout('onABFootClicked', that);\n    }),\n    onArmSelectedBots: ListenerString(() => {\n        const selectedBots = that;\n\n        if (Array.isArray(selectedBots)) {\n            // Multiple bot selection.\n            links.remember.masks.abMultipleBotFocus = getLink(selectedBots);\n            links.manager.abClick({ menu: 'multipleBot' });\n        } else {\n            // Single bot selection.\n            // links.remember.masks.abBotFocus = getLink(selectedBots);\n            links.remember.masks.abBotFocus = \"ðŸ”—\" + selectedBots.id;\n            links.manager.abClick({ menu: 'bot' });\n        }\n\n        shout('onABSelectedBot', selectedBots);\n    }),\n    onArmDestroy: ListenerString(() => {\n        shout('abMenuRefresh');\n    }),\n    onDestroy: ListenerString(() => {\n        clearInterval(tags.interval);\n        shout('abMenuRefresh');\n    }),\n};\n\nconst abBot = create(abMod);\n\nif (links.remember.tags.abSecondaryLabel) {\n    const abLabelBot = {\n        space: 'tempLocal',\n        [dimension]: true,\n        [dimension + 'Z']: -1,\n        creator: abBot.id,\n        transformer: abBot.id,\n        pointable: false,\n        color: 'clear',\n        label: links.remember.tags.abSecondaryLabel,\n        labelPosition: 'left',\n        labelSize: 0.7,\n        labelColor: abBot.tags.labelColor,\n    };\n\n    create(abLabelBot);\n}\n\nmasks.abBot = getLink(abBot);\nlinks.remember.masks.abActiveDimension = dimension;\nthisBot.vars.abBotLastId = abBot.id; // Storing id as a var prevents ghost abBots during multiple calls in one frame.\n\n// Store the last position of ab in this dimension on the remember bot.\nlinks.remember.masks[dimension + 'ABLastPosition'] = 'ðŸ§¬' + JSON.stringify({ x: position?.x, y: position?.y });\n\nawait os.sleep(0); // Give CasualOS a chance to update tag masks.\n\nshout('onABMoved', { dimension, x: position.x, y: position.y });\n\nreturn abBot;","onGridClick":"@if (!tags.abAwake) {\n    return;\n}\n\nconst shiftCheck = os.getInputState(\"keyboard\", \"Shift\");\n\nif (links.abBot && (shiftCheck || (that.modality == \"mouse\" && that.buttonId == \"right\" && !links.remember.tags.abRightClickDisabled) || that.forceArmPlacement)) {\n    const armBot = ab.links.arm_tool.abCreateArm({\n        originBot: links.abBot,\n        dimension: that.dimension,\n        position: that.position,\n    })\n\n    // Fake user dropping the arm on the grid space.\n    armBot.onDrop({\n        bot: armBot,\n        to: {\n            x: that.position.x,\n            y: that.position.y,\n            dimension: that.dimension\n        },\n        from: {\n            x: that.position.x,\n            y: that.position.y,\n            dimension: that.dimension\n        }\n    });\n\n    return;\n}\n\nconst footprint = {\n    space: \"tempLocal\",\n    dimension: that.dimension,\n    [that.dimension]: true,\n    [that.dimension + \"X\"]: that.position.x,\n    [that.dimension + \"Y\"]: that.position.y,\n    scaleZ: 0.01,\n    positionInfo: that,\n    color: \"clear\",\n    personality: tags.personality,\n    strokeColor: links.personality.tags.abBaseStrokeColor,\n    draggable: false,\n    cursor: 'alias',\n    manager: getLink(thisBot),\n    onCreate: ListenerString(async () => {\n        setTimeout(() => destroy(thisBot), 800);\n\n        await animateTag(thisBot, {\n            fromValue: {\n                scaleX: 0.1,\n                scaleY: 0.1\n            },\n            toValue: {\n                scaleX: 1.1,\n                scaleY: 1.1\n            },\n            duration: 0.5,\n            easing: {\n                type: \"elastic\",\n                mode: \"out\"\n            }\n        }).catch(e => {});\n    }),\n    onClick: ListenerString(() => {\n        tags[tags.dimension] = false;\n        shout(\"onABFootClicked\", { dimension: tags.dimension });\n        links.manager.abManifestBot(tags.positionInfo);\n    }),\n};\n\n\ncreate(footprint);","menu":"ðŸ”—b30c6c5d-a4f7-4266-ba38-393dc95e1ecb","abClick":"@if (!links.abBot) {\n    return;\n}\n\nif (links.input) {\n    links.input.abChatBarClose();\n}\n\nconst reset = that ? that.reset : false;\nconst menu = that ? that.menu : \"core\";\nconst state = os.getInputState(\"keyboard\", \"Shift\");\n\nif (!reset && (links.abBot.tags.interval || state)) {\n    const abMenuBots = getBots(\"abMenu\", true);\n\n    whisper(abMenuBots, \"abMenuRefresh\");\n\n    clearInterval(links.abBot.tags.interval);\n\n    links.abBot.masks.interval = null;\n\n    clearAnimations(links.abBot);\n\n    const rotZ = links.abBot.tags.dimension + \"RotationZ\";\n\n    if (state && menu == \"core\") {\n        links.menu.abEnvironmentMenu();\n    }\n    else {\n        links.menu.abOpenMenu(menu);\n    }\n\n    animateTag(links.abBot, {\n        fromValue: {\n            [rotZ]: links.abBot.tags[rotZ],\n            scale: links.abBot.tags.scale\n        },\n        toValue: {\n            [rotZ]: 0,\n            scale: 0.9\n        },\n        easing: {\n            type: \"sinusoidal\",\n            mode: \"inout\"\n        },\n        duration: 0.5\n    }).catch(e => {})\n}\nelse {\n    links.abBot.animateBot();\n\n    links.abBot.masks.lineTo = null;\n\n    if (links.abBot.masks.armBot) {\n        destroy(links.abBot.links.armBot);\n        links.abBot.masks.armBot = null;\n    }\n\n    shout(\"abMenuRefresh\");\n\n    clearInterval(links.abBot.tags.interval);\n    links.abBot.masks.interval = setInterval(() => links.abBot.animateBot(), 2000);\n}\n\nshout('onABClick', { abBot: links.abBot, dimension: links.abBot.tags.dimension, menu, shiftKey: !!state, reset });","abIgnore":"true","ask":"ðŸ”—ec85c1d6-9f1a-40d4-82e1-5bd680349c27","askButton":"@if (!tags.abAwake)\n{\n    return;\n}\n\nlet abMenuButton = {};\n\nabMenuButton.abMenu = true;\nabMenuButton.remember = links.menu.tags.remember;\nabMenuButton.manifestation = links.menu.tags.manifestation;\nabMenuButton.abMenuRefresh = \"@ destroy(thisBot);\";\nabMenuButton.baseSkill = \"ðŸ”—\" + links.ask.id;\nabMenuButton.label = links.ask.tags.abCoreMenuLabel;\nabMenuButton.formAddress = links.ask.tags.abCoreMenuIcon;\nabMenuButton.onCreate = links.ask.tags.abCoreMenuOnGenerate;\nabMenuButton.abMenuSortOrder = links.ask.tags.abCoreMenuSortOrder;\nabMenuButton.color = links.ask.tags.abCoreMenuColor ? links.ask.tags.abCoreMenuColor : links.personality.tags.abBaseStrokeColor;\n\nlinks.menu.abCreateMenuButton(abMenuButton);","abBotChat":"@if (!links.abBot && !that.bot)\n{\n    return;\n}\n\nconst botBase = that.bot ? that.bot: links.abBot;\nconst dimension = !that.bot ? botBase.tags.dimension : that.dimension ? that.dimension : configBot.tags.gridPortal;\nconst message = that.message;\nconst messageTime = that.time ? that.time * 1000 : 1600; \n\nconst messageBot = await links.bot_factory.abCreateBillboardLabel({\n    bot: botBase,\n    label: message,\n    dimension,\n    messageTime,\n    color: \"#000000\",\n    labelColor: \"#ffffff\",\n    onBotAdded: `@\n        await os.sleep(tags.messageTime);\n        thisBot.onFade();\n    `,\n    onFade: `@\n        animateTag(thisBot, {\n            fromValue: {\n                formOpacity: 1,\n                labelOpacity: 1,\n                [tags.dimension + \"Z\"]: tags[tags.dimension + \"Z\"]\n            },\n            toValue: {\n                formOpacity: 0,\n                labelOpacity: 0,\n                [tags.dimension + \"Z\"]: tags[tags.dimension + \"Z\"] + 5\n            },\n            duration: ${that.duration ?? 3}\n        })\n        .catch((e) => {})\n        .finally(() => {\n            destroy(thisBot);\n        })\n\n    `,\n});","abVersion":"10.34","animation":"ðŸ”—b26e1089-172d-45a9-8d22-05c3f58c2bf7","onAnyBotClicked":"@if (!links.remember.tags.abRightClickDisabled && !that.bot.tags.abRightClickIgnore && that.modality == \"mouse\" && that.buttonId == \"right\") {\n    if (!tags.abAwake) {\n        return;\n    }\n\n    // ab selected\n    if (that.bot == links.abBot) {\n        links.menu.abEnvironmentMenu();\n        return;\n    }    \n    \n    const armBot = ab.links.arm_tool.abCreateArm({\n        originBot: links.abBot,\n        dimension: that.dimension,\n        position: that.position,\n    })\n\n    const botPosition = getBotPosition(that.bot, that.dimension);\n\n    // Fake user dropping the selecting the bot with the arm.\n    armBot.onDrop({\n        bot: armBot,\n        to: {\n            bot: that.bot,\n            x: botPosition.x,\n            y: botPosition.y,\n            z: botPosition.z,\n            dimension: that.dimension\n        },\n        from: {\n            x: botPosition.x,\n            y: botPosition.y,\n            z: botPosition.z,\n            dimension: that.dimension\n        }\n    });\n\n    return;\n}","input":"ðŸ”—f8602878-c2ef-48bd-85a0-8d6351eb4120","personality":"ðŸ”—b76dfbc4-854b-4f6d-a91f-a948694774db","abPersonality":"true","abSetAwake":"@let awake = that?.awake;\nlet initial = that?.initial ?? false;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nassert(typeof awake === 'boolean', `[${tags.system}.${tagName}] awake is a required boolean parameter.`);\n\nif (configBot.tags.abStayAwake) {\n    // If abStayAwake is enabled, override the incoming awake parameter and never let ab be put to sleep.\n    awake = true;\n}\n\nif (tags.abAwake !== awake) {\n    if (initial) {\n        // Load up some core ab skills.\n        const skillArray = [\"abPersonality\", \"abInterface\", \"abAction\", \"abTests\"];\n\n        for (let i = 0; i < skillArray.length; i++) {\n            await links.learn.abAdapt(skillArray[i]);\n        }\n\n        await os.sleep(300);\n\n        if (configBot.tags.pattern) {\n            links.remember.tags.baseAB = configBot.tags.pattern;\n        } else {\n            links.remember.tags.baseAB = uuid();\n        }\n        \n        // Play initial animation if one is defined on abConfig.\n        if (links.remember.tags.abInitialAnimation) {\n            await links.animation[links.remember.tags.abInitialAnimation]();\n        }\n        \n        // Show initial message if one is defined on abConfig.\n        if (links.remember.tags.abInitialMessage) {\n            shout(\"showConsole\");\n\n            if (Array.isArray(links.remember.tags.abInitialMessage)) {\n                for (let i = 0; i < links.remember.tags.abInitialMessage.length; i++) {\n                    ab.log(links.personality.tags.abBuilderIdentity + \": \" + links.remember.tags.abInitialMessage[i]);\n\n                    await os.sleep(2000);\n                }\n            }\n            else {\n                ab.log(links.personality.tags.abBuilderIdentity + \": \" + links.remember.tags.abInitialMessage);\n            }\n        }\n    }\n\n    // Update abAwake shared tag mask.\n    setTagMask(thisBot, 'abAwake', awake, 'shared');\n    \n    if (awake) {\n        let dimension = configBot.tags.mapPortal ? configBot.tags.mapPortal : configBot.tags.gridPortal;\n\n        if (!dimension) {\n            return;\n        }\n\n        await thisBot.abManifestBot({ dimension, position: { x: 0, y: 0 } });\n\n        shout(\"onABAwake\", { dimension, position: { x: 0, y: 0 } });\n    } else {\n        destroy(links.abBot);\n\n        shout(\"abMenuRefresh\");\n        shout(\"onABSleep\");\n    }\n}","utils":"ðŸ”—93d965e0-d20e-4b45-8ca0-649273b7138c","bot_factory":"ðŸ”—c78aa663-d05c-4ec4-bc2c-26fd51560b97","onABInitialized":"@if (configBot.tags.mapPortal) {\r\n    thisBot.onPortalChanged({portal: \"mapPortal\", dimension: configBot.tags.mapPortal});\r\n}","debug":"false"}}}}