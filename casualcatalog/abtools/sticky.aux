{"version":1,"state":{"83549396-5503-4131-9e05-7f0e6da3b8fd":{"id":"83549396-5503-4131-9e05-7f0e6da3b8fd","space":"shared","tags":{"abIgnore":true,"abToolbox":"true","abVersion":"9.65.1.1728323928059","avoidDelete":true,"checkForUI":"@if (tags.checkingForStickyUI) return;\n\ntags.checkingForStickyUI = true;\n\nconst stickyAppBot = getBot(\"system\", \"stickies.app\");\nif (!stickyAppBot) {\n    await links.search.abLoadTool({ toolName: 'stickiesApp' });\n} else {\n    if (tags.firstLoad) {\n        tags.firstLoad = false;\n        let stickyAppBot = getBot(\"system\", \"stickies.app\");\n        whisper(stickyAppBot, \"showNoteEditor\", thisBot);\n        \n    }  \n}\n\ntags.checkingForStickyUI = null;","color":"#f9c74f","deselect":"@masks.formOpacity = null;\nmasks.homeZ = null;\nmasks.selected = null;\nmasks.strokeColor = 'clear';\nmasks.strokeWidth = null;","dimension":"home","firstLoad":"true","handleUpdate":"@// Initialize updatesNeeded array if it doesn't exist\nconst stickyApp = getBot(\"system\", \"stickies.app\")\nif (!Array.isArray(stickyApp.tags.updatesNeeded)) { stickyApp.tags.updatesNeeded = [] }\n// Add this bot to the updatesNeeded array\nstickyApp.tags.updatesNeeded.push(thisBot.id);\n\nif (configBot.id !== stickyApp.tags.playerList[0]) {\n    console.log(\"[stickies] Avoiding update\")\n    os.sleep(5000).then(async () => {\n        console.log(\"[stickies] checking that update happened\")\n        if (getBot(\"system\", \"stickies.app\").tags.updatesNeeded.includes(thisBot.id)) {\n            console.log(\"[stickies] update was lost, updating list of players\")\n            // Reset the list of remotes\n            await whisper(stickyApp, \"onInit\");\n            // Re-try the update\n            whisper(thisBot, \"handleUpdate\");\n            return;\n        }\n        console.log(\"[stickies] update was successful\")\n    })\n    return\n}\n\nconsole.log(\"[stickies] claiming update\")\nstickyApp.tags.updatesNeeded = stickyApp.tags.updatesNeeded.filter(u => u !== thisBot.id);\n\n// Add address if it doesn't exist yet\nconst authBot = await os.requestAuthBot();\nif (!tags.stickyAddress) tags.stickyAddress = thisBot.id + '-' + new Date().toISOString();\n\nconst stickyRecord = tags.stickyRecord;\nif (!stickyRecord) {\n    os.toast(\"Error updating sticky note\");\n    throw new Error(\"Tried to update a sticky note, but no record is selected\");\n}\n\n// Grant record permission\nif (!Array.isArray(stickyApp.vars.recordPermissions)) {\n    stickyApp.vars.recordPermissions = [];\n}\n\nif (!stickyApp.vars.recordPermissions.includes(stickyRecord)) {\n    if (await os.grantInstAdminPermission(stickyRecord)) {\n        stickyApp.vars.recordPermissions.push(stickyRecord)\n    }\n}\n\n// Trim data\nconst payload = {...thisBot.tags};\nconst tagsToDelete = tags.unstoredTags;\nfor (var t of tagsToDelete) {\n    delete payload[t];\n}\n\n// Check if changed\nconst hash = crypto.hash(\"sha256\", \"base64\", JSON.stringify(payload));\nif (hash === tags.lastUpdateHash) { return };\ntags.lastUpdateHash = hash;\n\n// Record definition\nconst stickyRecordName = stickyRecord;\nlet address = tags.stickyAddress\nif (!address) {\n    address = thisBot.id + '-' + new Date().toISOString();\n    tags.stickyAddress = address;\n}\n\n// Update in records\nconst result = await os.recordData(stickyRecord, address, payload);\nif (result.success) {\n    console.log(\"[stickies] [stickies] Updated sticky note!\")\n    return { success: true }\n} else if (result.errorCode === \"record_not_found\") {\n    const createResult = await os.getPublicRecordKey(stickyRecord);\n    if (createResult.success) {\n        whisper(thisBot, 'handleUpdate')\n    }\n} else if (result.errorCode === \"not_authorized\") {\n    if (await os.grantInstAdminPermission(stickyRecord)) {\n        whisper(thisBot, 'handleUpdate');\n    }\n} else {\n    os.toast(\"Failed to update sticky note\");\n    console.log(\"[stickies] [stickies] Failed to update sticky note:\", result)\n    return { success: false }\n}\n","interruptSync":"@if (thisBot.vars.cancelTimeout) {\n    clearTimeout(thisBot.vars.cancelTimeout);\n}","labelColor":"#000000","labelPaddingX":0.24,"labelPaddingY":0.12,"lastUpdateHash":"Qxv5WUWaQ44CWURCMr2nw6Q0QDwP1nw039lcNJ7vyJo=","lineColor":"#000000","lineWidth":4,"listening":true,"onAnyBotClicked":"@if (\n    that.bot.id !== thisBot.id &&\n    !(configBot.tags.keyboard_Shift === 'held')\n) {\n    whisper(thisBot, 'onDeselect');\n}","onBotChanged":"@// Don't track if no record\nif (!tags.stickyRecord) { return }\n\n// Don't update for masks\nif (masks) {\n    if (Object.keys(masks).some(m => that.tags.indexOf(m) >= 0)) {\n        return\n    }\n}\n\n// Don't update unstored tags\nif (tags.unstoredTags.some(m => that.tags.indexOf(m) >= 0)) {\n    return\n}\n\n// Clear previous timer\nif (thisBot.vars.cancelTimeout) {\n    clearTimeout(thisBot.vars.cancelTimeout);\n}\n\n// Start 5s timer to update\nthisBot.vars.cancelTimeout = setTimeout(() => {\n    thisBot.vars.cancelTimeout = null;\n    whisper(thisBot, \"handleUpdate\");\n}, 5000);","onClick":"@// First click\nif (!thisBot.vars.doubleClickTimer) {\n    if (masks.selected && !masks.justSelected) {\n        const selectedBots = getBots(\"selected\");\n        if (selectedBots.length === 1 || configBot.tags.keyboard_Shift) {\n            whisper(thisBot, \"onDeselect\");\n        }\n    }\n    thisBot.vars.doubleClickTimer = true;\n    thisBot.vars.clickTimeout = setTimeout(() => {\n        thisBot.vars.doubleClickTimer = null;\n    }, 500);\n\n    let stickyAppBot = getBot(\"system\", \"stickies.app\");\n    whisper(stickyAppBot, \"setStickyHighlight\", [bot.id]);\n\n    return;\n}\n\n// Second click\nif (!configBot.tags.keyboard_Shift) {\n    whisper(thisBot, 'onDeselect');\n\n    let stickyAppBot = getBot(\"system\", \"stickies.app\");\n    whisper(stickyAppBot, \"showNoteEditor\", thisBot);\n}","onCreate":"@if (tags.abIDOrigin == \"sticky\" && tags.system != \"toolbox1.tool.sticky\") {\n    tags.firstLoad = true;\n}\n\nwhisper(thisBot, 'checkForUI');\n\nconst stickyData = {...thisBot.tags};\nconst unstoredTags = tags.unstoredTags;\nfor (var t of unstoredTags) {\n    delete stickyData[t];\n}\n\ntags.abIgnore = true;\n\ntags.lastUpdateHash = crypto.hash(\"sha256\", \"base64\", JSON.stringify(stickyData));","onDeselect":"@masks.formOpacity = null;\nmasks.startingZ = null;\nmasks.homeZ = null;\nmasks.selected = null;\nmasks.strokeColor = 'clear';\nmasks.strokeWidth = null;","onDestroy":"@if (tags.avoidDelete) return;\n\nconst result = os.eraseData(tags.stickyRecord, tags.stickyAddress);\n\nif (!result.success) {\n    return\n}","onDrag":"@os.enableCustomDragging();\nlet selectedBots = [];\nif (masks.justSelected && !configBot.tags.keyboard_Shift) {\n    shout('onDeselect');\n    whisper(thisBot, 'onSelect');\n    selectedBots.push(thisBot);\n} else {\n    selectedBots = getBots(\"selected\");\n}\n\nthisBot.vars.selectedBots = selectedBots;\nsetTagMask(selectedBots, 'pointable', false);\n\nconst dim = os.getCurrentDimension();\nthisBot.vars.dimension = dim;\n\nthisBot.vars.dragStart = {x: tags[`${dim}X`] ?? 0, y: tags[`${dim}Y`] ?? 0};\n\nconst startingPoints = {};\nfor (var b of selectedBots) {\n    startingPoints[b.id] = {x: b.tags[`${dim}X`] ?? 0, y: b.tags[`${dim}Y`] ?? 0}\n}\nthisBot.vars.startingPoints = startingPoints;","onDragging":"@const dim = thisBot.vars.dimension;\nconst deltaX = that.to.x - thisBot.vars.dragStart.x;\nconst deltaY = that.to.y - thisBot.vars.dragStart.y;\n\nfor (var b of thisBot.vars.selectedBots) {\n    b.tags[`${dim}X`] = Number(thisBot.vars.startingPoints[b.id].x + deltaX);\n    b.tags[`${dim}Y`] = Number(thisBot.vars.startingPoints[b.id].y + deltaY);\n}\n\n\nlet selBots = getBots(\"selected\", true);\n\nif(selBots.length == 1){\n    let stickyArrowBots = getBots(\"botID\", \"stickyArrowNode\");\n    whisper(stickyArrowBots, \"onStickyUpdated\", bot.id);\n\n    let stickyScaleBots = getBots(\"botID\", \"stickyScaleNode\");\n    whisper(stickyScaleBots, \"onStickyUpdated\", bot.id);\n}\nelse{\n    for(let i = 0; i < selBots.length; i++){\n        let stickyArrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"stickyBotID\",selBots[i].id));\n        whisper(stickyArrowBots, \"onStickyUpdated\", selBots[i].id);\n\n        let stickyScaleBots = getBots(byTag(\"botID\", \"stickyScaleNode\"), byTag(\"stickyBotID\",selBots[i].id));\n        whisper(stickyScaleBots, \"onStickyUpdated\", selBots[i].id);\n    }\n}","onDrop":"@setTagMask(thisBot.vars.selectedBots, 'pointable', null);\nthisBot.vars.selectedBots = null;\nthisBot.vars.dimension = null;\nthisBot.vars.startingPoints = null;\nthisBot.vars.dragStart = null;\n\nif (masks.justSelected) {\n    whisper(thisBot, \"onDeselect\")\n}","onDuplicate":"@if (tags.selected) {\n    const payload = {...tags};\n    delete payload.stickyAddress;\n    delete payload[`${os.getCurrentDimension()}Z`];\n    delete payload.strokeColor;\n    delete payload.strokeWidth;\n    delete payload.selected;\n\n    payload[`${os.getCurrentDimension()}X`] += 1;\n    const newSticky = create(payload);\n    whisper(newSticky, 'onPointerDown');\n    whisper(newSticky, 'onSelect');\n    whisper(newSticky, 'handleUpdate');\n}","onEggHatch":"@if (that.eggParameters) {\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\n\n    tags[dimension] = true;\n    tags[dimension + 'X'] = dimensionX;\n    tags[dimension + 'Y'] = dimensionY;\n}\n","onGridClick":"@whisper(thisBot, 'onDeselect');","onKeyDown":"@if (configBot.tags.keyboard_Meta === 'held' ||\n    configBot.tags.keyboard_Control === 'held'\n) {\n    // Duplicate\n    if (that.keys.includes('d')) {\n        whisper(thisBot, 'onDuplicate')\n    }\n}\n","onPointerDown":"@if (!masks.selected) {\n    whisper(thisBot, \"onSelect\");\n    masks.justSelected = true;\n}","onPointerEnter":"@if (!masks.selected) {\n    masks.formOpacity = 0.85\n}","onPointerExit":"@masks.formOpacity = null","onPointerUp":"@masks.justSelected = null;\nif (!masks.selected) {\n    masks.homeZ = null;\n}","onSelect":"@masks.selected = true;\nmasks.formOpacity = null;\nmasks.strokeColor = \"#4bb1db\";\nmasks.strokeWidth = 2;\n\nif (!masks.startingZ) masks.startingZ = tags.homeZ ?? 0;\nmasks.homeZ = masks.startingZ + 0.15;","pointable":true,"position":{"x":7,"y":2},"scaleX":"1","scaleY":"1","scaleZ":0.125,"select":"@masks.selected = true;\nmasks.formOpacity = null;\nmasks.strokeColor = \"#4bb1db\"\nmasks.strokeWidth = 2;","sim_toolbox":true,"sim_toolboxX":-0.5000000000000003,"sim_toolboxY":-7.500000000000001,"startingZ":0,"stickiesAppLoaded":"@if (tags.firstLoad) {\r\n    tags.firstLoad = false;\r\n    shout(\"showNoteEditor\", thisBot);\r\n}","sticky":true,"system":"sticky.sticky","toolbox1":"true","unstoredTags":["abIDOrigin","avoidDelete","checkForUI","creator","handleUpdate","interruptSync","lastUpdateHash","onAnyBotClicked","onBotChanged","onClick","onCreate","onDeselect","onDestroy","onDrag","onDragging","onDrop","onDuplicate","onGridClick","onKeyDown","onPointerDown","onPointerEnter","onPointerExit","onPointerUp","onSelect","strokeColor","strokeWidth","selected"],"version":"0.2","search":"🔗d8371444-9158-4436-8fc7-84cc91b7f525","home":null,"homeX":null,"homeY":null,"checkingForStickyUI":null,"label":null}}}}