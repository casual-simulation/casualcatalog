{"version":1,"state":{"c61eef7c-a47c-42b9-8e08-c59cd3f6301b":{"id":"c61eef7c-a47c-42b9-8e08-c59cd3f6301b","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"abParticleEmitter.emitter","home":true,"homeX":-3,"homeY":3,"color":"#ff8800","scale":0.5,"form":"sphere","particleBurstInterval":"0.15","particleLifetimeVariance":0.5,"particleSpeedMin":"0.3","particleSpeedMax":"1.2","particleDirectionX":"0","particleDirectionY":"0","particleDirectionZ":"1","particleSpread":"180","particleGravity":-0.4,"particleScaleStart":0.25,"particleScaleEnd":0.02,"particleScaleVariance":0.08,"particleColorStart":"#ffcc00","particleColorEnd":"#ff2200","particleOpacityStart":1,"particleOpacityEnd":0,"particleForm":"sprite","particleLoop":"true","intervalRate":50,"onDestroy":"@thisBot.abParticleReset();","onTick":"@if (tags.particlePause) return;\n\nconst dt = 0.05;\nlet elapsed = thisBot.vars.particleElapsed + dt;\nlet burstTimer = thisBot.vars.particleBurstTimer + dt;\nconst dim = \"home\";\n\nthisBot.vars.particleElapsed = elapsed;\n\n// Parse alive particle IDs\nlet pIds = thisBot.vars.particleIds ?? [];\n\n// Clean up dead particles\nconst aliveIds = [];\nfor (const entry of pIds) {\n    const p = getBot(\"id\", entry.id);\n    if (p) {\n        entry.age += dt;\n        if (entry.age >= entry.life) {\n            destroy(p);\n        } else {\n            // Update particle\n            const t = entry.age / entry.life;\n            const cs = tags.particleColorStart ?? \"#ffffff\";\n            const ce = tags.particleColorEnd ?? \"#ffffff\";\n            const os_ = tags.particleOpacityStart ?? 1;\n            const oe = tags.particleOpacityEnd ?? 0;\n            const ss = entry.scaleStart;\n            const se = tags.particleScaleEnd ?? 0.02;\n\n            // Lerp scale\n            const sc = ss + (se - ss) * t;\n            setTagMask(p, \"scale\", Math.max(0.001, sc));\n\n            // Lerp opacity\n            const op = os_ + (oe - os_) * t;\n            setTagMask(p, \"formOpacity\", Math.max(0, Math.min(1, op)));\n\n            // Lerp color (simple hex lerp)\n            setTagMask(p, \"color\", lerpColor(cs, ce, t));\n\n            // Move\n            const grav = tags.particleGravity ?? 0;\n            const curZ = getTag(p, dim + \"Z\") ?? 0;\n            entry.vz = (entry.vz || 0) + grav * dt;\n            setTagMask(p, dim + \"X\", getTag(p, dim + \"X\") + entry.vx * dt);\n            setTagMask(p, dim + \"Y\", getTag(p, dim + \"Y\") + entry.vy * dt);\n            setTagMask(p, dim + \"Z\", curZ + entry.vz * dt);\n\n            aliveIds.push(entry);\n        }\n    }\n}\n\n// Burst emission\nif (burstTimer >= (tags.particleBurstInterval ?? 0.15) && tags.particleOn) {\n    burstTimer = 0;\n    const rate = tags.particleRate ?? 5;\n    const maxP = tags.particleMaxCount ?? 60;\n    const toSpawn = Math.min(rate, maxP - aliveIds.length);\n\n    for (let i = 0; i < toSpawn; i++) {\n        const life = (tags.particleLifetime ?? 1.5) + (Math.random() - 0.5) * 2 * (tags.particleLifetimeVariance ?? 0);\n        const speed = (tags.particleSpeedMin ?? 0.3) + Math.random() * ((tags.particleSpeedMax ?? 1.2) - (tags.particleSpeedMin ?? 0.3));\n        const spreadRad = ((tags.particleSpread ?? 360) / 360) * Math.PI;\n\n        // Random direction within spread cone\n        const baseDx = tags.particleDirectionX ?? 0;\n        const baseDy = tags.particleDirectionY ?? 0;\n        const baseDz = tags.particleDirectionZ ?? 1;\n\n        const theta = (Math.random() - 0.5) * 2 * spreadRad;\n        const phi = Math.random() * Math.PI * 2;\n\n        const sinT = Math.sin(theta);\n        const vx = baseDx * speed + sinT * Math.cos(phi) * speed * 0.5;\n        const vy = baseDy * speed + sinT * Math.sin(phi) * speed * 0.5;\n        const vz = baseDz * speed * Math.cos(theta);\n\n        const scStart = (tags.particleScaleStart || 0.25) + (Math.random() - 0.5) * 2 * (tags.particleScaleVariance || 0);\n\n        const particleMod = {\n            space: \"tempLocal\",\n            [dim]: true,\n            [dim + \"X\"]: getTag(thisBot, dim + \"X\") ?? 0,\n            [dim + \"Y\"]: getTag(thisBot, dim + \"Y\") ?? 0,\n            [dim + \"Z\"]: 0.1,\n            form: tags.particleForm ?? \"sprite\",\n            formAddress: tags.particleFormAddress ?? null,\n            formSubtype: tags.particleFormSubtype ?? null,\n            pointable: false,\n            color: tags.particleColorStart ?? \"#ffcc00\",\n            formOpacity: tags.particleOpacityStart ?? 1,\n            scale: Math.max(0.001, scStart),\n            _particleOwner: thisBot.id,\n            orientationMode: tags.particleBillboard ? 'billboard' : null,\n        };\n\n        const np = create(particleMod);\n\n        aliveIds.push({\n            id: np.id,\n            age: 0,\n            life: Math.max(0.1, life),\n            vx: vx,\n            vy: vy,\n            vz: vz,\n            scaleStart: scStart\n        });\n    }\n\n    // For one-shot mode, stop after first burst sequence\n    if (!tags.particleLoop) {\n        tags.particleOn = false;\n    }\n}\n\nthisBot.vars.particleBurstTimer = burstTimer;\nthisBot.vars.particleIds = aliveIds;\n\n// Color lerp helper\nfunction lerpColor(a, b, t) {\n    t = Math.max(0, Math.min(1, t));\n    const pa = parseHex(a);\n    const pb = parseHex(b);\n    const r = Math.round(pa.r + (pb.r - pa.r) * t);\n    const g = Math.round(pa.g + (pb.g - pa.g) * t);\n    const bl = Math.round(pa.b + (pb.b - pa.b) * t);\n    return \"#\" + toHex(r) + toHex(g) + toHex(bl);\n}\nfunction parseHex(hex) {\n    hex = hex.replace(\"#\", \"\");\n    if (hex.length === 3) hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    return { r: parseInt(hex.substr(0, 2), 16), g: parseInt(hex.substr(2, 2), 16), b: parseInt(hex.substr(4, 2), 16) };\n}\nfunction toHex(n) { const h = n.toString(16); return h.length < 2 ? \"0\" + h : h; }","homeZ":0,"abIDOrigin":"ab-particle-emitter","onBotAdded":"@thisBot.vars.particleElapsed = 0;\nthisBot.vars.particleBurstTimer = 0;\n\nif (tags.particleStartOn) {\n    if (tags.particleOn !== true) {\n        tags.particleOn = true;\n    } \n}","formOpacity":"0.3","particleBillboard":"true","particleStartOn":"true","onBotChanged":"@let onChanged = false;\nlet pauseChanged = false;\n\nfor (let tag of that.tags) {\n    if (tag === 'particleOn') {\n        onChanged = true;\n    } else if (tag === 'particlePause') {\n        pauseChanged = true;\n    }\n}\n\nif (onChanged) {\n    if (tags.particleOn) {\n        thisBot.vars.particleElapsed = 0;\n        thisBot.vars.particleBurstTimer = 0;\n        os.toast(\"▶ Emitter ON\");\n    } else {\n        os.toast(\"⏹ Emitter OFF\");\n    }\n}\n\nif (pauseChanged) {\n    if (tags.particlePause) {\n        os.toast(\"▶ Emitter PAUSE\");\n    } else {\n        os.toast(\"▶ Emitter RESUME\");\n    }\n}","particleOn":"true","particlePause":"false","abParticleReset":"@let pIds = thisBot.vars.particleIds ?? [];\n\nfor (const entry of pIds) {\n    destroy(entry.id);\n}\n\nthisBot.vars.particleElapsed = 0;\nthisBot.vars.particleBurstTimer = 0;","particleMaxCount":"60","particleLifetime":"1.5","particleRate":"5","abParticleEmitter":"true","abArtifactName":"abParticleEmitter","onABArtifactCollectShards":null}}}}