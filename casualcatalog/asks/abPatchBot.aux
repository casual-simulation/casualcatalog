{"version":1,"state":{"33219dc1-1201-4f39-aba6-30ba7b707ef9":{"id":"33219dc1-1201-4f39-aba6-30ba7b707ef9","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"abPatchBot.template","onClick":"@thisBot.abPatchMenuOpen();\nthisBot.animateSpin();","abPatchMenuOpen":"@shout('abPatchMenuReset');\n\nconfigBot.masks.menuPortal = 'abPatchMenu';\n\n// This bot handles removing this menu if the patch bot that created it gets destroyed.\ncreate({\n    space: 'tempLocal',\n    patchBotId: thisBot.id,\n    abPatchMenuReset: `@destroy(thisBot)`,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (botIDs.includes(tags.patchBotId)) {\n            shout('abPatchMenuReset');\n        }\n    `,\n})\n\nif (tags.abPatchInvalid) {\n    const patchMenuGroup = {\n        groupSortOrder: 100,\n        abPatchMenu: true,\n        abPatchMenuReset: `@destroy(thisBot)`,\n        patchBot: getLink(thisBot),\n        color: tags.abPatchColor,\n        menuItems: [\n            {\n                label: 'dispose patch',\n                formAddress: 'error',\n                onClick: `@\n                    destroy(links.patchBot);\n                `\n            },\n        ]\n    }\n\n    ab.links.menu.abCreateMenuGroup(patchMenuGroup);\n} else {\n    const patchMenuGroup = {\n        groupSortOrder: 100,\n        abPatchMenu: true,\n        abPatchMenuReset: `@destroy(thisBot)`,\n        patchBot: getLink(thisBot),\n        color: tags.abPatchColor,\n        menuItems: [\n            {\n                label: 'approve patch',\n                formAddress: 'done',\n                onClick: `@\n                    if (links.patchBot.tags.abPatchBotInstance) {\n                        whisper(links.patchBot, 'onABPatchApproveClick');\n                    } else {\n                        os.toast('do nothing: this is a patch bot template');\n                    }\n                `\n            },\n            {\n                label: 'undo patch',\n                formAddress: 'undo',\n                onClick: `@\n                    if (links.patchBot.tags.abPatchBotInstance) {\n                        whisper(links.patchBot, 'onABPatchUndoClick');\n                    } else {\n                        os.toast('do nothing: this is a patch bot template');\n                    }\n                `\n            }\n        ]\n    }\n\n    const allPatchesMenuGroup = {\n        groupSortOrder: 200,\n        abPatchMenu: true,\n        abPatchMenuReset: `@destroy(thisBot)`,\n        patchBot: getLink(thisBot),\n        color: tags.abPatchColor,\n        menuItems: [\n            {\n                label: 'approve all patches',\n                formAddress: 'done_all',\n                onClick: `@\n                    if (links.patchBot.tags.abPatchBotInstance) {\n                        whisper(links.patchBot, 'onABPatchApproveAllClick');\n                    } else {\n                        os.toast('do nothing: this is a patch bot template');\n                    }\n                `\n            },\n            {\n                label: 'undo all patches',\n                formAddress: 'fast_rewind',\n                onClick: `@\n                    if (links.patchBot.tags.abPatchBotInstance) {\n                        whisper(links.patchBot, 'onABPatchUndoAllClick');\n                    } else {\n                        os.toast('do nothing: this is a patch bot template');\n                    }\n                `\n            }\n        ]\n    }\n\n    ab.links.menu.abCreateMenuGroup(patchMenuGroup);\n    ab.links.menu.abCreateMenuGroup(allPatchesMenuGroup);\n}","abPatchMenuReset":"@if (configBot.masks.menuPortal === 'abPatchMenu') {\n    configBot.masks.menuPortal = null;\n}","onGridClick":"@shout('abPatchMenuReset');","onEggHatch":"@if (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nconst sourceEvent = that?.sourceEvent;\n\nif (sourceEvent === 'ask_gpt') {\n    const patchCode = that.eggParameters.patchCode;\n    const askInput = that.eggParameters.askInput;\n    const dimension = that.eggParameters.dimension;\n    const position = that.eggParameters.position;\n    const alwaysApprove = that.eggParameters.alwaysApprove ?? false;\n\n    tags.abIgnore = true;\n    tags.abPatchBotInstance = true;\n    tags.abPatchCode = `@${patchCode}`;\n    tags.abPatchBotIdentity = `patch ${thisBot.id.substring(0, 5)}`;\n    tags.abPatchLabel = tags.abPatchBotIdentity;\n    tags.system = `abPatchBot.${tags.abPatchBotIdentity}`;\n    tags[dimension] = true;\n    tags[dimension + 'X'] = position?.x ?? 0;\n    tags[dimension + 'Y'] = position?.y ?? 0;\n    tags[dimension + 'Z'] = position?.z ?? 0;\n\n    try {\n        await thisBot.abPatchApply();\n    } finally {\n        if (alwaysApprove) {\n            whisper(thisBot, 'onABPatchApproveClick');\n        }\n    }\n\n    const abBot = ab.links.manifestation.links.abBot;\n    if (abBot) {\n        const abBotPosition = getBotPosition(abBot, dimension);\n        if (abBotPosition.x == position.x && \n            abBotPosition.y == position.y &&\n            abBotPosition.z == position.z\n        ) {\n            if (!configBot.tags.abStayAwake) {\n                // If the ab bot is in the current position of this patch bot, hide the ab bot.\n                destroy(ab.links.manifestation.links.abBot);\n            }\n\n            // If the ab bot didn't move, automatically open the menu for this new patch bot.\n            thisBot.abPatchMenuOpen();\n        }\n    }\n}\n","abPatchApply":"@if (tags.abPatchApplied || tags.abPatchApplying) {\n    return;\n}\n\nif (typeof thisBot.abPatchCode === 'function') {\n    try {\n        tags.abPatchApplying = true;\n        const abPatchResults: ABPatchResult[] = await thisBot.abPatchCode();\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] patch results:`, abPatchResults);\n        }\n\n        // Store the patch results on this patch bot.\n        tags.abPatchResults = `ðŸ§¬${JSON.stringify(abPatchResults, undefined, 4)}`;\n\n        // For all patched bots, remove the 'creator' tag on them if the creator was this patch bot.\n        // We don't want our patched bots to get destroyed when this patch bot is destroyed.\n        for (const result of abPatchResults) {\n            const bot = getBot('id', result.botId);\n            \n            if (bot && bot.tags.creator === thisBot.id) {\n                bot.tags.creator = null;\n            }\n        }\n\n        tags.abPatchApplied = true;\n        tags.abPatchAppliedTimestamp = os.isCollaborative() ? os.agreedUponTime : os.localTime;\n        tags.lineTo = getLink(abPatchResults.map(r => getBot('id', r.botId)));\n    } catch (e) {\n        ab.links.utils.abLogAndToast({ name: tags.patchLabel, message: `Something went wrong applying patch â€” ${ab.links.utils.getErrorMessage(e)}`, logType: 'error' });\n    } finally {\n        tags.abPatchApplying = null;\n    }\n} else {\n    ab.links.utils.abLogAndToast({ name: tags.patchLabel, message: `Cannot apply patch â€” patch code is invalid.`, logType: 'error' });\n    tags.abPatchInvalid = true;\n}","abPatchUndo":"@if (!tags.abPatchApplied || tags.abPatchApplying) {\n    return;\n}\n\nconst abPatchResults: ABPatchResult[] = tags.abPatchResults;\n\nif (abPatchResults && abPatchResults.length > 0) {\n    for (let result of abPatchResults) {\n        const patchedBot = getBot('id', result.botId);\n\n        if (patchedBot) {\n            if (result.created) {\n                // This patch created the bot, to undo it we destroy it.\n                destroy(patchedBot);\n                destroy(thisBot);\n            } else if (result.rollbackDiff) {\n                // This patch modified the bot, to undo it we apply all the the tags and masks in the rollback diff to the bot.\n                const rollbackBotData = result.rollbackDiff[patchedBot.id];\n                const rollbackTags = rollbackBotData.tags;\n                const rollbackMasks = rollbackBotData.masks;\n\n                if (rollbackTags) {\n                    for (const tagName in rollbackTags) {\n                        setTag(patchedBot, tagName, rollbackTags[tagName]);\n                    }\n                }\n\n                if (rollbackMasks) {\n                    for (const space in rollbackMasks) {\n                        if (space === 'remoteTempShared') {\n                            // Cant set remoteTempShared masks, they are owned by someone else.\n                            continue;\n                        }\n\n                        for (const tagName in rollbackMasks[space]) {\n                            setTagMask(patchedBot, tagName, rollbackMasks[space][tagName], space);\n                        }\n                    }\n                }\n\n                // After tags and masks have been rolled back, destroy this patch bot.\n                destroy(thisBot);\n            } else {\n                ab.links.utils.abLogAndToast({ message: `Cannot undo ${tags.abPatchBotIdentity}. Something went wrong during patch process? No data found to undo changes.`, logType: 'warning' });\n            }\n        } else {\n            // Patched bot not found, quietly destroy the patch bot.\n            destroy(thisBot);\n        }\n    }\n}","abPatchColor":"#FFFFFF","cursor":"pointer","abPatchBot":true,"formOpacity":"0.33","strokeColor":"#FFFFFF","color":"#FFFFFF","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nmasks.ready = true;\n\nthisBot.updateBillboardLabel();","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nconst currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nconst botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\nif (botInDimension) {\n    thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n        bot: thisBot,\n        label: tags.abPatchLabel,\n        color: tags.abPatchColor,\n        dimension: currentDimension,\n        labelColor: '#000000',\n        space: 'tempLocal',\n    })\n}\n\n","onBotChanged":"@const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nconst needUpdateBillboardLabel = that.tags.some(t => t === 'abPatchLabel' || t === 'abPatchColor' || t === currentDimension);\n\nif (needUpdateBillboardLabel && tags.ready) {\n    thisBot.updateBillboardLabel();\n}","abPatchLabel":"patch bot template","abPatchBotIdentity":"","onABPatchApproveClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    destroy(thisBot);\n}","onABPatchUndoClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    thisBot.abPatchUndo();\n}","types":"ðŸ“„interface ABPatchResult {\n    /** The id of the bot that was created / modified. */\n    botId: string;\n\n    /** Wether or not this bot was created by the patch. */\n    created: boolean;\n\n    /** \n    * A rollback diff of the bot that stores the original values of tags on the bot before the patch code was run. If the bot was created by the patch code then this must be null.\n    * \n    * Snapshots of bots can be obtained by running getSnapshot(bot) and then a rollback diff can be created by running diffSnapshots(postPatchSnapshot, prePatchSnapshot).\n    */\n    rollbackDiff: PartialBotState | null;\n}","onABPatchApproveAllClick":"@if (tags.abPatchBotInstance) {\n    shout('onABPatchApproveClick');\n}","onABPatchUndoAllClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    const abAppliedPatchBots = getBots(bot => bot.tags.abPatchBot && bot.tags.abPatchBotInstance && bot.tags.abPatchApplied);\n\n    // Sort abAppliedPatchBots by their abPatchAppliedTimestamp in descending order (most recent to oldest patch bots);\n    abAppliedPatchBots.sort((a, b) => b.tags.abPatchAppliedTimestamp - a.tags.abPatchAppliedTimestamp);\n\n    for (const abPatchBot of abAppliedPatchBots) {\n        whisper(abPatchBot, 'onABPatchUndoClick');\n    }\n}","abVersion":"10.28","debug":"false","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}"}}}}