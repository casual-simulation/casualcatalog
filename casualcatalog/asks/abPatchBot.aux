{"version":1,"state":{"611fc877-7716-485d-84b3-397803596ba9":{"id":"611fc877-7716-485d-84b3-397803596ba9","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"abPatchBot.template","onClick":"@thisBot.abPatchMenuOpen();\nthisBot.animateSpin();","abPatchMenuOpen":"@shout('abPatchMenuReset');\n\nconfigBot.masks.menuPortal = 'abPatchMenu';\n\n// This bot handles removing this menu if the patch bot that created it gets destroyed.\ncreate({\n    space: 'tempLocal',\n    patchBotId: thisBot.id,\n    abPatchMenuReset: `@destroy(thisBot)`,\n    onBotAdded: `@\n        const patchBot = getBot('id', tags.patchBotId);\n        if (!patchBot) {\n            // The patch bot was deleted before the menu opened.\n            shout('abPatchMenuReset');\n        }\n    `,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (botIDs.includes(tags.patchBotId)) {\n            shout('abPatchMenuReset');\n        }\n    `,\n})\n\n/**\n * Menu group for this patch bot.\n */\nconst patchMenuGroup = {\n    groupSortOrder: 100,\n    abPatchMenu: true,\n    abPatchMenuReset: `@destroy(thisBot)`,\n    patchBot: getLink(thisBot),\n    color: tags.abPatchColor,\n    menuItems: []\n}\n\npatchMenuGroup.menuItems.push({\n    label: `${tags.abPatchAskInput.originalUserInquiry}`,\n    menuItemType: 'text',\n    formAddress: 'notes',\n    menuItemStyle: {\n        \"padding-top\": \"6px\",\n        \"padding-bottom\": \"6px\",\n    },\n    menuItemLabelStyle: {\n        \"font-style\": \"italic\"\n    }\n});\n\nif (tags.abPatchError) {\n    patchMenuGroup.menuItems.push({\n        label: `${tags.abPatchError}`,\n        menuItemType: 'text',\n        formAddress: 'error',\n        color: 'firebrick',\n        labelColor: 'white',\n        menuItemStyle: {\n            \"padding-top\": \"6px\",\n            \"padding-bottom\": \"6px\",\n        },\n    });\n}\n\nif (tags.abPatchInvalid) {\n    patchMenuGroup.menuItems.push({\n        label: 'dispose patch',\n        formAddress: 'delete',\n        onClick: `@\n            destroy(links.patchBot);\n        `\n    });\n} else {\n    patchMenuGroup.menuItems.push({\n        label: 'approve patch',\n        formAddress: 'done',\n        onClick: `@\n            if (links.patchBot.tags.abPatchBotInstance) {\n                whisper(links.patchBot, 'onABPatchApproveClick');\n            } else {\n                os.toast('do nothing: this is a patch bot template');\n            }\n        `\n    });\n\n    patchMenuGroup.menuItems.push({\n        label: 'undo patch',\n        formAddress: 'undo',\n        onClick: `@\n            if (links.patchBot.tags.abPatchBotInstance) {\n                whisper(links.patchBot, 'onABPatchUndoClick');\n            } else {\n                os.toast('do nothing: this is a patch bot template');\n            }\n        `\n    });\n}\n\nab.links.menu.abCreateMenuGroup(patchMenuGroup);\n\n/**\n * Menu group for applying/undoing \"all\" patch bots.\n */\nif (!tags.abPatchInvalid) {\n    const abAppliedPatchBots = thisBot.abGetAppliedPatchBots();\n    \n    if (abAppliedPatchBots.length > 1) {\n        const allPatchesMenuGroup = {\n            groupSortOrder: 200,\n            abPatchMenu: true,\n            abPatchMenuReset: `@destroy(thisBot)`,\n            patchBot: getLink(thisBot),\n            color: tags.abPatchColor,\n            menuItems: [\n                {\n                    label: 'approve all patches',\n                    formAddress: 'done_all',\n                    onClick: `@\n                        if (links.patchBot.tags.abPatchBotInstance) {\n                            whisper(links.patchBot, 'onABPatchApproveAllClick');\n                        } else {\n                            os.toast('do nothing: this is a patch bot template');\n                        }\n                    `\n                },\n                {\n                    label: 'undo all patches',\n                    formAddress: 'fast_rewind',\n                    onClick: `@\n                        if (links.patchBot.tags.abPatchBotInstance) {\n                            whisper(links.patchBot, 'onABPatchUndoAllClick');\n                        } else {\n                            os.toast('do nothing: this is a patch bot template');\n                        }\n                    `\n                }\n            ]\n        }\n\n        ab.links.menu.abCreateMenuGroup(allPatchesMenuGroup);\n    }\n}","abPatchMenuReset":"@if (configBot.masks.menuPortal === 'abPatchMenu') {\n    configBot.masks.menuPortal = null;\n}","onGridClick":"@shout('abPatchMenuReset');","onEggHatch":"@if (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nconst sourceEvent = that?.sourceEvent;\n\nif (sourceEvent === 'ask_gpt') {\n    const patchCode = that.eggParameters.patchCode;\n    const askInput = that.eggParameters.askInput;\n    const dimension = that.eggParameters.dimension;\n    const position = that.eggParameters.position;\n    const alwaysApprove = that.eggParameters.alwaysApprove ?? false;\n\n    tags.abIgnore = true;\n    tags.abPatchBotInstance = true;\n    tags.abPatchAskInput = `ðŸ§¬${JSON.stringify(askInput)}`;\n    tags.abPatchCode = `@${patchCode}`;\n    tags.abPatchBotIdentity = `patch ${thisBot.id.substring(0, 5)}`;\n    tags.abPatchLabel = `review ${tags.abPatchBotIdentity}`;\n    tags.system = `abPatchBot.${tags.abPatchBotIdentity}`;\n    tags[dimension] = true;\n    tags[dimension + 'X'] = position?.x ?? 0;\n    tags[dimension + 'Y'] = position?.y ?? 0;\n    tags[dimension + 'Z'] = position?.z ?? 0;\n\n    try {\n        await thisBot.abPatchApply();\n    } finally {\n        thisBot.updatePatchColor();\n    }\n\n    await os.sleep(0); // NOTE: Need to wait 1 frame and let tags/masks updates in the patch bots otherwise the menu wont be able to retrieve all patch bots successfully.\n\n    if (alwaysApprove) {\n        thisBot.onABPatchApproveClick();\n    } else {\n        thisBot.abPatchMenuOpen();\n\n        const abBot = ab.links.manifestation.links.abBot;\n        if (abBot) {\n            const abBotPosition = getBotPosition(abBot, dimension);\n            if (abBotPosition.x == position.x && \n                abBotPosition.y == position.y &&\n                abBotPosition.z == position.z\n            ) {\n                if (!configBot.tags.abStayAwake) {\n                    // If the ab bot is in the current position of this patch bot, hide the ab bot.\n                    destroy(ab.links.manifestation.links.abBot);\n                }\n\n                // If the ab bot didn't move, automatically open the menu for this new patch bot.\n            }\n        }\n    }\n}\n","abPatchApply":"@if (tags.abPatchApplied || tags.abPatchApplying) {\n    return;\n}\n\nif (typeof thisBot.abPatchCode === 'function') {\n    try {\n        tags.abPatchApplying = true;\n        const abPatchResults: ABPatchResult[] = await thisBot.abPatchCode();\n\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] patch results:`, abPatchResults);\n        }\n\n        // Store the patch results on this patch bot.\n        tags.abPatchResults = `ðŸ§¬${JSON.stringify(abPatchResults, undefined, 4)}`;\n\n        // For all patched bots, remove the 'creator' tag on them if the creator was this patch bot.\n        // We don't want our patched bots to get destroyed when this patch bot is destroyed.\n        for (const result of abPatchResults) {\n            const bot = getBot('id', result.botId);\n            \n            if (bot && bot.tags.creator === thisBot.id) {\n                bot.tags.creator = null;\n            }\n        }\n\n        tags.abPatchApplied = true;\n        tags.abPatchAppliedTimestamp = os.isCollaborative() ? os.agreedUponTime : os.localTime;\n        tags.lineTo = getLink(abPatchResults.map(r => getBot('id', r.botId)));\n    } catch (e) {\n        const errorMessage = `Something went wrong applying patch â€” ${ab.links.utils.getErrorMessage(e)}`;\n        ab.links.utils.abLogAndToast({ name: tags.patchLabel, message: errorMessage, logType: 'error' });\n        tags.abPatchError = errorMessage;\n    } finally {\n        tags.abPatchApplying = null;\n\n        if (!tags.abPatchResults || !tags.abPatchApplied) {\n            // If patch is not applied or results are not successfully recorded, then we mark this patch as invalid.\n            tags.abPatchInvalid = true;\n        }\n    }\n} else {\n    const errorMessage = `Patch code is not a valid function.`;\n    ab.links.utils.abLogAndToast({ name: tags.patchLabel, message: errorMessage, logType: 'error' });\n    tags.abPatchInvalid = true;\n    tags.abPatchError = errorMessage;\n}","abPatchUndo":"@if (!tags.abPatchApplied || tags.abPatchApplying) {\n    return;\n}\n\nconst abPatchResults: ABPatchResult[] = tags.abPatchResults;\n\nif (abPatchResults && abPatchResults.length > 0) {\n    for (let result of abPatchResults) {\n        const patchedBot = getBot('id', result.botId);\n\n        if (patchedBot) {\n            if (result.created) {\n                // This patch created the bot, to undo it we destroy it.\n                destroy(patchedBot);\n                destroy(thisBot);\n            } else if (result.rollbackDiff) {\n                // This patch modified the bot, to undo it we apply all the the tags and masks in the rollback diff to the bot.\n                const rollbackBotData = result.rollbackDiff[patchedBot.id];\n                const rollbackTags = rollbackBotData.tags;\n                const rollbackMasks = rollbackBotData.masks;\n\n                if (rollbackTags) {\n                    for (const tagName in rollbackTags) {\n                        setTag(patchedBot, tagName, rollbackTags[tagName]);\n                    }\n                }\n\n                if (rollbackMasks) {\n                    for (const space in rollbackMasks) {\n                        if (space === 'remoteTempShared') {\n                            // Cant set remoteTempShared masks, they are owned by someone else.\n                            continue;\n                        }\n\n                        for (const tagName in rollbackMasks[space]) {\n                            setTagMask(patchedBot, tagName, rollbackMasks[space][tagName], space);\n                        }\n                    }\n                }\n\n                // After tags and masks have been rolled back, destroy this patch bot.\n                destroy(thisBot);\n            } else {\n                ab.links.utils.abLogAndToast({ message: `Cannot undo ${tags.abPatchBotIdentity}. Something went wrong during patch process? No data found to undo changes.`, logType: 'warning' });\n            }\n        } else {\n            // Patched bot not found, quietly destroy the patch bot.\n            destroy(thisBot);\n        }\n    }\n}","abPatchColor":"white","cursor":"pointer","abPatchBot":true,"formOpacity":"0.33","strokeColor":"white","color":"white","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nmasks.ready = true;\n\nthisBot.updatePatchColor();\nthisBot.updateBillboardLabel();","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nconst currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nconst botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\nif (botInDimension) {\n    thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n        bot: thisBot,\n        label: tags.abPatchLabel,\n        labelColor: tags.abPatchLabelColor,\n        color: tags.abPatchLabelBackgroundColor,\n        dimension: currentDimension,\n        space: 'tempLocal',\n    })\n}\n\n","onBotChanged":"@const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\n\nlet needUpdateBillboardLabel = false;\nlet needUpdatePatchColor = false;\n\nfor (const t of that.tags) {\n    if (!needUpdateBillboardLabel) {\n        needUpdateBillboardLabel = t === 'abPatchLabel' ||\n                                   t === 'abPatchLabelColor' ||\n                                   t === 'abPatchLabelBackgroundColor' ||\n                                   t === currentDimension;\n    }\n\n    if (!needUpdatePatchColor) {\n        needUpdatePatchColor = t === 'abPatchError' || t === 'abPatchInvalid';\n    }\n}\n\nif (needUpdatePatchColor) {\n    thisBot.updatePatchColor();\n}\n\nif (needUpdateBillboardLabel && tags.ready) {\n    thisBot.updateBillboardLabel();\n}","abPatchLabel":"patch bot template","onABPatchApproveClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    destroy(thisBot);\n}","onABPatchUndoClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    thisBot.abPatchUndo();\n}","types":"ðŸ“„interface ABPatchResult {\n    /** The id of the bot that was created / modified. */\n    botId: string;\n\n    /** Wether or not this bot was created by the patch. */\n    created: boolean;\n\n    /** \n    * A rollback diff of the bot that stores the original values of tags on the bot before the patch code was run. If the bot was created by the patch code then this must be null.\n    * \n    * Snapshots of bots can be obtained by running getSnapshot(bot) and then a rollback diff can be created by running diffSnapshots(postPatchSnapshot, prePatchSnapshot).\n    */\n    rollbackDiff: PartialBotState | null;\n}","onABPatchApproveAllClick":"@if (tags.abPatchBotInstance) {\n    shout('onABPatchApproveClick');\n}","onABPatchUndoAllClick":"@if (tags.abPatchApplied && tags.abPatchBotInstance) {\n    const abAppliedPatchBots = thisBot.abGetAppliedPatchBots();\n    \n    for (const abPatchBot of abAppliedPatchBots) {\n        whisper(abPatchBot, 'onABPatchUndoClick');\n    }\n}","abVersion":"10.39","debug":"false","abGetAppliedPatchBots":"@const abAppliedPatchBots = getBots(bot => bot.tags.abPatchBot && bot.tags.abPatchBotInstance && bot.tags.abPatchApplied);\n\n// Sort abAppliedPatchBots by their abPatchAppliedTimestamp in descending order (most recent to oldest patch bots);\nabAppliedPatchBots.sort((a, b) => b.tags.abPatchAppliedTimestamp - a.tags.abPatchAppliedTimestamp);\n\nreturn abAppliedPatchBots;","abPatchBotVersion":"1.3","updatePatchColor":"@let botColor;\nlet labelColor;\n\nif (tags.abPatchInvalid || tags.abPatchError) {\n    botColor = 'firebrick';\n    labelColor = 'white';\n} else {\n    botColor = 'white',\n    labelColor = 'black';\n}\n\nif (tags.abPatchLabelColor !== labelColor) {\n    tags.abPatchLabelColor = labelColor;\n}\n\nif (tags.abPatchLabelBackgroundColor !== botColor) {\n    tags.abPatchLabelBackgroundColor = botColor;\n}\n\nif (tags.color !== botColor) {\n    tags.color = botColor;\n}\n\nif (tags.strokeColor !== botColor) {\n    tags.strokeColor = botColor;\n}","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}","abIDOrigin":"abPatchBot","abPatchLabelColor":"black","abPatchLabelBackgroundColor":"white"}}}}