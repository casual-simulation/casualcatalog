{"version":1,"state":{"bc46aeab-238c-4f0e-9ed2-fc94766b1470":{"id":"bc46aeab-238c-4f0e-9ed2-fc94766b1470","space":"shared","tags":{"system":"ab.ai.voice","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'abVoice'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\n\r\n//If console is not open, open console\r\nif (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;","abArtifactName":"abVoice","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","abCoreMenuOnGenerate":"@tags.onSubmit = `@\r\n    links.baseSkill.abCoreMenuAction({message: that.text, menu: \"core\"});\r\n`;\r\n\r\ntags.form = \"input\";\r\n\r\nif (!authBot)\r\n{\r\n    tags.label = \"you must be logged in to chat with \" + links.personality.tags.abBuilderIdentity;\r\n}\r\nelse if (authBot.tags.subscriptionTier == \"FreePlay\")\r\n{\r\n    tags.label = \"chat with \" + links.personality.tags.abBuilderIdentity + \" (limited)\";\r\n}\r\nelse\r\n{\r\n    tags.label = \"chat with \" + links.personality.tags.abBuilderIdentity;\r\n}","abCoreMenuAction":"@if (that && that.message) {\r\n    let username = \"user\";\r\n\r\n    if (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n        username = authBot.tags.name;\r\n    } else if (ab.links.console.masks.preferredName) {\r\n        username = ab.links.console.masks.preferredName;\r\n    } else {\r\n        username = await os.showInput(\"\", {\r\n            title: \"What would you like me to call you?\"\r\n        });\r\n        ab.links.console.masks.preferredName = username;\r\n    }\r\n\r\n    const text = await thisBot.textResponse({user: username, message: that.message});\r\n    console.log(\"textResponse: \", text);\r\n}","startHume":"@const endpoint = \"wss://api.hume.ai/v0/evi/chat\";\r\nconst accessToken = (await ai.hume.getAccessToken()).accessToken;\r\n//const configID = \"e04b02d5-cb78-4292-aba4-a912d8926ddd\";\r\nconst configID = \"ff1133fb-2a27-4a9c-8801-258ecf7eb2aa\";\r\n\r\nconst url = new URL(endpoint);\r\nurl.searchParams.set(\"access_token\", accessToken);\r\nurl.searchParams.set(\"config_id\", configID);\r\n\r\nawait os.beginAudioRecording({\r\n    stream: true,\r\n    mimeType: 'audio/wav'\r\n});\r\n\r\nconst humeSocket = new WebSocket(url.toString());\r\nthisBot.vars.humeSocket = humeSocket;\r\nthisBot.vars.playingQueue = false;\r\n\r\nconst session_settings = {\r\n    \"type\": \"session_settings\",\r\n    \"variables\": {\r\n        // \"name\": tags.name,\r\n        // \"allowed_topics\": JSON.stringify(knowledgeBase),\r\n    }\r\n};\r\n\r\nhumeSocket.addEventListener('open', (event) => {\r\n    console.warn(\"Hume Socket opened: \", event);\r\n    humeSocket.send(JSON.stringify(session_settings));\r\n\r\n    thisBot.clearAudio();\r\n\r\n    thisBot.vars.playHumeAudio = true;\r\n});\r\n\r\nhumeSocket.addEventListener('close', (event) => {\r\n    console.warn(\"Hume Socket closed: \", event);\r\n    thisBot.endHume();\r\n    // shout(\"onHumeChatEnded\", event);\r\n});\r\n\r\nhumeSocket.addEventListener('message', async (event) => {\r\n    const data = JSON.parse(event.data);\r\n\r\n    if (data.type == \"audio_output\") {\r\n        thisBot._audio_queueAudio(data.data);\r\n    }\r\n    else if (data.type == \"assistant_message\") {\r\n        //if (thisBot.vars.playHumeAudio == true) {\r\n            const message = data.message.content;\r\n            thisBot.queueText(message);\r\n            // ab.log({ message: message, name: tags.name, space: \"shared\", rbIgnoreMessage: true });\r\n        //}\r\n    }\r\n    else if (data.type == \"error\") {\r\n        console.warn('error: ', data.message);\r\n    }\r\n    else if (data.type == \"user_message\") {\r\n        let username = thisBot.getUserName();\r\n\r\n        const message = data.message.content;\r\n\r\n        ab.log({\r\n            message: message,\r\n            name: username,\r\n            space: \"shared\",\r\n            audioInput: true,\r\n            messageOrigin: configBot.id,\r\n        });\r\n\r\n        thisBot.vars.playHumeAudio = true;\r\n    }\r\n    else if (data.type == \"tool_call\") {\r\n        console.log(\"Tool called: \", data.name, data);\r\n        if (data.name == \"raiseHand\") {\r\n            thisBot.raiseHand(data);\r\n        }\r\n        // else if (data.name == \"getAllowedTopics\") {\r\n        //     thisBot._audio_updateAI();\r\n        //     let knowledgeBase = tags.knowledgeBase ?? [];\r\n        //     const toolResponseMessage = {\r\n        //         type: \"tool_response\",\r\n        //         tool_call_id: data.tool_call_id,\r\n        //         content: JSON.stringify(knowledgeBase),\r\n        //     };\r\n        //     humeSocket.send(JSON.stringify(toolResponseMessage));\r\n        // }\r\n    }\r\n    else if (data.type == \"user_interruption\") {\r\n        thisBot.clearAudio();\r\n\r\n        thisBot.vars.playHumeAudio = true;\r\n    }\r\n    else {\r\n        console.log(\"unexpected message:\", data.type, data);\r\n    }\r\n});","clearAudio":"@thisBot.masks.audioQueue && thisBot.masks.audioQueue.length > 0 ? thisBot.masks.audioQueue.length = 1 : null;\r\nthisBot.masks.textQueue && thisBot.masks.textQueue.length > 0 ? thisBot.masks.textQueue.length = 1 : null;\r\n\r\nos.cancelSound(thisBot.masks.activeSound);\r\n\r\nthisBot.masks.activeSound = null;","endHume":"@masks.audioChat = false;\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.close(1000, 'User ended the chat');\r\n    delete thisBot.vars.humeSocket;\r\n}\r\n\r\ntry {\r\n    await os.endAudioRecording();\r\n} catch(e) {\r\n    console.warn(e);\r\n}","queueText":"@const text = that;\r\n\r\nthisBot.masks.textQueue = thisBot.masks.textQueue ? [...thisBot.masks.textQueue].concat(text) : [text];","raiseHand":"@//pop up notification label\r\nconsole.log(\"hand raised\", that);","playQueuedAudio":"@//TODO: review\r\nconsole.log(\"playQueuedAudio triggered\", thisBot.vars.playingQueue)\r\n\r\nif (thisBot.vars.playingQueue)\r\n{\r\n    return;\r\n}\r\n\r\nthisBot.vars.playingQueue = true;\r\n\r\nwhile (thisBot.masks.audioQueue.length > 0)\r\n{\r\n    const activeAudio = thisBot.masks.audioQueue[0];\r\n    const activeText = thisBot.masks.textQueue[0];\r\n\r\n    thisBot.masks.audioQueue.splice(0, 1);\r\n    thisBot.masks.textQueue.splice(0,1);\r\n\r\n    let soundId = os.playSound(activeAudio);\r\n    thisBot.masks.activeSound = soundId;\r\n    let username = thisBot.getUserName();\r\n    ab.log({ message: activeText, name: username, space: \"shared\", messageOrigin: configBot.id });\r\n    \r\n    await os.sleep((getDuration(activeAudio) * 1000));\r\n    \r\n    thisBot.masks.activeSound = null;\r\n\r\n    console.log(\"AUDIO QUEUE: \", thisBot.masks.audioQueue);\r\n}\r\n\r\nthisBot.vars.playingQueue = null;\r\n\r\nfunction base64ToArrayBuffer(base64) {\r\n    const binaryString = self.atob(base64.split(',')[1]);\r\n    const bytes = Uint8Array.from(binaryString, char => char.charCodeAt(0));\r\n    return bytes.buffer;\r\n}\r\n\r\nfunction getWavDuration(arrayBuffer) {\r\n    const view = new DataView(arrayBuffer);\r\n\r\n    // Check the \"RIFF\" identifier\r\n    if (view.getUint32(0, false) !== 0x52494646) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Check the \"WAVE\" identifier\r\n    if (view.getUint32(8, false) !== 0x57415645) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Get the byte rate from the fmt subchunk\r\n    const byteRate = view.getUint32(28, true);\r\n\r\n    // Get the total number of bytes in the data subchunk\r\n    const dataChunkSize = view.getUint32(40, true);\r\n\r\n    // Calculate duration\r\n    const duration = dataChunkSize / byteRate;\r\n\r\n    return duration;\r\n}\r\n\r\nfunction getDuration(base64) {\r\n    var arrBuffer = base64ToArrayBuffer(base64);\r\n    return getWavDuration(arrBuffer);\r\n}","textResponse":"@// let response = await ai.chat(responsePrompt, {\r\n//     preferredModel: tags.aiModel\r\n// });\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.send(JSON.stringify({\r\n        \"type\": \"user_input\",\r\n        \"text\": that.message,\r\n    }));\r\n}\r\n\r\nreturn true;","abCoreMenuSortOrder":"1001","onAudioChunk":"@const muteBot = getBot(\"system\", \"ab.ai.mute\");\r\nif (muteBot && muteBot.tags.muted) {\r\n    return;\r\n}\r\n\r\nconsole.log(\"audio chunk recieved\")\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.send(JSON.stringify({\r\n        data: await blobToBase64(that),\r\n        type: \"audio_input\"\r\n    }));\r\n}\r\n\r\nasync function blobToBase64(blob) {\r\n  // Read the Blob as an ArrayBuffer\r\n  const arrayBuffer = await blob.arrayBuffer();\r\n  \r\n  // Convert the ArrayBuffer to a Base64 string\r\n  const base64String = bytes.toBase64String(new Uint8Array(arrayBuffer), 'audio/wav');\r\n  \r\n  return base64String;\r\n}","queueAudio":"@const base64Audio = that;\r\n\r\nconst mimeType = \"audio/wav\"; // Adjust MIME type as needed\r\nconst dataURL = `data:${mimeType};base64,${base64Audio}`;\r\n\r\nthisBot.masks.audioQueue = thisBot.masks.audioQueue ? [...thisBot.masks.audioQueue].concat(dataURL) : [dataURL];\r\n\r\nthisBot.playQueuedAudio();","getUserName":"@let username = \"user\";\r\n\r\nif (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n    username = authBot.tags.name;\r\n} else if (ab.links.console.masks.preferredName) {\r\n    username = ab.links.console.masks.preferredName;\r\n} else {\r\n    username = await os.showInput(\"\", {\r\n        title: \"What would you like me to call you?\"\r\n    });\r\n    ab.links.console.masks.preferredName = username;\r\n}\r\n\r\nreturn username;"}},"c0fb18e3-0a0b-40c2-9281-d4f0a2f19ac5":{"id":"c0fb18e3-0a0b-40c2-9281-d4f0a2f19ac5","space":"shared","tags":{"system":"ab.ai.mute","abCoreMenuAction":"@tags.muted = !tags.muted;\r\n\r\nconst menuBot = getBot(byTag(\"baseSkill\", 'ðŸ”—' + getID(thisBot)), byTag(\"abMenu\", true));\r\nif (menuBot) {\r\n    if (tags.muted) {\r\n        menuBot.tags.label = \"unmute\";\r\n        menuBot.tags.formAddress = 'mic_off';\r\n    } else {\r\n        menuBot.tags.label = \"mute\";\r\n        menuBot.tags.formAddress = 'mic';\r\n    }\r\n}","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'abVoice'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\n\r\ntags.muted = true;","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","abArtifactName":"abVoice","abCoreMenuOnGenerate":null,"muted":true,"abCoreMenuIcon":"mic_off","abCoreMenuLabel":"unmute","label":"mute","formAddress":"mic","onClick":null,"abCoreMenuSortOrder":"1000","abCoreMenuOnBeforeCreate":"@if (tags.muted) {\r\n    tags.abCoreMenuLabel = \"unmute\";\r\n    tags.abCoreMenuIcon = 'mic_off';\r\n} else {\r\n    tags.abCoreMenuLabel = \"mute\";\r\n    tags.abCoreMenuIcon = 'mic';\r\n}"}}}}