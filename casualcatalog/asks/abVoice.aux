{"version":1,"state":{"24a289cd-1e87-48c1-9707-41ee40c70da9":{"id":"24a289cd-1e87-48c1-9707-41ee40c70da9","space":"shared","tags":{"system":"ab.ai.voice","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'abVoice'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\n\r\n//If console is not open, open console\r\nif (!links.console.masks.open) {\r\n    whisper(links.console, \"showConsole\");\r\n    links.console.masks.open = true;\r\n}\r\n\r\nsetTagMask(links.ask, \"abCoreMenuHide\", true, \"shared\");","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;","abArtifactName":"abVoice","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","abCoreMenuOnGenerate":"@tags.onSubmit = `@\r\n    links.baseSkill.abCoreMenuAction({message: that.text, menu: \"core\"});\r\n    masks.menuItemText = \"\";\r\n`;\r\n\r\ntags.form = \"input\";\r\n\r\nif (!authBot)\r\n{\r\n    tags.label = \"you must be logged in to chat with \" + abPersonality.tags.abBuilderIdentity;\r\n}\r\nelse if (authBot.tags.subscriptionTier == \"FreePlay\")\r\n{\r\n    tags.label = \"chat with \" + abPersonality.tags.abBuilderIdentity + \" (limited)\";\r\n}\r\nelse\r\n{\r\n    tags.label = \"chat with \" + abPersonality.tags.abBuilderIdentity;\r\n}","abCoreMenuAction":"@if (that && that.message) {\r\n    if (that.message == '.stopHume') {\r\n        thisBot.endHume();\r\n        return;\r\n    }\r\n\r\n    let username = await thisBot.getUserName();\r\n\r\n    if (!thisBot.vars.humeSocket) {\r\n        setTagMask(thisBot, \"awaitingText\", {user: username, message: that.message});\r\n        await thisBot.startHume();\r\n    } else {\r\n        thisBot.textResponse({user: username, message: that.message});\r\n    }\r\n}","startHume":"@const endpoint = \"wss://api.hume.ai/v0/evi/chat\";\r\nconst accessToken = (await ai.hume.getAccessToken()).accessToken;\r\n//const configID = \"e04b02d5-cb78-4292-aba4-a912d8926ddd\";\r\nconst configID = \"ff1133fb-2a27-4a9c-8801-258ecf7eb2aa\";\r\n\r\nconst url = new URL(endpoint);\r\nurl.searchParams.set(\"access_token\", accessToken);\r\nurl.searchParams.set(\"config_id\", configID);\r\n\r\nconst humeSocket = new WebSocket(url.toString());\r\nthisBot.vars.humeSocket = humeSocket;\r\nthisBot.vars.playingQueue = false;\r\n\r\nconst session_settings = {\r\n    \"type\": \"session_settings\",\r\n    \"variables\": {\r\n        \"name\": abPersonality.tags.abBuilderIdentity,\r\n        \"catalog_asks\": await thisBot.getCatalogAsks()\r\n    }\r\n};\r\n\r\nhumeSocket.addEventListener('open', (event) => {\r\n    console.warn(\"Hume Socket opened: \", event);\r\n\r\n    thisBot.clearQueues();\r\n    tags.handRaised = false;\r\n\r\n    thisBot.vars.playHumeAudio = true;\r\n\r\n    humeSocket.send(JSON.stringify(session_settings));\r\n\r\n    setTagMask(thisBot, \"sentInitChunk\", false);\r\n\r\n    os.beginAudioRecording({\r\n        stream: true,\r\n        mimeType: 'audio/wav'\r\n    });\r\n\r\n    os.toast(\"Hume active...\");\r\n    shout(\"onHumeSocketOpened\");\r\n});\r\n\r\nhumeSocket.addEventListener('close', (event) => {\r\n    console.warn(\"Hume Socket closed: \", event);\r\n    thisBot.endHume();\r\n\r\n    os.toast(\"Hume closed...\");\r\n    // shout(\"onHumeChatEnded\", event);\r\n});\r\n\r\nhumeSocket.addEventListener('message', async (event) => {\r\n    const data = JSON.parse(event.data);\r\n\r\n    console.log(\"data\", data);\r\n\r\n    if (data.type == \"audio_output\") {\r\n        thisBot.queueAudio(data.data);\r\n    }\r\n    else if (data.type == \"assistant_message\") {\r\n        const message = data.message.content;\r\n\r\n        thisBot.queueText(message); \r\n        \r\n    }\r\n    else if (data.type == \"assistant_end\") {\r\n        //tags.thinking = true;\r\n    }\r\n    else if (data.type == \"error\") {\r\n        console.warn('error: ', data.message);\r\n    }\r\n    else if (data.type == \"user_message\") {\r\n        let username = await thisBot.getUserName();\r\n        tags.handRaised = false;\r\n\r\n        const message = data.message.content;\r\n\r\n        if (message) {\r\n            ab.log({\r\n                message: message,\r\n                name: username,\r\n                space: \"shared\",\r\n                audioInput: true,\r\n                messageOrigin: configBot.id,\r\n            });\r\n        }\r\n    }\r\n    else if (data.type == \"tool_call\") {\r\n        console.log(\"Tool called: \", data.name, data);\r\n        tags.recentToolCall = data.tool_call_id;\r\n        if (data.name == \"think\") {\r\n            if (JSON.parse(data.parameters).message) {\r\n                ab.log({ message: JSON.parse(data.parameters).message, name: abPersonality.tags.abBuilderIdentity, space: \"shared\", messageOrigin: configBot.id });\r\n            }\r\n        } else if (data.name == \"makeToDoBot\") {\r\n            thisBot.makeToDoBot(data.parameters);\r\n        }  else if (data.name == \"make\") {\r\n            thisBot.makeSomething(data.parameters);\r\n        }  else if (data.name == \"pullFromCatalog\") {\r\n            thisBot.pullFromCatalog(data.parameters);\r\n        } \r\n        // else if (data.name == \"handDown\") {\r\n        //     thisBot.handDown(data);\r\n        // }\r\n        thisBot.sendToolCompleteMessage();\r\n    }\r\n    else if (data.type == \"user_interruption\") {\r\n        thisBot.clearQueues();\r\n\r\n        thisBot.vars.playHumeAudio = true;\r\n    }\r\n    else {\r\n        console.log(\"unexpected message:\", data.type, data);\r\n    }\r\n});","endHume":"@const humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.close(1000, 'User ended the chat');\r\n    delete thisBot.vars.humeSocket;\r\n}\r\n\r\ntry {\r\n    await os.endAudioRecording();\r\n} catch(e) {\r\n    console.warn(e);\r\n}","queueText":"@const text = that;\r\n\r\nthisBot.masks.textQueue = thisBot.masks.textQueue ? [...thisBot.masks.textQueue].concat(text) : [text];","playQueuedAudio":"@if (thisBot.vars.playingQueue)\r\n{\r\n    return;\r\n}\r\n\r\nthisBot.vars.playingQueue = true;\r\n\r\nwhile (thisBot.masks.audioQueue?.length > 0)\r\n{\r\n    const activeAudio = thisBot.masks.audioQueue[0];\r\n    const activeText = thisBot.masks.textQueue[0];\r\n\r\n    thisBot.masks.audioQueue.splice(0, 1);\r\n    thisBot.masks.textQueue.splice(0,1);\r\n\r\n    let soundId = os.playSound(activeAudio);\r\n    thisBot.masks.activeSound = soundId;\r\n    if (activeText) {\r\n        ab.log({ message: activeText, name: abPersonality.tags.abBuilderIdentity, space: \"shared\", messageOrigin: configBot.id });\r\n    }\r\n    \r\n    await os.sleep((getDuration(activeAudio) * 1000));\r\n    \r\n    thisBot.masks.activeSound = null;\r\n}\r\n\r\nthisBot.vars.playingQueue = null;\r\n\r\nfunction base64ToArrayBuffer(base64) {\r\n    const binaryString = self.atob(base64.split(',')[1]);\r\n    const bytes = Uint8Array.from(binaryString, char => char.charCodeAt(0));\r\n    return bytes.buffer;\r\n}\r\n\r\nfunction getWavDuration(arrayBuffer) {\r\n    const view = new DataView(arrayBuffer);\r\n\r\n    // Check the \"RIFF\" identifier\r\n    if (view.getUint32(0, false) !== 0x52494646) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Check the \"WAVE\" identifier\r\n    if (view.getUint32(8, false) !== 0x57415645) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Get the byte rate from the fmt subchunk\r\n    const byteRate = view.getUint32(28, true);\r\n\r\n    // Get the total number of bytes in the data subchunk\r\n    const dataChunkSize = view.getUint32(40, true);\r\n\r\n    // Calculate duration\r\n    const duration = dataChunkSize / byteRate;\r\n\r\n    return duration;\r\n}\r\n\r\nfunction getDuration(base64) {\r\n    var arrBuffer = base64ToArrayBuffer(base64);\r\n    return getWavDuration(arrBuffer);\r\n}","textResponse":"@// let response = await ai.chat(responsePrompt, {\r\n//     preferredModel: tags.aiModel\r\n// });\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.send(JSON.stringify({\r\n        \"type\": \"user_input\",\r\n        \"text\": that.message,\r\n    }));\r\n}","abCoreMenuSortOrder":"1001","onAudioChunk":"@const muteBot = getBot(\"system\", \"ab.ai.mute\");\r\nlet audioData;\r\nif (muteBot && muteBot.tags.muted && tags.sentInitChunk) {\r\n    const silence = new Blob([new Uint8Array(that.size)], { type: 'audio/wav' });\r\n    audioData = await blobToBase64(silence);\r\n} else {\r\n    audioData = await blobToBase64(that);\r\n}\r\n\r\nsetTagMask(thisBot, \"sentInitChunk\", true);\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nconst packetHash = crypto.hash('sha1', 'hex', audioData);\r\n\r\nif(humeSocket) {\r\n    console.log(\"packet here\", packetHash);\r\n\r\n    humeSocket.send(JSON.stringify({\r\n        \"type\": \"audio_input\",\r\n        \"data\": audioData\r\n    }));\r\n}\r\n\r\nasync function blobToBase64(blob) {\r\n  // Read the Blob as an ArrayBuffer\r\n  const arrayBuffer = await blob.arrayBuffer();\r\n  \r\n  // Convert the ArrayBuffer to a Base64 string\r\n  const base64String = bytes.toBase64String(new Uint8Array(arrayBuffer), 'audio/wav');\r\n  \r\n  return base64String;\r\n}","queueAudio":"@const base64Audio = that;\r\n\r\nconst mimeType = \"audio/wav\"; // Adjust MIME type as needed\r\nconst dataURL = `data:${mimeType};base64,${base64Audio}`;\r\n\r\nthisBot.masks.audioQueue = thisBot.masks.audioQueue ? [...thisBot.masks.audioQueue].concat(dataURL) : [dataURL];\r\n\r\n//thisBot.playQueuedAudio();\r\ntags.handRaised = true;","getUserName":"@let username = \"user\";\r\n\r\nif (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n    username = authBot.tags.name;\r\n} else if (ab.links.console.masks.preferredName) {\r\n    username = ab.links.console.masks.preferredName;\r\n} else {\r\n    username = await os.showInput(\"\", {\r\n        title: \"What would you like me to call you?\"\r\n    });\r\n    ab.links.console.masks.preferredName = username;\r\n}\r\n\r\nreturn username;","abIDOrigin":"abVoice","abCoreMenuIcon":"cube","ask":"ðŸ”—ec85c1d6-9f1a-40d4-82e1-5bd680349c27","onBotChanged":"@if (that.tags.includes(\"handRaised\")) {\r\n    //create bot above ab with special clickable label\r\n    \r\n    const abBot = ab.links.manifestation.links.abBot;\r\n    if (!abBot) {\r\n        return;\r\n    }\r\n\r\n    if (tags.handRaised) {\r\n        const notifBots = getBots(\"abVoiceNotificationBot\", true);\r\n        destroy(notifBots);\r\n        \r\n        create({\r\n            transformer: getID(abBot),\r\n            onClick: `@\r\n                links.voice.calledOn(thisBot);\r\n            `,\r\n            voice: getLink(thisBot),\r\n            abVoiceNotificationBot: true,\r\n            [ab.links.remember.tags.abActiveDimension]: true,\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: 1,\r\n            form: 'sprite',\r\n            orientationMode: 'billboard',\r\n            formAddress: 'https://auth-aux-prod-filesbucket-682397690660.s3.amazonaws.com/64beb439-12b9-4155-b388-db03b7ec1c9c/89299d8c58f97f8853a9e87d4a0207574839dbeb3c66b92ea691db710b33c516',\r\n\r\n        })\r\n    } else {\r\n        const notifBots = getBots(\"abVoiceNotificationBot\", true);\r\n        destroy(notifBots);\r\n    }\r\n}","onInstStreaming":"@//If console is not open, open console\r\nif (!links.console.masks.open) {\r\n    whisper(links.console, \"showConsole\");\r\n    links.console.masks.open = true;\r\n}","console":"ðŸ”—24b7e66f-0d5b-4064-bf48-b562b9e6e3eb","calledOn":"@destroy(that);\r\n\r\nthisBot.playQueuedAudio();","onHumeSocketOpened":"@if (tags.awaitingText) {\r\n    thisBot.textResponse(tags.awaitingText);\r\n    setTagMask(thisBot, \"awaitingText\", null);\r\n}","clearQueues":"@thisBot.masks.audioQueue && thisBot.masks.audioQueue.length > 0 ? thisBot.masks.audioQueue.length = 1 : null;\r\nthisBot.masks.textQueue && thisBot.masks.textQueue.length > 0 ? thisBot.masks.textQueue.length = 1 : null;\r\n\r\nos.cancelSound(thisBot.masks.activeSound);\r\n\r\nconst notifBots = getBots(\"abVoiceNotificationBot\", true);\r\ndestroy(notifBots);\r\n\r\nthisBot.masks.activeSound = null;","thinking":true,"handRaised":true,"makeToDoBot":"@const data = JSON.parse(that);\r\n\r\nfor (let i = 0; i < data.bots.length; ++i) {\r\n    const abArtifactShard = {\r\n        data: {\r\n            prompt: data.bots[i].prompt,\r\n            eggParameters: {\r\n                gridInformation: {\r\n                    dimension: tags.dimension,\r\n                    position: {\r\n                        x: data.bots[i].location.x,\r\n                        y: data.bots[i].location.y\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        dependencies: [\r\n            {\r\n                askID: 'toDoBot'\r\n            }\r\n        ]\r\n    };\r\n    await ab.links.artifact.abCreateArtifactPromiseBot({\r\n        abArtifactName: 'toDoBot',\r\n        abArtifactInstanceID: uuid(),\r\n        abArtifactShard,\r\n    });\r\n}\r\n","getCatalogAsks":"@const catalogArr = [];\r\nconst possibleToolboxes = ab.links.remember.tags.toolbox_array;\r\n\r\nfor (let i = 0; i < possibleToolboxes.length; i++)\r\n{\r\n    const activeToolbox = possibleToolboxes[i];\r\n    const extantBot = activeToolbox.studio ? getBot(\"abIDOrigin\", activeToolbox.name): getBot(activeToolbox.name, true);\r\n\r\n    if (!extantBot)\r\n    {\r\n        const obj = {\r\n            \"name\": activeToolbox.title,\r\n            \"id\": activeToolbox.name\r\n        }\r\n        catalogArr.push(obj);\r\n    }\r\n}\r\n\r\nconst loadedToolboxes = getBots(\"tool_array\");\r\nfor (let j = 0; j < loadedToolboxes.length; ++j) {\r\n    const arr = loadedToolboxes[j].tags.tool_array ?? [];\r\n    for (let k = 0; k < arr.length; ++k) {\r\n        const obj = {\r\n            \"name\": arr[k].name ?? arr[k].targetAB,\r\n            \"id\": arr[k].targetAB\r\n        }\r\n        catalogArr.push(obj);\r\n    }\r\n}\r\n\r\nreturn catalogArr;","makeSomething":"@const data = JSON.parse(that);\r\nif (data && data.prompt) {\r\n    ab.links.ask.abCoreMenuAction(data.prompt);\r\n}\r\n","pullFromCatalog":"@const data = JSON.parse(that);\r\nif (data && data.ask) {\r\n    if (data.ask.includes(\"kit\")) {\r\n        const toolboxData = ab.links.remember.tags.toolbox_array.find(toolBox => toolBox.name == data.ask);\r\n        ab.links.manager.toolbox_add({toolboxData: toolboxData, gridData: ab.links.remember.tags.abGridFocus});\r\n    } else {\r\n      ab.links.ask.abCoreMenuAction(data.ask);\r\n    }\r\n}","onAnyBotsAdded":"@for (let i = 0; i < that.bots.length; ++i) {\r\n    if (that.bots[i].tags.tool_array) {\r\n        const humeSocket = thisBot.vars.humeSocket;\r\n\r\n        if(humeSocket) {\r\n            humeSocket.send(JSON.stringify({\r\n                \"type\": \"session_settings\",\r\n                \"variables\": {\r\n                    \"name\": abPersonality.tags.abBuilderIdentity,\r\n                    \"catalog_asks\": await thisBot.getCatalogAsks()\r\n                }\r\n            }));\r\n        }\r\n    }\r\n}","sendToolCompleteMessage":"@const complete_settings = {\r\n    \"type\": \"tool_response\",\r\n    \"tool_call_id\": tags.recentToolCall,\r\n    \"content\": \"completed\"\r\n};\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.send(JSON.stringify(complete_settings));\r\n}","recentToolCall":"call_Tu5vkVByFdYhuLUhNBGleWpy"}},"4e562af8-c5e1-4f88-8b24-b239a6c035d0":{"id":"4e562af8-c5e1-4f88-8b24-b239a6c035d0","space":"shared","tags":{"system":"ab.ai.mute","abCoreMenuAction":"@tags.muted = !tags.muted;\r\n\r\nconst menuBot = getBot(byTag(\"baseSkill\", 'ðŸ”—' + getID(thisBot)), byTag(\"abMenu\", true));\r\nif (menuBot) {\r\n    if (tags.muted) {\r\n        menuBot.tags.label = \"unmute\";\r\n        menuBot.tags.formAddress = 'mic_off';\r\n\r\n        \r\n    } else {\r\n        menuBot.tags.label = \"mute\";\r\n        menuBot.tags.formAddress = 'mic';\r\n        \r\n        const voiceBot = getBot(\"system\", \"ab.ai.voice\");\r\n        if (voiceBot && !voiceBot.vars.humeSocket) {\r\n            voiceBot.startHume();\r\n        }\r\n    }\r\n}","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'abVoice'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\n\r\ntags.muted = true;","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","abArtifactName":"abVoice","muted":true,"abCoreMenuIcon":"mic_off","abCoreMenuLabel":"unmute","label":"mute","formAddress":"mic","abCoreMenuSortOrder":"1000","abCoreMenuOnBeforeCreate":"@if (tags.muted) {\r\n    tags.abCoreMenuLabel = \"unmute\";\r\n    tags.abCoreMenuIcon = 'mic_off';\r\n} else {\r\n    tags.abCoreMenuLabel = \"mute\";\r\n    tags.abCoreMenuIcon = 'mic';\r\n}","abIDOrigin":"abVoice"}}}}