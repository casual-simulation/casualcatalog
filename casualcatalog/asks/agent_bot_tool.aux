{"version":1,"state":{"69d4e2a2-bf24-4434-8d18-6d6c735358b9":{"id":"69d4e2a2-bf24-4434-8d18-6d6c735358b9","space":"shared","tags":{"destroyAfterUse":"true","creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","home":true,"onClick":"@const { dimension } = that;\r\n\r\nshout(\"abMenuRefresh\");\r\nshout('clearAiKitAgentBotMenu');\r\n\r\nconfigBot.tags.menuPortal = \"ai_kit_bot_menu\";\r\n\r\nconst menuOptions = {\r\n    ai_kit_bot_menu: true,\r\n    color: 'white',\r\n}\r\n\r\nconst aiMenu = {\r\n    onClick: `@`,\r\n    ...menuOptions,\r\n    groupSortOrder: 1,\r\n    clearAiKitAgentBotMenu: `@destroy(this);`\r\n}\r\n\r\nconst menu = [];\r\nconst aiModels = links.remember.tags.aiModels ?? [];\r\nfor (let i = 0; i < aiModels.length; ++i) {\r\n    const groupItem = {\r\n        menuItemType: \"dropdown\",\r\n        label: aiModels[i].company,\r\n        dropdownOptions: []\r\n    }\r\n\r\n    for (let j = 0; j < aiModels[i].models.length; ++j) {\r\n\r\n        if (aiModels[i].models[j].allowed) {\r\n            const dropdownItem = {\r\n                label: aiModels[i].models[j].model,\r\n                color: 'white',\r\n                botGen: await getLink(thisBot),\r\n                modelData: aiModels[i].models[j],\r\n                dimension,\r\n                onClick: `@links.botGen.createAIAgent({ dimension: tags.dimension, modelData: tags.modelData });`,\r\n                onPointerEnter: `@\r\n                    if (tags.modelData.purpose) {\r\n                        // masks.label = tags.modelData.model + ' - ' + tags.modelData.purpose\r\n                    }\r\n                `,\r\n                onPointerExit: `@\r\n                    masks.label = null;\r\n                `\r\n            }\r\n            groupItem.dropdownOptions.push(dropdownItem);\r\n        }\r\n    }\r\n\r\n    if (groupItem.dropdownOptions.length > 0) {\r\n        menu.push(groupItem);\r\n    }\r\n}\r\n\r\naiMenu[\"menuItems\"] = menu;\r\nab.links.menu.abCreateMenuGroup(aiMenu);\r\nthisBot.animateSpin();","system":"ai_toolbox.tool.agent maker","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","homeX":-5,"homeY":-6,"onGridClick":"@shout(\"clearAiKitAgentBotMenu\")","createAIAgent":"@const { dimension, modelData } = that;\r\n\r\nshout(\"clearAiKitAgentBotMenu\");\r\n\r\nconst botTags = {\r\n    abIDOrigin: null,\r\n    aiModel: modelData.model,\r\n    ai_toolbox: null,\r\n    system: \"ai.agent.\" + modelData.model\r\n}\r\n\r\nconst dimensionX = thisBot.tags[dimension + 'X'] ?? 0;\r\nconst dimensionY = thisBot.tags[dimension + 'Y'] ?? 0;\r\n\r\nbotTags.dimension = dimension;\r\nbotTags[dimension] = true;\r\nbotTags[dimension + 'X'] = dimensionX;\r\nbotTags[dimension + 'Y'] = dimensionY;\r\n\r\nconst agentModel = getBot(\"system\", \"ai_toolbox.tool.agentModel\");\r\n\r\nif (agentModel) {\r\n    const bot = await create(agentModel, botTags);\r\n\r\n    if (bot && tags.destroyAfterUse) {\r\n        destroy(agentModel);\r\n        destroy(thisBot);\r\n    }\r\n}\r\n\r\n","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nif (globalThis.ab?.links.bot_factory) {\n    const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\n    const botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\n    if (botInDimension) {\n        thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n            bot: thisBot,\n            label: 'make an agent',\n            // color: tags.abPatchColor,\n            dimension: currentDimension,\n            labelColor: '#000000',\n            space: 'tempLocal',\n        })\n    }\n}","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nthisBot.updateBillboardLabel();","formOpacity":"0.33","strokeColor":"white","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","cursor":"pointer","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}","onCreate":"@tags.abIgnore = true;\r\nthisBot.onClick();","ai_toolbox_tools":"true","agent_bot_tool":"true","abVersion":"10.28","abIgnore":true,"onEggHatch":"@if (that.eggParameters) {\r\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n}","abIDOrigin":"agent_bot_tool","hello":null,"helloX":null,"helloY":null,"helloZ":null}},"aa0b3d91-7848-480e-9299-322830935920":{"id":"aa0b3d91-7848-480e-9299-322830935920","space":"shared","tags":{"creator":"bdbeef26-8eb0-494e-b5df-94114c7f6155","abAgent":"true","abMenuRefresh":"@thisBot.agentReset();","abVersion":"10.28","agentOnRequest":"@thisBot.agentReset();\n\nlet inquiry = that.inquiry ?? that;\n\nconst abAskBot = ab.links.ask;\n\nabAskBot.masks.gptActive = true;\n\nconst data = {\n    dimension: that.data?.armDimension,\n    dimensionX: that.data?.armDimensionX,\n    dimensionY: that.data?.armDimensionY,\n    bot: links.targetBot?.id,\n    bots: that.data?.bots,\n}\n\nif (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n    console.log(`[${tags.system}.${tagName}] destroy billboard label bot`);\n}\n\nabAskBot.askGPT({\n    inquiry,\n    prompt: tags.promptType,\n    model: tags.aiModel,\n    abBot: thisBot,\n    abDimension: tags.dimension,\n    abPosition: getBotPosition(thisBot, tags.dimension),\n    data,\n})\n\n// Wait some amount of time before bringing bot label back.\nawait os.sleep(1600 + 250);\nthisBot.updateBillboardLabel();","agentReset":"@if (links.arm) {\n    destroy(links.arm);\n}\n\nclearTagMasks(thisBot);\n\nshout('onABAIAgentReset');\n\nif (globalThis.abRemember) {\n    abRemember.masks.abBuilderIdentity = null;\n}","aiModel":"unset","askAgent":"@const menuPortal = configBot.tags.menuPortal ?? \"menu\";\n\nif (!configBot.tags.menuPortal) {\n    configBot.tags.menuPortal = menuPortal;\n}\n\nif (thisBot.vars.inputBot) {\n    destroy(thisBot.vars.inputBot);\n    thisBot.vars.inputBot = null;\n}\n\nthisBot.vars.inputBot = ab.links.menu.abCreateMenuInput({\n    [menuPortal]: true,\n    dimension: menuPortal,\n    label: `ask ${tags.aiModel}`,\n    color: tags.menuColor,\n    labelColor: 'black',\n    promptType: that.prompt,\n    agentBotId: thisBot.id,\n    agentBot: getLink(thisBot),\n    onABAIAgentReset: `@destroy(thisBot)`,\n    onSubmit: `@\n        links.agentBot.masks.promptType = tags.promptType;\n        links.agentBot.onSubmit(that);\n    `,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (botIDs.includes(tags.agentBotId)) {\n            shout('onABAIAgentReset');\n        }\n    `,\n})\n\nif (that.bot && that.prompt === \"bot\") {\n    masks.targetBot = getLink(that.bot);\n}\n\nabRemember.masks.abBuilderIdentity = tags.aiModel;\n\nthisBot.animateSpin();","scale":"0.9","botChat":"@const dimension = configBot.tags.gridPortal;\nconst message = that.message;\nconst messageTime = that.time ? that.time * 1000 : 1600; \n\n\nab.links.manifestation.abBotChat({\n    bot: thisBot,\n    dimension,\n    message,\n    messageTime,\n});\n\nawait os.sleep(messageTime + 250);\n\nthisBot.updateBillboardLabel();","color":"gold","labelColor":"gold","menuColor":"gold","onArmClick":"@const arm = that.arm;\nconst dimension = arm.tags.dimension;\nconst targetX = arm.tags[dimension + \"X\"];\nconst targetY = arm.tags[dimension + \"Y\"];\n\ntags[dimension] = true;\ntags[dimension + \"X\"] = targetX;\ntags[dimension + \"Y\"] = targetY;\n\nthisBot.agentReset();","onClick":"@thisBot.askAgent({prompt: \"core\"});","onDrag":"@os.hideChat();\n\n// if (links.remember.links.abMultipleBotFocus && that.bot.id == id)\n// {\n//     os.enableCustomDragging();\n\n//     return;\n// }\n\n\nif (tags.arm)\n{\n    await thisBot.agentReset();\n}\n\n// if (!that.bot.tags.interval)\n// {\n//     thisBot.abClick();\n// }\n\n//let state = os.getInputState(\"keyboard\", \"Shift\");\nlet arm = {};\n\narm.space = \"tempLocal\";\narm[that.dimension] = true;\narm[that.dimension + \"X\"] = tags[that.dimension + \"X\"];\narm[that.dimension + \"Y\"] = tags[that.dimension + \"Y\"];\narm.creator = thisBot.id;\narm.dimension = that.dimension ?? configBot.tags.gridPortal;\narm.scale = 0.9;\narm.scaleZ = 0.01;\narm.color = \"clear\";\narm.strokeColor = tags.strokeColor ?? tags.color;\narm.lineColor = tags.strokeColor ?? tags.color;\narm.lineTo = thisBot.id;\narm.manager = getLink(thisBot);\narm.onClick = \"@ links.manager.onArmClick({arm: thisBot});\";\narm.onDrop = `@ tags.draggable = false;\n\nif (that.to.bot)\n{\n    links.manager.masks.lineTo = that.to.bot.id;\n    links.manager.masks.lineColor = links.manager.tags.strokeColor;\n    \n    links.manager.askAgent({prompt: \"bot\", bot: that.to.bot});\n\n    destroy(thisBot);\n}\nelse\n{\n    links.manager.askAgent({prompt: \"grid\"});\n}`;\n\n// arm.onClick = `@ destroy(thisBot);\n\n// links.manager.abManifestBot({dimension: that.dimension, position:{x:tags[that.dimension + \"X\"],y:tags[that.dimension + \"Y\"]}});`;\n\n// if (state)\n// {\n//     arm.multiSelect = true;\n//     arm.form = \"sphere\";\n//     arm.color = links.remember.tags.abBaseStrokeColor;\n\n//     masks.draggable = true;\n// }\n\nlet newArm = await create(arm);\n\nmasks.arm = \"ðŸ”—\" + newArm.id;\n\nos.replaceDragBot(newArm);","onGridClick":"@thisBot.agentReset();","onSubmit":"@console.log(`[${tags.system}.${tagName}] that:`, that);\n\nconst requestData = {};\nconst activeDimension = that.dimension ?? configBot.tags.gridPortal;\n\nif (links.arm) {\n    const arm = links.arm;\n    const armDimension = arm.tags.dimension;\n\n    requestData.armDimension = armDimension;\n    requestData.armDimensionX = arm.tags[armDimension + \"X\"];\n    requestData.armDimensionY = arm.tags[armDimension + \"Y\"];\n}\n\nconst inquiry = that.text;\n\nconst aiRequest = await thisBot.agentOnRequest({inquiry, data: requestData, model: tags.aiModel});","strokeColor":"gold","system":"ai_toolbox.tool.agentModel","onCreate":"@tags.abIgnore = true;","ai_toolbox_tools":"true","agent_bot_tool":"true","abIgnore":true,"abIDOrigin":"agent_bot_tool","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nif (globalThis.ab?.links.bot_factory) {\n    const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\n    const botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\n    if (botInDimension) {\n        console.log(`[${tags.system}.${tagName}] create billboard label bot`);\n        thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n            bot: thisBot,\n            label: tags.aiModel,\n            color: 'gold',\n            labelColor: 'black',\n            dimension: currentDimension,\n            space: 'tempLocal',\n        })\n    }\n}","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nthisBot.updateBillboardLabel();","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}","formOpacity":"0.33","cursor":"pointer"}}}}