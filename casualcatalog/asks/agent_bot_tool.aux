{"version":1,"state":{"3d0e91d7-5c4f-4751-a7e6-6e28fa9076c1":{"id":"3d0e91d7-5c4f-4751-a7e6-6e28fa9076c1","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","destroyAfterUse":"true","home":true,"onClick":"@const {\r\n    dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal\r\n} = that ?? {}\r\n\r\nif (!dimension) {\r\n    return;\r\n}\r\n\r\nshout(\"abMenuRefresh\");\r\nshout('clearAiKitAgentBotMenu');\r\n\r\nconfigBot.tags.menuPortal = \"ai_kit_bot_menu\";\r\n\r\nconst menuOptions = {\r\n    ai_kit_bot_menu: true,\r\n    color: 'white',\r\n}\r\n\r\nconst aiMenu = {\r\n    onClick: `@`,\r\n    ...menuOptions,\r\n    groupSortOrder: 1,\r\n    clearAiKitAgentBotMenu: `@destroy(this);`\r\n}\r\n\r\nconst aiChatModels = configBot.tags.aiChatModels ?? [];\r\n\r\nif (aiChatModels.length > 0) {\r\n    const providerDropdowns = {};\r\n\r\n    for (let i = 0; i < aiChatModels.length; ++i) {\r\n        let dropdown = providerDropdowns[aiChatModels[i].provider];\r\n\r\n        if (!dropdown) {\r\n            dropdown = {\r\n                menuItemType: \"dropdown\",\r\n                label: aiChatModels[i].provider,\r\n                dropdownOptions: []\r\n            }\r\n\r\n            providerDropdowns[aiChatModels[i].provider] = dropdown;\r\n        }\r\n        \r\n        const option = {\r\n            label: aiChatModels[i].name,\r\n            aiProvider: aiChatModels[i].provider,\r\n            aiModel: aiChatModels[i].name,\r\n            color: 'white',\r\n            botGen: await getLink(thisBot),\r\n            dimension,\r\n            onClick: `@\r\n                links.botGen.createAIAgent({\r\n                    dimension: tags.dimension,\r\n                    aiModel: tags.aiModel,\r\n                    aiProvider: tags.aiProvider\r\n                });\r\n            `,\r\n        }\r\n\r\n        dropdown.dropdownOptions.push(option);\r\n    }\r\n\r\n    const menuItems = [];\r\n    for (let provider in providerDropdowns) {\r\n        menuItems.push(providerDropdowns[provider]);\r\n    }\r\n    aiMenu[\"menuItems\"] = menuItems;\r\n\r\n    ab.links.menu.abCreateMenuGroup(aiMenu);\r\n} else {\r\n    if (authBot) {\r\n        os.showAlert({\r\n            title: 'something went wrong',\r\n            content: 'failed to get list of ai chat models.'\r\n        })\r\n    } else {\r\n        os.showAlert({\r\n            title: 'sign in required',\r\n            content: 'you must sign in to use ai.'\r\n        })\r\n    }\r\n}\r\n\r\nthisBot.animateSpin();","system":"agent_bot_tool.maker","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","homeX":8,"homeY":1,"onGridClick":"@shout(\"clearAiKitAgentBotMenu\")","createAIAgent":"@const { dimension, aiModel, aiProvider } = that;\r\n\r\nshout(\"clearAiKitAgentBotMenu\");\r\n\r\nconst agentConfig = tags.agentConfigs[aiProvider] ?? tags.agentConfigs['default'];\r\n\r\nconst botTags = {\r\n    abIDOrigin: null,\r\n    abIgnore: true,\r\n    aiModel,\r\n    aiProvider,\r\n    ai_toolbox: null,\r\n    listening: true,\r\n    menuColor: agentConfig.themeColor,\r\n    armColor: agentConfig.themeColor,\r\n    armMeshPath: agentConfig.armMeshPath,\r\n    scale: agentConfig.scale,\r\n    system: \"ai.agent.\" + aiModel\r\n}\r\n\r\nif (agentConfig.meshPath) {\r\n    if (agentConfig.meshPath.startsWith('https://')) {\r\n        botTags.formAddress = agentConfig.meshPath;\r\n    } else {\r\n        botTags.formAddress = ab.abBuildCasualCatalogURL(agentConfig.meshPath);\r\n    }\r\n\r\n    botTags.form = 'mesh';\r\n    botTags.formSubtype = 'gltf';\r\n} else {\r\n    botTags.form = 'cube';\r\n    botTags.strokeWidth = 1;\r\n    botTags.strokeColor = agentConfig.themeColor;\r\n    botTags.color = 'clear';\r\n}\r\n\r\nif (agentConfig.showName) {\r\n    botTags.label = aiModel;\r\n    botTags.labelPosition = 'floatingBillboard';\r\n    botTags.labelFloatingBackgroundColor = agentConfig.themeColor;\r\n    botTags.labelWordWrapMode = 'none';\r\n}\r\n\r\nconst dimensionX = thisBot.tags[dimension + 'X'] ?? 0;\r\nconst dimensionY = thisBot.tags[dimension + 'Y'] ?? 0;\r\n\r\nbotTags.dimension = dimension;\r\nbotTags[dimension] = true;\r\nbotTags[dimension + 'X'] = dimensionX;\r\nbotTags[dimension + 'Y'] = dimensionY;\r\n\r\nif (links.agentModel) {\r\n    const bot = await create(links.agentModel, botTags);\r\n\r\n    if (bot && tags.destroyAfterUse) {\r\n        destroy(links.agentModel);\r\n        destroy(thisBot);\r\n    }\r\n}\r\n\r\n","formOpacity":"0.33","strokeColor":"white","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","cursor":"pointer","onCreate":"@tags.abIgnore = true;\r\nthisBot.onClick();","agentConfigs":"ðŸ§¬{\n    \"openai\": {\n        \"meshPath\": \"/ab/meshes/casualBot_chatGPT_01.glb\",\n        \"armMeshPath\": \"/ab/meshes/webslinger.glb\",\n        \"themeColor\": \"#76a298\",\n        \"scale\": 0.9999,\n        \"formOpacity\": null,\n        \"showName\": false\n    },\n    \"google\": {\n        \"meshPath\": \"/ab/meshes/casualBot_gemini_01.glb\",\n        \"armMeshPath\": \"/ab/meshes/webslinger.glb\",\n        \"themeColor\": \"#3187ea\",\n        \"scale\": 0.9999,\n        \"formOpacity\": null,\n        \"showName\": false\n    },\n    \"anthropic\": {\n        \"meshPath\": \"/ab/meshes/casualBot_claude_01.glb\",\n        \"armMeshPath\": \"/ab/meshes/webslinger.glb\",\n        \"themeColor\": \"#d4825a\",\n        \"scale\": 0.9999,\n        \"formOpacity\": null,\n        \"showName\": false\n    },\n    \"default\": {\n        \"meshPath\": null,\n        \"armMeshPath\": null,\n        \"themeColor\": \"gold\",\n        \"scale\": 0.9,\n        \"formOpacity\": 0.33,\n        \"showName\": true\n    }\n}","label":"make an agent","labelPosition":"floatingBillboard","labelWordWrapMode":"none","scale":"0.9","agent_bot_tool":"true","abVersion":"10.39","abIgnore":true,"onEggHatch":"@if (that.eggParameters) {\r\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n\r\n    if (that.eggParameters.aiModel) {\r\n        // AI model has been provided with egg parameters, make it immediately.\r\n        const aiChatModels = configBot.tags.aiChatModels ?? (await ai.listChatModels());\r\n        const match = aiChatModels.find(e => e.name === that.eggParameters.aiModel);\r\n\r\n        if (match) {\r\n            thisBot.createAIAgent({\r\n                dimension,\r\n                aiModel: match.name,\r\n                aiProvider: match.provider\r\n            })\r\n        } else {\r\n            console.error(`[${tags.system}.${tagName}] '${aiModel}' is not a supported ai model.`);\r\n        }\r\n    }\r\n}","abIDOrigin":"agent_bot_tool","homeZ":0,"onDestroy":"@shout('clearAiKitAgentBotMenu');\ndestroy(links.agentModel);","agentModel":"ðŸ”—c50ab58a-7aa7-4db2-a39a-f6e96b75e3c0"}},"c50ab58a-7aa7-4db2-a39a-f6e96b75e3c0":{"id":"c50ab58a-7aa7-4db2-a39a-f6e96b75e3c0","space":"shared","tags":{"creator":"bdbeef26-8eb0-494e-b5df-94114c7f6155","abAgent":"true","abMenuRefresh":"@thisBot.agentReset();","abVersion":"10.39","agentOnRequest":"@thisBot.agentReset();\n\nlet inquiry = that.inquiry ?? that;\n\nconst abAskBot = ab.links.ask;\n\nabAskBot.masks.gptActive = true;\n\nconst data = {\n    dimension: that.data?.armDimension,\n    dimensionX: that.data?.armDimensionX,\n    dimensionY: that.data?.armDimensionY,\n    bot: links.targetBot?.id,\n    bots: that.data?.bots,\n}\n\nconst prevLabel = tags.label;\ntags.label = null;\n\nconst inMapPortal = configBot.tags.mapPortal === tags.dimension || configBot.tags.miniMapPortal === tags.dimension;\nconst inGridPortal = configBot.tags.gridPortal === tags.dimension || configBot.tags.miniGridPortal === tags.dimension;\n\n// Determine where the patch bot will be placed. Default to the current position of this agent bot.\nlet patchBotPosition = getBotPosition(thisBot, tags.dimension);\n\nif (!inMapPortal && inGridPortal) {\n    const openPosition = thisBot.findOpenPositionAround({\n        originPosition: getBotPosition(thisBot, tags.dimension),\n        distance: 3,\n        dimension: tags.dimension,\n        interval: 1,\n    })\n\n    if (openPosition) {\n        patchBotPosition = openPosition;\n    }\n}\n\nabAskBot.askGPT({\n    inquiry,\n    prompt: tags.promptType,\n    model: tags.aiModel,\n    abBot: thisBot,\n    abDimension: tags.dimension,\n    abPosition: patchBotPosition,\n    data,\n})\n\n// Wait some amount of time before bringing bot label back.\nawait os.sleep(1600 + 250);\ntags.label = prevLabel;","agentReset":"@if (masks.armBot) {\n    destroy(links.armBot);\n    masks.armBot = null;\n}\n\nclearTagMasks(thisBot);\n\nshout('onABAIAgentReset');\n\nif (globalThis.abRemember) {\n    abRemember.masks.abBuilderIdentity = null;\n}","aiModel":"unset","askAgent":"@const menuPortal = configBot.tags.menuPortal ?? \"menu\";\n\nif (!configBot.tags.menuPortal) {\n    configBot.tags.menuPortal = menuPortal;\n}\n\nif (thisBot.vars.inputBot) {\n    destroy(thisBot.vars.inputBot);\n    thisBot.vars.inputBot = null;\n}\n\nthisBot.vars.inputBot = ab.links.menu.abCreateMenuInput({\n    [menuPortal]: true,\n    dimension: menuPortal,\n    label: `ask ${tags.aiModel}`,\n    color: tags.menuColor,\n    labelColor: 'black',\n    promptType: that.prompt,\n    agentBotId: thisBot.id,\n    agentBot: getLink(thisBot),\n    onABAIAgentReset: `@destroy(thisBot)`,\n    onSubmit: `@\n        links.agentBot.masks.promptType = tags.promptType;\n        links.agentBot.onSubmit(that);\n    `,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (botIDs.includes(tags.agentBotId)) {\n            shout('onABAIAgentReset');\n        }\n    `,\n})\n\nif (that.bot && that.prompt === \"bot\") {\n    masks.targetBot = getLink(that.bot);\n}\n\nabRemember.masks.abBuilderIdentity = tags.aiModel;\n\nthisBot.animateSpin();","botChat":"@const dimension = configBot.tags.gridPortal;\nconst message = that.message;\nconst messageTime = that.time ? that.time * 1000 : 1600; \n\nab.links.manifestation.abBotChat({\n    bot: thisBot,\n    dimension,\n    message,\n    messageTime,\n});","onClick":"@thisBot.askAgent({ prompt: \"core\" });","onSubmit":"@console.log(`[${tags.system}.${tagName}] that:`, that);\n\nconst requestData = {};\nconst activeDimension = that.dimension ?? configBot.tags.gridPortal;\n\nif (links.armBot) {\n    const armBot = links.armBot;\n    const armDimension = armBot.tags.dimension;\n\n    requestData.armDimension = armDimension;\n    requestData.armDimensionX = armBot.tags[armDimension + \"X\"];\n    requestData.armDimensionY = armBot.tags[armDimension + \"Y\"];\n}\n\nconst inquiry = that.text;\n\nconst aiRequest = await thisBot.agentOnRequest({inquiry, data: requestData, model: tags.aiModel});","system":"agent_bot_tool.model","agent_bot_tool":"true","abIgnore":true,"abIDOrigin":"agent_bot_tool","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nconst FULL_TURN = Math.PI * 2;\n\nconst nextZeroEquivalent = Math.ceil(currentRotZ / FULL_TURN) * FULL_TURN;\nconst targetRotZ = nextZeroEquivalent + FULL_TURN;\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 1,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","cursor":"pointer","armSelection":"true","onArmSelectedBots":"@const selectedBots = that;\n\nassert(!Array.isArray(selectedBots), `[${tags.system}.${tagName}] agent bots are not currently designed to support multi-selected bots. Support must be added.`);\n\nthisBot.askAgent({ prompt: \"bot\", bot: selectedBots });","onArmPlaced":"@thisBot.askAgent({ prompt: \"grid\" });","armMultiSelect":"false","onArmDestroy":"@thisBot.agentReset();","onGridClick":"@thisBot.agentReset();","listening":"false","findOpenPositionAround":"@const { \n    originPosition, \n    distance, \n    dimension,\n    interval,\n} = that;\n\nassert(originPosition, `[${tags.system}.${tagName}] originPosition is a required parameter.`);\nassert(distance > 0, `[${tags.system}.${tagName}] distance must be greater than zero.`);\nassert(dimension, `[${tags.system}.${tagName}] dimension is a required parameter.`);\nassert(interval > 0, `[${tags.system}.${tagName}] interval must be greater than zero.`);\n\nconst DEBUG = true;\n\n// Helper to round to nearest interval (avoids floating point drift)\nfunction roundTo(value: number, interval: number): number {\n  return Math.round(value / interval) * interval;\n}\n\nfunction findOpenPosition(position: Vector2, distance: number, dimension: string, interval: number = 1): Vector2 | null {\n    // Create a set of all occupied positions in the dimension.\n    const occupied = new Set();\n\n    // Round to avoid floating point mismatches when building the set\n    const toKey = (x: number, y: number) => `${roundTo(x, interval)},${roundTo(y, interval)}`;\n\n    // Create a set of all occupied positions in the dimensions.\n    getBots((b) => {\n        if (b.tags[dimension]) {\n            const pos = getBotPosition(b, dimension);\n            occupied.add(toKey(pos.x, pos.y));\n        }\n    });\n\n    if (DEBUG) {\n        console.log(`[${tags.system}.${tagName}] occupied:`, occupied);\n    }\n\n    // Calculate number of steps based on distance and interval\n    const steps = Math.round(distance / interval);\n\n    // Start from outer shell, work inward\n    for (let d = steps; d >= 1; d--) {\n        for (let xi = -d; xi <= d; xi++) {\n            for (let yi = -d; yi <= d; yi++) {\n                if (Math.abs(xi) === d || Math.abs(yi) === d) {\n                    const x = roundTo(position.x + xi * interval, interval);\n                    const y = roundTo(position.y + yi * interval, interval);\n                    const key = toKey(x, y);\n                    \n                    if (DEBUG) {\n                        console.log(`[${tags.system}.${tagName}] key:`, key);\n                    }\n\n                    if (!occupied.has(key)) {\n                        if (DEBUG) {\n                            console.log(`[${tags.system}.${tagName}] occupied does not have:`, key);\n                        }\n                        return new Vector2(x, y);\n                    } else {\n                        if (DEBUG) {\n                            console.log(`[${tags.system}.${tagName}] occupied has:`, key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return null;\n}\n\nconst openPosition = findOpenPosition(originPosition, distance, tags.dimension, 1);\n\nif (DEBUG) {\n    console.log(`[${tags.system}.${tagName}] openPosition:`, openPosition);\n}\n\nreturn openPosition;"}}}}