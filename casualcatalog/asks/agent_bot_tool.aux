{"version":1,"state":{"0e839956-3da9-4705-98d9-4d4aa167e68c":{"id":"0e839956-3da9-4705-98d9-4d4aa167e68c","space":"shared","tags":{"creator":"bdbeef26-8eb0-494e-b5df-94114c7f6155","abAgent":"true","abMenuRefresh":"@thisBot.agentReset();","abVersion":"10.34","agentOnRequest":"@thisBot.agentReset();\n\nlet inquiry = that.inquiry ?? that;\n\nconst abAskBot = ab.links.ask;\n\nabAskBot.masks.gptActive = true;\n\nconst data = {\n    dimension: that.data?.armDimension,\n    dimensionX: that.data?.armDimensionX,\n    dimensionY: that.data?.armDimensionY,\n    bot: links.targetBot?.id,\n    bots: that.data?.bots,\n}\n\nif (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n    console.log(`[${tags.system}.${tagName}] destroy billboard label bot`);\n}\n\nabAskBot.askGPT({\n    inquiry,\n    prompt: tags.promptType,\n    model: tags.aiModel,\n    abBot: thisBot,\n    abDimension: tags.dimension,\n    abPosition: getBotPosition(thisBot, tags.dimension),\n    data,\n})\n\n// Wait some amount of time before bringing bot label back.\nawait os.sleep(1600 + 250);\nthisBot.updateBillboardLabel();","agentReset":"@if (links.arm) {\n    destroy(links.arm);\n}\n\nclearTagMasks(thisBot);\n\nshout('onABAIAgentReset');\n\nif (globalThis.abRemember) {\n    abRemember.masks.abBuilderIdentity = null;\n}","aiModel":"unset","askAgent":"@const menuPortal = configBot.tags.menuPortal ?? \"menu\";\n\nif (!configBot.tags.menuPortal) {\n    configBot.tags.menuPortal = menuPortal;\n}\n\nif (thisBot.vars.inputBot) {\n    destroy(thisBot.vars.inputBot);\n    thisBot.vars.inputBot = null;\n}\n\nthisBot.vars.inputBot = ab.links.menu.abCreateMenuInput({\n    [menuPortal]: true,\n    dimension: menuPortal,\n    label: `ask ${tags.aiModel}`,\n    color: tags.menuColor,\n    labelColor: 'black',\n    promptType: that.prompt,\n    agentBotId: thisBot.id,\n    agentBot: getLink(thisBot),\n    onABAIAgentReset: `@destroy(thisBot)`,\n    onSubmit: `@\n        links.agentBot.masks.promptType = tags.promptType;\n        links.agentBot.onSubmit(that);\n    `,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (botIDs.includes(tags.agentBotId)) {\n            shout('onABAIAgentReset');\n        }\n    `,\n})\n\nif (that.bot && that.prompt === \"bot\") {\n    masks.targetBot = getLink(that.bot);\n}\n\nabRemember.masks.abBuilderIdentity = tags.aiModel;\n\nthisBot.animateSpin();","scale":"0.9","botChat":"@const dimension = configBot.tags.gridPortal;\nconst message = that.message;\nconst messageTime = that.time ? that.time * 1000 : 1600; \n\n\nab.links.manifestation.abBotChat({\n    bot: thisBot,\n    dimension,\n    message,\n    messageTime,\n});\n\nawait os.sleep(messageTime + 250);\n\nthisBot.updateBillboardLabel();","color":"gold","labelColor":"gold","menuColor":"gold","onArmClick":"@const arm = that.arm;\nconst dimension = arm.tags.dimension;\nconst targetX = arm.tags[dimension + \"X\"];\nconst targetY = arm.tags[dimension + \"Y\"];\n\ntags[dimension] = true;\ntags[dimension + \"X\"] = targetX;\ntags[dimension + \"Y\"] = targetY;\n\nthisBot.agentReset();","onClick":"@thisBot.askAgent({prompt: \"core\"});","onDrag":"@os.hideChat();\n\n// if (links.remember.links.abMultipleBotFocus && that.bot.id == id)\n// {\n//     os.enableCustomDragging();\n\n//     return;\n// }\n\n\nif (tags.arm)\n{\n    await thisBot.agentReset();\n}\n\n// if (!that.bot.tags.interval)\n// {\n//     thisBot.abClick();\n// }\n\n//let state = os.getInputState(\"keyboard\", \"Shift\");\nlet arm = {};\n\narm.space = \"tempLocal\";\narm[that.dimension] = true;\narm[that.dimension + \"X\"] = tags[that.dimension + \"X\"];\narm[that.dimension + \"Y\"] = tags[that.dimension + \"Y\"];\narm.creator = thisBot.id;\narm.dimension = that.dimension ?? configBot.tags.gridPortal;\narm.scale = 0.9;\narm.scaleZ = 0.01;\narm.color = \"clear\";\narm.strokeColor = tags.strokeColor ?? tags.color;\narm.lineColor = tags.strokeColor ?? tags.color;\narm.lineTo = thisBot.id;\narm.manager = getLink(thisBot);\narm.onClick = \"@ links.manager.onArmClick({arm: thisBot});\";\narm.onDrop = `@ tags.draggable = false;\n\nif (that.to.bot)\n{\n    links.manager.masks.lineTo = that.to.bot.id;\n    links.manager.masks.lineColor = links.manager.tags.strokeColor;\n    \n    links.manager.askAgent({prompt: \"bot\", bot: that.to.bot});\n\n    destroy(thisBot);\n}\nelse\n{\n    links.manager.askAgent({prompt: \"grid\"});\n}`;\n\n// arm.onClick = `@ destroy(thisBot);\n\n// links.manager.abManifestBot({dimension: that.dimension, position:{x:tags[that.dimension + \"X\"],y:tags[that.dimension + \"Y\"]}});`;\n\n// if (state)\n// {\n//     arm.multiSelect = true;\n//     arm.form = \"sphere\";\n//     arm.color = links.remember.tags.abBaseStrokeColor;\n\n//     masks.draggable = true;\n// }\n\nlet newArm = await create(arm);\n\nmasks.arm = \"ðŸ”—\" + newArm.id;\n\nos.replaceDragBot(newArm);","onGridClick":"@thisBot.agentReset();","onSubmit":"@console.log(`[${tags.system}.${tagName}] that:`, that);\n\nconst requestData = {};\nconst activeDimension = that.dimension ?? configBot.tags.gridPortal;\n\nif (links.arm) {\n    const arm = links.arm;\n    const armDimension = arm.tags.dimension;\n\n    requestData.armDimension = armDimension;\n    requestData.armDimensionX = arm.tags[armDimension + \"X\"];\n    requestData.armDimensionY = arm.tags[armDimension + \"Y\"];\n}\n\nconst inquiry = that.text;\n\nconst aiRequest = await thisBot.agentOnRequest({inquiry, data: requestData, model: tags.aiModel});","strokeColor":"gold","system":"ai_toolbox.tool.agentModel","onCreate":"@tags.abIgnore = true;","ai_toolbox_tools":"true","agent_bot_tool":"true","abIgnore":true,"abIDOrigin":"agent_bot_tool","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nif (globalThis.ab?.links.bot_factory) {\n    const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\n    const botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\n    if (botInDimension) {\n        console.log(`[${tags.system}.${tagName}] create billboard label bot`);\n        thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n            bot: thisBot,\n            label: tags.aiModel,\n            color: 'gold',\n            labelColor: 'black',\n            dimension: currentDimension,\n            space: 'tempLocal',\n        })\n    }\n}","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nthisBot.updateBillboardLabel();","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}","formOpacity":"0.33","cursor":"pointer"}},"e4ce43f4-c1cc-4cff-bff8-cd3bd67fc61d":{"id":"e4ce43f4-c1cc-4cff-bff8-cd3bd67fc61d","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","destroyAfterUse":"true","home":null,"onClick":"@const {\r\n    dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal\r\n} = that ?? {}\r\n\r\nif (!dimension) {\r\n    return;\r\n}\r\n\r\nshout(\"abMenuRefresh\");\r\nshout('clearAiKitAgentBotMenu');\r\n\r\nconfigBot.tags.menuPortal = \"ai_kit_bot_menu\";\r\n\r\nconst menuOptions = {\r\n    ai_kit_bot_menu: true,\r\n    color: 'white',\r\n}\r\n\r\nconst aiMenu = {\r\n    onClick: `@`,\r\n    ...menuOptions,\r\n    groupSortOrder: 1,\r\n    clearAiKitAgentBotMenu: `@destroy(this);`\r\n}\r\n\r\nconst aiChatModels = configBot.tags.aiChatModels ?? [];\r\nconst providerDropdowns = {};\r\n\r\nfor (let i = 0; i < aiChatModels.length; ++i) {\r\n    let dropdown = providerDropdowns[aiChatModels[i].provider];\r\n\r\n    if (!dropdown) {\r\n        dropdown = {\r\n            menuItemType: \"dropdown\",\r\n            label: aiChatModels[i].provider,\r\n            dropdownOptions: []\r\n        }\r\n\r\n        providerDropdowns[aiChatModels[i].provider] = dropdown;\r\n    }\r\n    \r\n    const option = {\r\n        label: aiChatModels[i].name,\r\n        aiModel: aiChatModels[i].name,\r\n        color: 'white',\r\n        botGen: await getLink(thisBot),\r\n        dimension,\r\n        onClick: `@\r\n            links.botGen.createAIAgent({ dimension: tags.dimension, aiModel: tags.aiModel });\r\n        `,\r\n    }\r\n\r\n    dropdown.dropdownOptions.push(option);\r\n}\r\n\r\nconst menuItems = [];\r\nfor (let provider in providerDropdowns) {\r\n    menuItems.push(providerDropdowns[provider]);\r\n}\r\naiMenu[\"menuItems\"] = menuItems;\r\n\r\nab.links.menu.abCreateMenuGroup(aiMenu);\r\nthisBot.animateSpin();","system":"ai_toolbox.tool.agent maker","remember":"ðŸ”—e5380a6b-8b4d-4a8b-8b04-58e1eb03e5e7","homeX":null,"homeY":null,"onGridClick":"@shout(\"clearAiKitAgentBotMenu\")","createAIAgent":"@const { dimension, aiModel } = that;\r\n\r\nshout(\"clearAiKitAgentBotMenu\");\r\n\r\nconst botTags = {\r\n    abIDOrigin: null,\r\n    aiModel,\r\n    ai_toolbox: null,\r\n    system: \"ai.agent.\" + aiModel\r\n}\r\n\r\nconst dimensionX = thisBot.tags[dimension + 'X'] ?? 0;\r\nconst dimensionY = thisBot.tags[dimension + 'Y'] ?? 0;\r\n\r\nbotTags.dimension = dimension;\r\nbotTags[dimension] = true;\r\nbotTags[dimension + 'X'] = dimensionX;\r\nbotTags[dimension + 'Y'] = dimensionY;\r\n\r\nconst agentModel = getBot(\"system\", \"ai_toolbox.tool.agentModel\");\r\n\r\nif (agentModel) {\r\n    const bot = await create(agentModel, botTags);\r\n\r\n    if (bot && tags.destroyAfterUse) {\r\n        destroy(agentModel);\r\n        destroy(thisBot);\r\n    }\r\n}\r\n\r\n","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\n    destroy(thisBot.vars.billboardLabelBot);\n    thisBot.vars.billboardLabelBot = null;\n}\n\nif (globalThis.ab?.links.bot_factory) {\n    const currentDimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\n    const botInDimension = currentDimension && thisBot.tags[currentDimension] === true;\n\n    if (botInDimension) {\n        thisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \n            bot: thisBot,\n            label: 'make an agent',\n            // color: tags.abPatchColor,\n            dimension: currentDimension,\n            labelColor: '#000000',\n            space: 'tempLocal',\n        })\n    }\n}","onBotAdded":"@let waitTime = 0;\n\nwhile(!globalThis.ab?.links.bot_factory) {\n    if (waitTime >= 5000) {\n        return;\n    }\n    \n    await os.sleep(250);\n    waitTime += 250;\n}\n\nthisBot.updateBillboardLabel();","formOpacity":"0.33","strokeColor":"white","animateSpin":"@clearAnimations(thisBot);\n\nconst dimension = configBot.tags.mapPortal ?? configBot.tags.gridPortal;\nlet currentRotZ = tags[dimension + 'RotationZ'] ?? 0;\n\nfunction getNextOrthogonalSpin(currentRotZ) {\n    const HALF_TURN = Math.PI;\n    const QUARTER_TURN = Math.PI / 2;\n\n    const minTarget = currentRotZ + HALF_TURN;\n    const nextMultiple = Math.ceil(minTarget / QUARTER_TURN) * QUARTER_TURN;\n    return nextMultiple;\n}\n\nconst targetRotZ = getNextOrthogonalSpin(currentRotZ);\n\nawait animateTag(thisBot, {\n    fromValue: {\n        [dimension + 'RotationZ']: currentRotZ,\n    },\n    toValue: {\n        [dimension + 'RotationZ']: targetRotZ,\n    },\n    easing: {\n        type: \"sinusoidal\",\n        mode: \"inout\"\n    },\n    duration: 0.5,\n    tagMaskSpace: 'tempLocal',\n}).catch(() => {});\n\nmasks[dimension + 'RotationZ'] = null;","cursor":"pointer","onPortalChanged":"@const { portal, dimension } = that;\n\nif (portal === 'gridPortal' || portal === 'mapPortal') {\n    thisBot.updateBillboardLabel();\n}","onCreate":"@tags.abIgnore = true;\r\nthisBot.onClick();","ai_toolbox_tools":"true","agent_bot_tool":"true","abVersion":"10.34","abIgnore":true,"onEggHatch":"@if (that.eggParameters) {\r\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n}","abIDOrigin":"agent_bot_tool","homeZ":null}}}}