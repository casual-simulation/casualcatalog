{"version":1,"state":{"0767548a-0c95-4f01-bf39-f72fb1ba386c":{"id":"0767548a-0c95-4f01-bf39-f72fb1ba386c","space":"shared","tags":{"system":"arWebSlinger.fonts","robotoData":"ðŸ§¬{\"pages\":[\"Roboto.png\"],\"chars\":[{\"id\":0,\"x\":0,\"y\":0,\"width\":0,\"height\":0,\"xoffset\":-4,\"yoffset\":0,\"xadvance\":0,\"page\":0,\"chnl\":0},{\"id\":10,\"x\":0,\"y\":0,\"width\":0,\"height\":0,\"xoffset\":-4,\"yoffset\":0,\"xadvance\":0,\"page\":0,\"chnl\":0},{\"id\":32,\"x\":0,\"y\":0,\"width\":0,\"height\":0,\"xoffset\":-4,\"yoffset\":0,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":33,\"x\":378,\"y\":42,\"width\":12,\"height\":32,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":34,\"x\":465,\"y\":106,\"width\":15,\"height\":16,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":10,\"page\":0,\"chnl\":0},{\"id\":35,\"x\":463,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-3,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":36,\"x\":152,\"y\":0,\"width\":24,\"height\":39,\"xoffset\":-3,\"yoffset\":-1,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":37,\"x\":110,\"y\":42,\"width\":30,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":23,\"page\":0,\"chnl\":0},{\"id\":38,\"x\":140,\"y\":42,\"width\":27,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":39,\"x\":480,\"y\":106,\"width\":11,\"height\":16,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":6,\"page\":0,\"chnl\":0},{\"id\":40,\"x\":0,\"y\":0,\"width\":17,\"height\":42,\"xoffset\":-2,\"yoffset\":0,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":41,\"x\":17,\"y\":0,\"width\":17,\"height\":42,\"xoffset\":-4,\"yoffset\":0,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":42,\"x\":388,\"y\":106,\"width\":22,\"height\":22,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":14,\"page\":0,\"chnl\":0},{\"id\":43,\"x\":321,\"y\":106,\"width\":24,\"height\":25,\"xoffset\":-3,\"yoffset\":7,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":44,\"x\":452,\"y\":106,\"width\":13,\"height\":17,\"xoffset\":-4,\"yoffset\":22,\"xadvance\":6,\"page\":0,\"chnl\":0},{\"id\":45,\"x\":38,\"y\":133,\"width\":17,\"height\":11,\"xoffset\":-4,\"yoffset\":15,\"xadvance\":9,\"page\":0,\"chnl\":0},{\"id\":46,\"x\":26,\"y\":133,\"width\":12,\"height\":13,\"xoffset\":-2,\"yoffset\":22,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":47,\"x\":68,\"y\":42,\"width\":21,\"height\":33,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":13,\"page\":0,\"chnl\":0},{\"id\":48,\"x\":23,\"y\":42,\"width\":24,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":49,\"x\":381,\"y\":75,\"width\":18,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":50,\"x\":308,\"y\":42,\"width\":24,\"height\":32,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":51,\"x\":458,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":52,\"x\":399,\"y\":75,\"width\":26,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":53,\"x\":332,\"y\":42,\"width\":23,\"height\":32,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":54,\"x\":355,\"y\":42,\"width\":23,\"height\":32,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":55,\"x\":425,\"y\":75,\"width\":24,\"height\":31,\"xoffset\":-3,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":56,\"x\":481,\"y\":0,\"width\":24,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":57,\"x\":0,\"y\":42,\"width\":23,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":58,\"x\":115,\"y\":106,\"width\":12,\"height\":27,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":59,\"x\":449,\"y\":75,\"width\":14,\"height\":31,\"xoffset\":-4,\"yoffset\":8,\"xadvance\":7,\"page\":0,\"chnl\":0},{\"id\":60,\"x\":345,\"y\":106,\"width\":21,\"height\":23,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":16,\"page\":0,\"chnl\":0},{\"id\":61,\"x\":430,\"y\":106,\"width\":22,\"height\":18,\"xoffset\":-2,\"yoffset\":10,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":62,\"x\":366,\"y\":106,\"width\":22,\"height\":23,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":63,\"x\":47,\"y\":42,\"width\":21,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":15,\"page\":0,\"chnl\":0},{\"id\":64,\"x\":117,\"y\":0,\"width\":35,\"height\":39,\"xoffset\":-3,\"yoffset\":3,\"xadvance\":29,\"page\":0,\"chnl\":0},{\"id\":65,\"x\":390,\"y\":42,\"width\":29,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":21,\"page\":0,\"chnl\":0},{\"id\":66,\"x\":419,\"y\":42,\"width\":25,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":67,\"x\":216,\"y\":0,\"width\":27,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":21,\"page\":0,\"chnl\":0},{\"id\":68,\"x\":444,\"y\":42,\"width\":26,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":21,\"page\":0,\"chnl\":0},{\"id\":69,\"x\":470,\"y\":42,\"width\":24,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":70,\"x\":0,\"y\":75,\"width\":23,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":71,\"x\":243,\"y\":0,\"width\":27,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":22,\"page\":0,\"chnl\":0},{\"id\":72,\"x\":23,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":23,\"page\":0,\"chnl\":0},{\"id\":73,\"x\":494,\"y\":42,\"width\":12,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":9,\"page\":0,\"chnl\":0},{\"id\":74,\"x\":167,\"y\":42,\"width\":24,\"height\":32,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":75,\"x\":50,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":76,\"x\":77,\"y\":75,\"width\":23,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":77,\"x\":100,\"y\":75,\"width\":32,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":28,\"page\":0,\"chnl\":0},{\"id\":78,\"x\":132,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":23,\"page\":0,\"chnl\":0},{\"id\":79,\"x\":270,\"y\":0,\"width\":28,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":22,\"page\":0,\"chnl\":0},{\"id\":80,\"x\":159,\"y\":75,\"width\":25,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":81,\"x\":176,\"y\":0,\"width\":28,\"height\":36,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":22,\"page\":0,\"chnl\":0},{\"id\":82,\"x\":184,\"y\":75,\"width\":26,\"height\":31,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":83,\"x\":298,\"y\":0,\"width\":25,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":19,\"page\":0,\"chnl\":0},{\"id\":84,\"x\":210,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":19,\"page\":0,\"chnl\":0},{\"id\":85,\"x\":191,\"y\":42,\"width\":25,\"height\":32,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":21,\"page\":0,\"chnl\":0},{\"id\":86,\"x\":237,\"y\":75,\"width\":28,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":87,\"x\":265,\"y\":75,\"width\":36,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":28,\"page\":0,\"chnl\":0},{\"id\":88,\"x\":301,\"y\":75,\"width\":28,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":20,\"page\":0,\"chnl\":0},{\"id\":89,\"x\":329,\"y\":75,\"width\":27,\"height\":31,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":19,\"page\":0,\"chnl\":0},{\"id\":90,\"x\":356,\"y\":75,\"width\":25,\"height\":31,\"xoffset\":-3,\"yoffset\":3,\"xadvance\":19,\"page\":0,\"chnl\":0},{\"id\":91,\"x\":51,\"y\":0,\"width\":15,\"height\":39,\"xoffset\":-2,\"yoffset\":0,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":92,\"x\":89,\"y\":42,\"width\":21,\"height\":33,\"xoffset\":-4,\"yoffset\":3,\"xadvance\":13,\"page\":0,\"chnl\":0},{\"id\":93,\"x\":66,\"y\":0,\"width\":15,\"height\":39,\"xoffset\":-4,\"yoffset\":0,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":94,\"x\":410,\"y\":106,\"width\":20,\"height\":20,\"xoffset\":-3,\"yoffset\":3,\"xadvance\":13,\"page\":0,\"chnl\":0},{\"id\":95,\"x\":55,\"y\":133,\"width\":23,\"height\":11,\"xoffset\":-4,\"yoffset\":26,\"xadvance\":14,\"page\":0,\"chnl\":0},{\"id\":96,\"x\":491,\"y\":106,\"width\":16,\"height\":13,\"xoffset\":-4,\"yoffset\":2,\"xadvance\":10,\"page\":0,\"chnl\":0},{\"id\":97,\"x\":0,\"y\":106,\"width\":23,\"height\":27,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":98,\"x\":323,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":99,\"x\":23,\"y\":106,\"width\":23,\"height\":27,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":100,\"x\":346,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-3,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":101,\"x\":46,\"y\":106,\"width\":23,\"height\":27,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":102,\"x\":369,\"y\":0,\"width\":20,\"height\":33,\"xoffset\":-4,\"yoffset\":1,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":103,\"x\":389,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":104,\"x\":216,\"y\":42,\"width\":22,\"height\":32,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":105,\"x\":238,\"y\":42,\"width\":12,\"height\":32,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":106,\"x\":34,\"y\":0,\"width\":17,\"height\":39,\"xoffset\":-6,\"yoffset\":2,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":107,\"x\":250,\"y\":42,\"width\":23,\"height\":32,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":16,\"page\":0,\"chnl\":0},{\"id\":108,\"x\":273,\"y\":42,\"width\":12,\"height\":32,\"xoffset\":-2,\"yoffset\":2,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":109,\"x\":127,\"y\":106,\"width\":32,\"height\":26,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":28,\"page\":0,\"chnl\":0},{\"id\":110,\"x\":159,\"y\":106,\"width\":22,\"height\":26,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":111,\"x\":69,\"y\":106,\"width\":24,\"height\":27,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":112,\"x\":412,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":113,\"x\":435,\"y\":0,\"width\":23,\"height\":33,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":114,\"x\":181,\"y\":106,\"width\":17,\"height\":26,\"xoffset\":-2,\"yoffset\":8,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":115,\"x\":93,\"y\":106,\"width\":22,\"height\":27,\"xoffset\":-3,\"yoffset\":8,\"xadvance\":17,\"page\":0,\"chnl\":0},{\"id\":116,\"x\":490,\"y\":75,\"width\":18,\"height\":30,\"xoffset\":-4,\"yoffset\":5,\"xadvance\":10,\"page\":0,\"chnl\":0},{\"id\":117,\"x\":198,\"y\":106,\"width\":22,\"height\":26,\"xoffset\":-2,\"yoffset\":9,\"xadvance\":18,\"page\":0,\"chnl\":0},{\"id\":118,\"x\":220,\"y\":106,\"width\":23,\"height\":25,\"xoffset\":-4,\"yoffset\":9,\"xadvance\":16,\"page\":0,\"chnl\":0},{\"id\":119,\"x\":243,\"y\":106,\"width\":32,\"height\":25,\"xoffset\":-4,\"yoffset\":9,\"xadvance\":24,\"page\":0,\"chnl\":0},{\"id\":120,\"x\":275,\"y\":106,\"width\":24,\"height\":25,\"xoffset\":-4,\"yoffset\":9,\"xadvance\":16,\"page\":0,\"chnl\":0},{\"id\":121,\"x\":285,\"y\":42,\"width\":23,\"height\":32,\"xoffset\":-4,\"yoffset\":9,\"xadvance\":15,\"page\":0,\"chnl\":0},{\"id\":122,\"x\":299,\"y\":106,\"width\":22,\"height\":25,\"xoffset\":-3,\"yoffset\":9,\"xadvance\":16,\"page\":0,\"chnl\":0},{\"id\":123,\"x\":81,\"y\":0,\"width\":18,\"height\":39,\"xoffset\":-3,\"yoffset\":1,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":124,\"x\":204,\"y\":0,\"width\":12,\"height\":36,\"xoffset\":-2,\"yoffset\":3,\"xadvance\":8,\"page\":0,\"chnl\":0},{\"id\":125,\"x\":99,\"y\":0,\"width\":18,\"height\":39,\"xoffset\":-4,\"yoffset\":1,\"xadvance\":11,\"page\":0,\"chnl\":0},{\"id\":126,\"x\":0,\"y\":133,\"width\":26,\"height\":15,\"xoffset\":-2,\"yoffset\":13,\"xadvance\":22,\"page\":0,\"chnl\":0}],\"kernings\":[],\"info\":{\"face\":\"Roboto-Regular\",\"size\":32,\"bold\":0,\"italic\":0,\"charset\":\"\",\"unicode\":0,\"stretchH\":100,\"smooth\":1,\"aa\":1,\"padding\":[4,4,4,4],\"spacing\":[-8,-8]},\"common\":{\"lineHeight\":38,\"base\":30,\"scaleW\":512,\"scaleH\":512,\"pages\":1,\"packed\":0}}","debug":"false","truncateLabel":"@const {\n    label,\n    fontSize,\n    fontName,\n    wordWrap,\n    maxWidth,\n    maxHeight,\n    gutterSpaces\n} = that;\n\nassert(maxWidth, `[${tags.system}] [@truncateLabel] maxWidth parameter is required.`);\nassert(maxHeight, `[${tags.system}] [@truncateLabel] maxHeight parameter is required.`);\nassert(gutterSpaces >= 0, `[${tags.system}] [@truncateLabel] gutterSpaces parameter must be a non-negative number.`);\n\nif (tags.debug) {\n    console.log(`[${tags.system}] ==== truncate label start ====`);\n    console.log(`[${tags.system}] that:`, that);\n    console.log(`[${tags.system}] label: '${label}'`);\n    console.log(`[${tags.system}] label length:`, label.length);\n}\n\nif (!wordWrap) {\n    const originalSize = thisBot.calculateLabelSize(that);\n\n    if (originalSize.width <= maxWidth && originalSize.height <= maxHeight) {\n        return label;\n    }\n}\n\nconst ellipse = '...';\nconst ellipseSize = thisBot.calculateLabelSize({\n    ...that,\n    label: ellipse\n});\n\nconst gutter = ' '.repeat(gutterSpaces);\nconst gutterSize = thisBot.calculateLabelSize({\n    ...that,\n    label: gutter\n});\n\nif (wordWrap) {\n    // 1. Word wrap the incoming label.\n    const lines = [];\n\n    // Split the string by white spaces, new lines, and words\n    let parts = label.split(/(\\s|\\n|\\w+)/);\n    // Filter out empty strings resulting from split\n    parts = parts.filter(part => part !== '');\n    // Remove the gutter characters at both the start and end of the label.\n    if (gutterSpaces > 0) {\n        parts.splice(0, gutterSpaces);\n        parts.splice(-gutterSpaces);\n    }\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] parts:`, parts);\n    }\n\n    let workingLine;\n    let workingLineWidth;\n\n    const pushAndStartWorkingLine = () => {\n        // Insert working line into lines and start new line.\n        if (workingLine != undefined) {\n            if (tags.debug) {\n                console.log(`[${tags.system}] pushing line: '${gutter + workingLine + gutter}'`);\n            }\n            lines.push(gutter + workingLine + gutter);\n        }\n\n        workingLine = '';\n        workingLineWidth = gutterSize.width * 2;\n    }\n\n    pushAndStartWorkingLine();\n\n    for (let part of parts) {\n        if (tags.debug) {\n            console.log(`[${tags.system}] part: '${part}'`);\n        }\n\n        if (part === '\\n') {\n            if (tags.debug) {\n                console.log(`[${tags.system}] break new line`);\n            }\n            pushAndStartWorkingLine();\n        } else {\n            const partSize = thisBot.calculateLabelSize({\n                ...that,\n                label: part\n            });\n\n            let potentialWidth = workingLineWidth + partSize.width;\n\n            if (potentialWidth > maxWidth) {\n                if (part === ' ') {\n                    // If a space is causing the new line, do not move it the next line.\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] break space`);\n                    }\n                    pushAndStartWorkingLine();\n                } else {\n                    let partLineWidth = partSize.width + (gutterSize.width * 2);\n                    if (partLineWidth > maxWidth) {\n                        // The part is too long to fit on one line. \n                        // We need to break the part and move the rest to the next line.\n                        if (tags.debug) {\n                            console.log(`[${tags.system}] break part`);\n                        }\n\n                        for (let i = 0; i < part.length; i++) {\n                            const char = part[i];\n                            const charSize = thisBot.calculateLabelSize({\n                                ...that,\n                                label: char\n                            });\n                            \n                            potentialWidth = workingLineWidth + charSize.width;\n\n                            if (potentialWidth > maxWidth) {\n                                // Need to split the part here. Push the working line and continue processing this part\n                                // on the next working line.\n                                if (tags.debug) {\n                                    console.log(`[${tags.system}] split part`);\n                                }\n                                pushAndStartWorkingLine();\n                                workingLine += char;\n                                workingLineWidth += charSize.width;\n                            } else {\n                                workingLine += char;\n                                workingLineWidth = potentialWidth;\n                            }\n                        }\n\n                    } else {\n                        if (tags.debug) {\n                            console.log(`[${tags.system}] break word`);\n                        }\n                        pushAndStartWorkingLine();\n                        workingLine += part;\n                        workingLineWidth += partSize.width;\n                    }\n                }\n            } else {\n                // Part fits on line.\n                workingLine += part;\n                workingLineWidth += partSize.width;\n            }\n        }\n    }\n\n    // After processing all the parts, if there is anything left in the workingLine add it to lines.\n    pushAndStartWorkingLine();\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] lines:`, lines);\n    }\n\n    function linesToLabel(lines) {\n        let label = '';\n        for (let i = 0; i < lines.length; i++) {\n            label += lines[i];\n\n            if (i !== lines.length - 1) {\n                label += '\\n';\n            }\n        }\n\n        return label;\n    }\n\n    let wrappedLabel = linesToLabel(lines);\n\n    const wrappedLabelSize = thisBot.calculateLabelSize({\n        ...that,\n        label: wrappedLabel\n    });\n\n    if (wrappedLabelSize.height > maxHeight) {\n        // If the wrapped label is too tall, then we need to truncate it.\n        // Remove lines until it fits.\n\n        // Get font data.\n        const fontDataTag = `${fontName}Data`;\n        const fontData = thisBot.tags[fontDataTag];\n\n        // Calculate the number of lines to remove in order for to fit it inside the maxHeight of the container.\n        const lineHeight = fontData.common.lineHeight * fontSize * 0.01;\n        const totalHeight = lineHeight * lines.length;\n        const linesToRemove = Math.ceil((totalHeight - maxHeight) / lineHeight);\n\n        // Remove the lines and truncate the first line with an ellipse.\n        const truncatedLines = lines.slice(linesToRemove);\n        truncatedLines[0] = gutter + ellipse + truncatedLines[0].substring(gutter.length + ellipse.length);\n        const truncatedLabel = linesToLabel(truncatedLines);\n\n        return truncatedLabel;\n    } else {\n        // Wrapped label fits in the container.\n        return wrappedLabel;\n    }\n} else {\n    let truncatedLabel = gutter + ellipse;\n    let truncatedWidth = gutterSize.width + ellipseSize.width;\n    let truncatedHeight = Math.max(gutterSize.height, ellipseSize.height);\n\n    for (let i = label.length - 1; i >= 0; i--) {\n        const char = label.charAt(i);\n        const charSize = thisBot.calculateLabelSize({\n            ...that,\n            label: char\n        });\n\n        const newWidth = truncatedWidth + charSize.width;\n        const newHeight = Math.max(truncatedHeight, charSize.height);\n\n        if (newWidth <= maxWidth && newHeight <= maxHeight) {\n            truncatedWidth = newWidth;\n            truncatedHeight = newHeight;\n            truncatedLabel = truncatedLabel.slice(0, gutter.length + ellipse.length) + char + truncatedLabel.slice(gutter.length + ellipse.length);\n        } else {\n            break;\n        }\n    }\n\n    return truncatedLabel;\n}","calculateLabelSize":"@let { \n    label,\n    fontSize,\n    fontName\n} = that;\n\n// Workaround for using split(' ') on text with many spaces next to each other.\nif (label === '') {\n    label = ' ';\n}\n\nassert(label, `[${tags.system}] [@calculateLabelSize] label parameter is required.`);\nassert(typeof fontSize === 'number' && fontSize >= 0, `[${tags.system}] [@calculateLabelSize] fontSize paramter must be a positive number.`);\nassert(fontName, `[${tags.system}] [@calculateLabelSize] fontName parameter is required.`);\n\n// Get font data.\nconst fontDataTag = `${fontName}Data`;\nconst fontData = thisBot.tags[fontDataTag];\n\nif (!fontData) {\n    console.error(`[${tags.system}] No font data found for ${fontName} underneath tag ${fontDataTag}`);\n    return null;\n}\n\nlet totalWidth = 0;\nlet totalHeight = fontData.common.lineHeight;\nlet lineWidth = 0;\n\n// Loop through label's characters, adding up width and height.\nfor (let i = 0; i < label.length; i++) {\n    const charCode = label.charCodeAt(i);\n    // console.log('charCode:', charCode);\n\n    if (charCode === 10) {\n        // New line\n        if (lineWidth > 0 &&\n            lineWidth > totalWidth\n        ) {\n            totalWidth = lineWidth;\n        }\n\n        lineWidth = 0;\n        totalHeight += fontData.common.lineHeight;\n    } else {\n        let charData = fontData.chars.find(c => c.id === charCode);\n\n        if (!charData) {\n            // If character is not includes, fallback to whitespace data.\n            charData = fontData.chars.find(c => c.id === 32);\n        }\n\n        if (Number.isFinite(charData.xadvance)) {\n            lineWidth += charData.xadvance;\n        } else {\n            if (tags.debug) {\n                console.warn(`[${tags.system}] [@calculateLabelSize] charCode ${charCode} does not define xadvance number property in the font data for ${fontName}`);\n            }\n        }\n    }\n}\n\nif (lineWidth > 0 &&\n    lineWidth > totalWidth\n) {\n    totalWidth = lineWidth;\n}\n\n// Convert width and height totals to gridPortal units.\ntotalWidth = totalWidth * fontSize * 0.01;\ntotalHeight = totalHeight * fontSize * 0.01;\n\nif (tags.debug) {\n    // console.log(`[${tags.system}] [@calculateLabelSize] calculation end debug output:`, { ...that, width: totalWidth, height: totalHeight, fontData});\n}\n\nreturn {\n    width: totalWidth,\n    height: totalHeight\n}","abArtifactName":"arWebSlinger"}},"0ca6ad9a-e579-40a2-8e19-39ef65c59073":{"id":"0ca6ad9a-e579-40a2-8e19-39ef65c59073","space":"shared","tags":{"form":"sphere","formOpacity":"0.5","listening":true,"onClick":"@thisBot.arWebSlingerMenuOpen();","onExitClick":"@if (configBot.tags.arEnabled) {\n    os.disableAR();\n} else if (configBot.tags.vrEnabled) {\n    os.disableVR();\n} else if (tags.devMode && masks.isXRSetup) {\n    thisBot.xrTeardown();\n}","scale":"1.5","system":"arWebSlinger.manager","abVersion":"10.6","abArtifactName":"arWebSlinger","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\n    data: {\n        managerDimension: tags.dimension,\n        managerDimensionX: tags[tags.dimension + 'X'],\n        managerDimensionY: tags[tags.dimension + 'Y'],\n        managerDimensionZ: tags[tags.dimension + 'Z'],\n    },\n    dependencies: [\n        { askID: 'arWebSlinger' }\n    ]\n}\n\nreturn shard;","onABArtifactReconstitute":"@const data = that.data;\n\nif (data.eggParameters) {\n    if (data.eggParameters.gridInformation) {\n        const dimension = data.eggParameters.gridInformation.dimension ?? 'home';\n        const dimensionX = data.eggParameters.gridInformation.position?.x ?? 0;\n        const dimensionY = data.eggParameters.gridInformation.position?.y ?? 0;\n\n        tags.dimension = dimension;\n        tags[dimension] = true;\n        tags[dimension + 'X'] = dimensionX;\n        tags[dimension + 'Y'] = dimensionY;\n    }\n}\n\nif (data.managerDimension) {\n    tags.dimension = data.managerDimension;\n    tags[data.managerDimension] = true;\n    tags[data.managerDimension + 'X'] = data.managerDimensionX;\n    tags[data.managerDimension + 'Y'] = data.managerDimensionY;\n    tags[data.managerDimension + 'Z'] = data.managerDimensionZ;\n}\n\nthisBot.refreshHex();\n\nif (data.eggParameters) {\n    thisBot.arWebSlingerMenuOpen();\n}","onABStripArtifactInstanceDataFromBotData":"@console.log(`[${tags.system}.${tagName}]`, JSON.parse(JSON.stringify(that)));\n\nconst { data } = that;\n\nconst dimension = data.tags.dimension;\n\ndelete data.tags.dimension;\ndelete data.tags[dimension];\ndelete data.tags[dimension + 'X'];\ndelete data.tags[dimension + 'Y'];\ndelete data.tags[dimension + 'Z'];","refreshHex":"@if (!links.hex) {\n    const hex = create({\n        space: 'tempLocal',\n        form: 'cylinder',\n        color: '#00D9CD',\n        anchorPoint: 'center',\n        manager: getLink(thisBot),\n        scale: 0.5,\n        scaleZ: 0.2,\n        transformer: thisBot.id,\n        pointable: false,\n        onCreate: ListenerString(() => {\n            os.addBotListener(links.manager, 'onBotChanged', (listenerThat) => {\n                const changedTags = listenerThat.tags;\n\n                if (changedTags.includes('dimension')) {\n                    links.manager.refreshHex();\n                }\n            })\n        }),\n        onAnyBotsRemoved: ListenerString(() => {\n            const { botIDs } = that;\n\n            if (botIDs.includes(tags.transformer)) {\n                destroy(thisBot);\n            }\n        })\n    })\n\n    masks.hex = getLink(hex);\n}\n\nif (links.hex.tags.dimension) {\n    // Remove hex from its previous dimension.\n    const prevDim = links.hex.tags.dimension;\n    \n    console.log(`[${tags.system}.${tagName}] removing from prevDim:`, prevDim);\n\n    links.hex.tags.dimension = null;\n    links.hex.tags[prevDim] = null;\n    links.hex.tags[prevDim + 'X'] = null;\n    links.hex.tags[prevDim + 'Y'] = null;\n    links.hex.tags[prevDim + 'Z'] = null;\n    links.hex.tags[prevDim + 'RotationX'] = null;\n    links.hex.tags[prevDim + 'RotationY'] = null;\n    links.hex.tags[prevDim + 'RotationZ'] = null;\n}\n\nif (tags.dimension) {\n    // Put hex in the current dimension.\n    const curDim = tags.dimension;\n\n    console.log(`[${tags.system}.${tagName}] adding to curDim:`, curDim);\n\n    links.hex.tags.dimension = curDim;\n    links.hex.tags[curDim] = true;\n    links.hex.tags[curDim + 'X'] = 0;\n    links.hex.tags[curDim + 'Y'] = 0;\n    links.hex.tags[curDim + 'Z'] = -0.5;\n    links.hex.tags[curDim + 'RotationX'] = 0.785398;\n    links.hex.tags[curDim + 'RotationY'] = 0;\n    links.hex.tags[curDim + 'RotationZ'] = 0;\n}","debug":"false","onEnterAR":"@configBot.tags.arEnabled = true;\nthisBot.xrSetup();","onExitAR":"@configBot.tags.arEnabled = false;\nthisBot.xrTeardown();","onGridClick":"@thisBot.arWebSlingerMenuReset();","arWebSlingerMenuOpen":"@shout('arWebSlingerMenuReset');\n\nconfigBot.masks.menuPortal = 'arWebSlingerMenu';\n\nconst device = os.device();\n\nif (device.supportsAR || device.supportsVR || tags.devMode) {\n    masks.color = null;\n    \n    if (device.supportsAR || tags.devMode) {\n        const arButton = ab.links.menu.abCreateMenuButton({\n            arWebSlingerMenu: true,\n            label: 'enter ar',\n            arWebSlingerMenuReset: `@destroy(thisBot)`,\n            onClick: `@\n                os.enableAR();\n            `\n        })\n    }\n\n    if (device.supportsVR || tags.devMode) {\n        const vrButton = ab.links.menu.abCreateMenuButton({\n            arWebSlingerMenu: true,\n            label: 'enter vr',\n            arWebSlingerMenuReset: `@destroy(thisBot)`,\n            onClick: `@\n                os.enableVR();\n            `\n        })\n    }\n\n    if (tags.devMode) {\n        if (!masks.isXRSetup) {\n            const devXRSetupButton = ab.links.menu.abCreateMenuButton({\n                arWebSlingerMenu: true,\n                label: '[dev mode] xr setup',\n                manager: getLink(thisBot),\n                arWebSlingerMenuReset: `@destroy(thisBot)`,\n                onClick: `@\n                    links.manager.xrSetup();\n                `\n            })\n        }\n    }\n} else {\n    // Device does not support WebXR.\n    ab.links.utils.abLogAndToast({ message: 'WebXR is not available on this device.'});\n    masks.color = 'red';\n}\n","arWebSlingerMenuReset":"@configBot.masks.menuPortal = null;","cursor":"pointer","onEnterVR":"@configBot.tags.vrEnabled = true;\nthisBot.xrSetup();","onExitVR":"@configBot.tags.vrEnabled = false;\nthisBot.xrTeardown();","xrSetup":"@thisBot.arWebSlingerMenuReset();\n\nconfigBot.masks.leftWristPortal = \"arWebSlinger_leftWrist\";\nconfigBot.masks.rightWristPortal = \"arWebSlinger_rightWrist\";\n\n// Need to move out of the mapPortal if we are in it.\nmasks.mapPortalBeforeAR = configBot.tags.mapPortal;\n\nif (configBot.tags.mapPortal) {\n    configBot.tags.mapPortal = null;\n\n    if (!configBot.tags.gridPortal) {\n        configBot.tags.gridPortal = masks.mapPortalBeforeAR;\n    }\n}\n\n// Make this manager bot into a exit ar/vr button. Put it in the wrist portal.\nmasks.onClick = `@thisBot.onExitClick();`;\nmasks.label = \"X\";\nmasks.form = null;\nmasks.formOpacity = 1;\nmasks.draggable = false;\nmasks.color = \"clear\";\nmasks.scaleZ = 0.1;\nmasks.labelColor = \"#FFFFFF\";\nmasks.onPointerEnter = \"@ masks.scale = 1.1;\";\nmasks.onPointerExit = \"@ masks.scale = null;\";\nmasks[tags.dimension] = false;\nmasks[configBot.masks.leftWristPortal] = true;\nmasks[configBot.masks.leftWristPortal + 'X'] = 3.2;\nmasks[configBot.masks.leftWristPortal + 'Y'] = 3;\nmasks[configBot.masks.leftWristPortal + 'Z'] = 0;\nmasks.isXRSetup = true;\n\nconst hexBot = getBot(\"transformer\", thisBot.id);\nhexBot.masks.color = \"clear\";\n\n// Create log window.\nthisBot.createLogWindow({\n    dimension: configBot.tags.leftWristPortal,\n    position: new Vector3(5.5, 1, 0),\n    // width: 5,\n    // height: 5,\n})\n\nif (tags.devMode) {\n    // Create portal bots in the current dimension for the left and right wristportals so we can easily see whats going on during dev.\n    create({\n        space: 'tempLocal',\n        form: 'portal',\n        formAddress: configBot.tags.leftWristPortal,\n        [tags.dimension]: true,\n        [tags.dimension + 'X']: -10,\n        [tags.dimension + 'Y']: 0,\n        onABWebSlingerTeardown: ListenerString(() => {\n            destroy(thisBot);\n        })\n    })\n\n    create({\n        space: 'tempLocal',\n        form: 'portal',\n        formAddress: configBot.tags.rightWristPortal,\n        [tags.dimension]: true,\n        [tags.dimension + 'X']: 10,\n        [tags.dimension + 'Y']: 0,\n        onABWebSlingerTeardown: ListenerString(() => {\n            destroy(thisBot);\n        })\n    })\n}\n\nshout('onABWebSlingerSetup', { devMode: tags.devMode });","xrTeardown":"@if (masks.mapPortalBeforeAR) {\n    configBot.tags.mapPortal = masks.mapPortalBeforeAR;\n}\n\nclearTagMasks(thisBot);\n\nconfigBot.masks.leftWristPortal = null;\nconfigBot.masks.rightWristPortal = null;\n\nconst hexBot = getBot(\"transformer\", thisBot.id);\nclearTagMasks(hexBot);\n\nshout('onABWebSlingerTeardown', { devMode: tags.devMode });","onBotAdded":"@thisBot.refreshHex();","abIDOrigin":"arWebSlinger","onDestroy":"@thisBot.arWebSlingerMenuReset();\ndestroy([links.hex, links.keyboard_controller, links.menu3dPortalBot, links.menu3dBotPool, links.fonts]);\n\nshout('onABWebSlingerDestroy');","menu3dPortalBot":"ðŸ”—151be191-7a93-40d2-b58b-523e547fd6cc","keyboard_controller":"ðŸ”—4215624c-3051-4052-bbd7-c47f2974bacf","menu3dBotPool":"ðŸ”—784f657c-d4ab-41da-acb4-2386db9b8b03","getMaterialIconURL":"@const { \n    iconName,\n    style = 'filled' // 'filled', 'outlined', 'round', 'sharp', 'two-tone'\n} = that;\n\nif (iconName === 'cube') {\n    // Hardcoded icon supported by CasualOS.\n    return 'https://cdn.jsdelivr.net/gh/casual-simulation/casualos@latest/src/aux-components/icons/Cube.svg';\n} else if (iconName === 'egg') {\n    // Hardcoded icon supported by CasualOS.\n    return 'https://cdn.jsdelivr.net/gh/casual-simulation/casualos@latest/src/aux-components/icons/Egg.svg';\n} else if (iconName === 'helix') {\n    // Hardcoded icon supported by CasualOS.\n    return 'https://cdn.jsdelivr.net/gh/casual-simulation/casualos@latest/src/aux-components/icons/Helix.svg';\n} else {\n    // Map style names to package directory names\n    const styleMap = {\n        'filled': 'filled',\n        'outlined': 'outlined',\n        'round': 'round',\n        'sharp': 'sharp',\n        'twotone': 'two-tone',\n        'two-tone': 'two-tone'\n    };\n\n    const iconStyle = styleMap[style] ?? 'filled';\n\n    // Using jsDelivr CDN for @material-design-icons/svg (auto-updated, latest icons)\n    // [SLOP] We should not use a google CDN for this but instead our own repository (casual catalog).\n    const url = `https://cdn.jsdelivr.net/npm/@material-design-icons/svg@latest/${iconStyle}/${iconName}.svg`;\n\n    return url;\n}","createLogWindow":"@const {\n    dimension,\n    position = new Vector3(0, 0, 0),\n    width = 5,\n    height = 2,\n} = that;\n\nconst logWindowBots = [];\n\nconst BASE_TAGS = {\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    dimension,\n    debug: tags.debug,\n    [dimension]: true,\n    [dimension + 'X']: 0,\n    [dimension + 'Y']: 0,\n    [dimension + 'Z']: 0,\n    onABWebSlingerTeardown: ListenerString(() => {\n        destroy(thisBot);\n    })\n}\n\nconst rootBot = create({\n    ...BASE_TAGS,\n    form: 'nothing',\n    logWindowBotType: 'root',\n    anchorPoint: 'center',\n    fonts: getLink(links.fonts),\n    [dimension + 'X']: position.x,\n    [dimension + 'Y']: position.y,\n    [dimension + 'Z']: position.z,\n    logsToShow: 3,\n    initialize: ListenerString(() => {\n        if (tags.initialized) {\n            return;\n        }\n\n        tags.initialized = true;\n\n        if (tags.debug) {\n            console.log(`[logWindow-${tags.logWindowBotType}.${tagName}] invoke`);\n        }\n\n        thisBot.update();\n    }),\n    onABConsoleLogMessageBotAdded: ListenerString(() => {\n        thisBot.update();\n    }),\n    onABConsoleLogMessageBotRemoved: ListenerString(() => {\n        thisBot.update();\n    }),\n    update: ListenerString(() => {\n        const logBots = getBots(b => b.tags.consoleLogMessageBot);\n\n        logBots.sort((a, b) => {\n            return new Date(a.tags.timestamp) > new Date(b.tags.timestamp) ? 1 : -1\n        })\n\n        const logBotsToShow = logBots.slice(-tags.logsToShow);\n\n        let label;\n\n        if (logBotsToShow.length > 0) {\n            label = '';\n\n            for (let i = 0; i < logBotsToShow.length; i++) {\n                if (i > 0) {\n                    label += '\\n\\n'\n                }\n\n                const logBot = logBotsToShow[i];\n\n                if (logBot.tags.name) {\n                    label += `${logBot.tags.name}: `;\n                }\n\n                label += `${logBot.tags.message}`\n\n            }\n\n            links.logLabelBot.tags.label = label;\n        } else {\n            label = 'no message yet';\n        }\n\n        if (tags.debug) {\n            console.log(`[logWindow-${tags.logWindowBotType}.${tagName}] label (before truncate):`, label);\n        }\n\n        const truncateParams = {\n            label,\n            fontSize: links.logLabelBot.tags.labelFontSize,\n            fontName: 'roboto',\n            wordWrap: true,\n            maxWidth: links.logLabelBot.tags.scaleX,\n            maxHeight: links.logLabelBot.tags.scaleY,\n            gutterSpaces: 0\n        }\n\n        label = links.fonts.truncateLabel(truncateParams);\n\n        if (tags.debug) {\n            console.log(`[logWindow-${tags.logWindowBotType}.${tagName}] label (after truncate):`, label);\n        }\n\n        if (links.labelSizeBox) {\n            const labelSize = fonts.calculateLabelSize({...truncateParams, label });\n            links.labelSizeBox.tags.scaleX = labelSize.width;\n            links.labelSizeBox.tags.scaleY = labelSize.height;\n            links.labelSizeBox.tags[tags.dimension + 'X'] = -tags.scaleX / 2;\n            links.labelSizeBox.tags[tags.dimension + 'Y'] = tags[tags.dimension + 'Y'];\n        }\n\n        links.logLabelBot.tags.label = label;\n    })\n})\nlogWindowBots.push(rootBot);\n\nconst WINDOW_WIDTH = width;\nconst WINDOW_HEIGHT = height;\nconst WINDOW_DEPTH = 0.1;\n\nconst windowBot = create({\n    ...BASE_TAGS,\n    form: 'cube',\n    logWindowBotType: 'window',\n    // color: ab.links.personality.tags.abBaseMenuColor,\n    color: 'black',\n    formOpacity: 0.6,\n    transformer: rootBot.id,\n    [dimension + 'X']: 0,\n    [dimension + 'Y']: 0,\n    [dimension + 'Z']: 0,\n    scaleX: WINDOW_WIDTH,\n    scaleY: WINDOW_HEIGHT,\n    scaleZ: WINDOW_DEPTH\n})\nlogWindowBots.push(windowBot);\nrootBot.tags.windowBot = getLink(windowBot);\n\nconst LABEL_LEFT_MARGIN = 0.1;\nconst LABEL_RIGHT_MARGIN = 0.1;\nconst LABEL_TOP_MARGIN = 0.1;\nconst LABEL_BOTTOM_MARGIN = 0.1;\nconst LABEL_WIDTH = WINDOW_WIDTH - LABEL_LEFT_MARGIN - LABEL_RIGHT_MARGIN;\nconst LABEL_HEIGHT = WINDOW_HEIGHT - LABEL_TOP_MARGIN - LABEL_BOTTOM_MARGIN;\n\nconst logLabelBot = create({\n    ...BASE_TAGS,\n    logWindowBotType: 'log_label',\n    transformer: rootBot.id,\n    color: 'clear',\n    // color: 'red',\n    label: '',\n    labelColor: 'white',\n    scaleX: LABEL_WIDTH,\n    scaleY: LABEL_HEIGHT,\n    scaleZ: 0,\n    labelFontSize: 0.5,\n    labelAlignment: 'left',\n    labelWordWrapMode: 'breakWords',\n    [dimension + 'Z']: WINDOW_DEPTH,\n})\nlogWindowBots.push(logLabelBot);\nrootBot.tags.logLabelBot = getLink(logLabelBot);\n\n// Give root bot links to all the bots of this log window.\nrootBot.links.logWindowBots = getLink(logWindowBots);\n\nrootBot.initialize();\n\nreturn rootBot;","devMode":"false","fonts":"ðŸ”—0767548a-0c95-4f01-bf39-f72fb1ba386c"}},"151be191-7a93-40d2-b58b-523e547fd6cc":{"id":"151be191-7a93-40d2-b58b-523e547fd6cc","space":"shared","tags":{"system":"arWebSlinger.menu3dPortalBot","onPortalChanged":"@if (!masks.initialized) {\n    return;\n}\n\nconst { portal, dimension } = that;\n\nif (portal === 'menuPortal') {\n    if (masks.showingMenuPortal !== dimension) {\n        masks.showingMenuPortal = dimension;\n        \n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] going to refresh menu 3d portal because menu portal dimension was changed: ${dimension}`);\n        }\n\n        thisBot.refreshPortal();\n    }\n}","form":"portal","formAddress":"arWebSlinger_menu3d","onAnyBotsAdded":"@if (!masks.initialized) {\n    return;\n}\n\nif (!configBot) {\n    return;\n}\n\nconst menuPortal = configBot.tags.menuPortal;\n\nif (menuPortal) {\n    // Add bots that are in the current menu portal to the web slinger's 3d menu.\n    let needRefreshPortal = false;\n\n    for (let i = 0; i < that.bots.length; i++) {\n        const bot = that.bots[i];\n\n        if (bot) {\n            if (bot.tags[menuPortal] == true) {\n                needRefreshPortal = true;\n                break;\n            }\n        }\n    }\n\n    if (needRefreshPortal) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] going to refresh menu 3d portal because new bots were added to the menu portal.`);\n        }\n        \n        thisBot.refreshPortal();\n    }\n}\n","manager":"ðŸ”—0ca6ad9a-e579-40a2-8e19-39ef65c59073","abArtifactName":"arWebSlinger","onABInitialized":"@thisBot.initialize();","debug":"false","home":"false","refreshPortal":"@if (!masks.initialized) {\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] invoke`);\n}\n\nconst runId = uuid();\nthisBot.vars.currentRunId = runId;\n\nawait os.sleep(0);\n\nif (runId !== thisBot.vars.currentRunId) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] ignore call because a newer one has occured.`);\n    }\n\n    return;\n}\n\nconst menu3dDimension = tags.formAddress;\n\nif (!links.menu3dParentBot) {\n    const menu3dParentBot = create({\n        space: 'tempLocal',\n        form: 'nothing',\n        scale: 0.5,\n        anchorPoint: 'center',\n        dimension: menu3dDimension,\n        [menu3dDimension]: true,\n        [menu3dDimension + 'X']: 0,\n        [menu3dDimension + 'Y']: 0,\n    })\n\n    masks.menu3dParentBot = getLink(menu3dParentBot);\n}\n\n// [SLOP] This is lazy - we dont need to release menu 3d bots to the pool if they still exist in the menu portal.\nconst existingMenu3dBots = getBots(b => b.tags.menu3dBotType === 'root');\nfor (const menu3dBot of existingMenu3dBots) {\n    links.menu3dBotPool.release(menu3dBot);\n}\n\nconst menuPortal = configBot.tags.menuPortal;\n\n// Store what menu portal we are currently showing.\nmasks.showingMenuPortal = menuPortal;\n\nif (menuPortal) {\n    const menuBots = getBots((b) => {\n        return b.tags[menuPortal] === true\n    })\n\n    if (tags.debug) {\n        const menuBotCreateTimes = menuBots.map((b) => {\n            return { label: b.tags.label, abCreateTime: b.tags.abCreateTime }\n        })\n\n        console.log(`[${tags.system}.${tagName}] menuBotCreateTimes:`, menuBotCreateTimes);\n    }\n\n    // Sort bots to be in the same order that they appear in the menu portal.\n    menuBots.sort((a, b) => {\n        const aSortOrder = a.tags[menuPortal + 'SortOrder'] ?? 0;\n        const bSortOrder = b.tags[menuPortal + 'SortOrder'] ?? 0;\n\n        if (aSortOrder == bSortOrder) {\n            const aCreateTime = a.tags.abCreateTime ?? 0;\n            const bCreateTime = b.tags.abCreateTime ?? 0;\n\n            // If a and b have the same sort order, then sort by creation time.\n            return aCreateTime - bCreateTime;\n        } else {\n            return aSortOrder - bSortOrder;\n        }\n    });\n\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] ${menuBots.length} bots found in menu portal '${menuPortal}':`, menuBots);\n    }\n\n    if (menuBots.length > 0) {\n        menuBots.reverse();\n\n        for (let i = 0; i < menuBots.length; i++) {\n            const menuBot = menuBots[i];\n            const menu3dBot = links.menu3dBotPool.retrieve();\n            menu3dBot.configure({ menuBot, dimension: menu3dDimension });\n\n            // Parent each menu3dBot to the menu3dParentBot.\n            menu3dBot.tags.transformer = links.menu3dParentBot.id;\n            \n            menu3dBot.tags[menu3dDimension + 'Y'] = i * (links.menu3dBotPool.tags.menu3dBot_height + tags.menu3d_botSpacing)\n\n        }\n    }\n} else {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] No menu portal is open.`);\n    }\n}","menu3d_botSpacing":"0.2","onABArtifactReconstitute":"@thisBot.initialize();","initialize":"@if (masks.initialized) {\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] invoke`);\n}\n\nmasks.initialized = true;\n\nawait links.menu3dBotPool.initialize();\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] going to refresh menu 3d portal because the menu 3d portal has been initialized.`);\n}\n\nthisBot.refreshPortal();","onEggHatch":"@thisBot.initialize();","abIDOrigin":"arWebSlinger","menu3dBotProperties":"ðŸ§¬{\n    \"hello\": \"world!\"\n\n}","inWristPortal":"@const leftWristPortal = configBot.tags.leftWristPortal;\nconst rightWristPortal = configBot.tags.rightWristPortal;\n\nif (leftWristPortal && tags[leftWristPortal] === true) {\n    return true;\n} else if (rightWristPortal && tags[rightWristPortal]) {\n    return true;\n}\n\nreturn false;","onDestroy":"@destroy(links.menu3dParentBot);","onAnyKeyboardFocus":"@// [SLOP] Show keyboard in menu 3d portal.\nconst dimension = tags.formAddress;\n\nconst keyboardBot = links.keyboard_controller.show({\n    dimension,\n    position: new Vector3(0, -1.5, 0),\n    scale: 5,\n})","onAnyKeyboardBlur":"@// [SLOP] always hide keyboard when blur happens.\nlinks.keyboard_controller.hide();","keyboard_controller":"ðŸ”—4215624c-3051-4052-bbd7-c47f2974bacf","menu3dBotPool":"ðŸ”—784f657c-d4ab-41da-acb4-2386db9b8b03","onAnyBotsChanged":"@if (!masks.initialized) {\n    return;\n}\n\nif (!configBot) {\n    return;\n}\n\nconst menuPortal = configBot.tags.menuPortal;\n\nif (menuPortal) {\n    let needRefreshPortal = false;\n\n    for (let entry of that) {\n        if (entry.tags.includes(menuPortal)) {\n            needRefreshPortal = true;\n            break;\n        }\n    }\n\n    if (needRefreshPortal) {\n        if (tags.debug) {\n            console.log(`[${tags.system}.${tagName}] going to refresh menu 3d portal because bots entered/exited the menu portal.`);\n        }\n        \n        thisBot.refreshPortal();\n    }\n}","onABWebSlingerSetup":"@const { devMode } = that ?? {};\n\n// Put the menu3d portal bot in the left wrist portal.\nmasks[configBot.masks.leftWristPortal] = true;\nmasks[configBot.masks.leftWristPortal + 'X'] = 0;\nmasks[configBot.masks.leftWristPortal + 'Y'] = 0;\nmasks[configBot.masks.leftWristPortal + 'Z'] = 0;","onABWebSlingerTeardown":"@const { devMode } = that ?? {};\n\n// Remove the menu3d portal bot from the left wrist portal.\nmasks[configBot.masks.leftWristPortal] = null;\nmasks[configBot.masks.leftWristPortal + 'X'] = null;\nmasks[configBot.masks.leftWristPortal + 'Y'] = null;\nmasks[configBot.masks.leftWristPortal + 'Z'] = null;"}},"4215624c-3051-4052-bbd7-c47f2974bacf":{"id":"4215624c-3051-4052-bbd7-c47f2974bacf","space":"shared","tags":{"system":"arWebSlinger.keyboard_controller","abArtifactName":"arWebSlinger","show":"@const {\n    dimension = configBot.tags.gridPortal ?? 'home',\n    position = new Vector3(0, 0, 0),\n    scale = 1,\n} = that ?? {};\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nif (!links.keyboardBot) {\n    const keyboardBot = create({\n        space: 'tempLocal',\n        form: 'keyboard',\n        anchorPoint: 'center',\n        controller: getLink(thisBot),\n        draggable: false,\n        onKeyClick: ListenerString(() => {\n            links.controller.keyClick(that);\n        })\n    })\n\n    masks.keyboardBot = getLink(keyboardBot);\n}\n\nlinks.keyboardBot.tags.dimension = dimension;\nlinks.keyboardBot.tags[dimension] = true;\nlinks.keyboardBot.tags[dimension + 'X'] = position.x;\nlinks.keyboardBot.tags[dimension + 'Y'] = position.y;\nlinks.keyboardBot.tags[dimension + 'Z'] = position.z;\nlinks.keyboardBot.tags.scaleX = scale;\nlinks.keyboardBot.tags.scaleY = scale;\n\nreturn links.keyboardBot;","blur":"@if (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] invoke`);\n}\n\n\nwhisper(links.targetBot, 'onKeyboardBlur');\nshout('onAnyKeyboardBlur', { targetBot: links.targetBot });\n\nmasks.targetBot = null;\nmasks.targetBotId = null;","focus":"@const { targetBot } = that;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nassert(targetBot && targetBot.id && targetBot.tags, `[${tags.system}.${tagName}] targetBot is a required Bot parameter.`);\n\nmasks.targetBot = getLink(targetBot);\nmasks.targetBotId = targetBot.id;\n\nwhisper(links.targetBot, 'onKeyboardFocus');\nshout('onAnyKeyboardFocus', { targetBot });\n","hide":"@if (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] invoke`);\n}\n\nif (links.keyboardBot) {\n    destroy(links.keyboardBot);\n    thisBot.blur();\n}","keyClick":"@const { key, physical } = that;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] that:`, that);\n}\n\nif (links.targetBot) {\n    whisper(links.targetBot, 'onKeyboardClick', { key });\n}\n\nif (!physical) {\n    ab.links.sound.abPlaySound({ value: tags.keyboardClickSound })\n}\n\nshout('onAnyKeyboardClick', { key, targetBot: links.targetBot });","debug":"false","onKeyDown":"@if (!links.targetBot) {\n    // Ignore physical keyboard keystrokes if we do not have a target bot.\n    return;\n}\n\nconst { keys } = that;\n\nfor (let key of keys) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] physical keyboard key down:`, key);\n    }\n    \n    thisBot.keyClick({ key, physical: true });\n}","onKeyRepeat":"@// Just forward the repeat key event to our onKeyDown handler.\nthisBot.onKeyDown(that);","onAnyBotClicked":"@const { bot } = that;\n\nif (links.targetBot) {\n    if (bot !== links.targetBot && bot !== links.keyboardBot) {\n        thisBot.blur();\n    }\n}","abIDOrigin":"arWebSlinger","onGridClick":"@thisBot.blur();","onAnyBotsRemoved":"@const { botIDs } = that;\n\nif (masks.targetBotId) {\n    if (botIDs.includes(masks.targetBotId)) {\n        // Hide keyboard if target bot gets destroyed.\n        thisBot.hide();\n    }\n}","keyboardClickSound":"ðŸ§¬[\n    \"ab/audio/keyboard_01.mp3\",\n    \"ab/audio/keyboard_02.mp3\",\n    \"ab/audio/keyboard_03.mp3\",\n    \"ab/audio/keyboard_04.mp3\",\n    \"ab/audio/keyboard_05.mp3\"\n]"}},"784f657c-d4ab-41da-acb4-2386db9b8b03":{"id":"784f657c-d4ab-41da-acb4-2386db9b8b03","space":"shared","tags":{"system":"arWebSlinger.menu3dBotPool","abArtifactName":"arWebSlinger","initialize":"@if (masks.initialized) {\n    return;\n}\n\n// Initialize the pool.\nthisBot.vars.pool = [];\n\nmasks.initialized = true;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] invoke`);\n}\n\nfor (let i = 0; i < tags.startSize; i++) {\n    const menu3dBot = thisBot.retrieve();\n    thisBot.release(menu3dBot);\n}\n","startSize":"10","debug":"false","retrieve":"@if (!masks.initialized) {\n    return;\n}\n\nlet menu3dBot;\n\nif (thisBot.vars.pool && thisBot.vars.pool.length > 0) {\n    menu3dBot = thisBot.vars.pool.pop();\n\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] retrieved from pool (${thisBot.vars.pool.length}):`, menu3dBot);\n    }\n} else {\n    menu3dBot = thisBot._newMenu3dBot();\n\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] pool is empty, created new:`, menu3dBot);\n    }\n}\n\nwhisper(menu3dBot, 'onRetrievedFromPool');\nreturn menu3dBot;","release":"@if (!masks.initialized) {\n    return;\n}\n\nconst menu3dBot = that;\n\nassert(menu3dBot && menu3dBot.id && menu3dBot.tags, `[${tags.system}.${tagName}] must be given a Bot`);\n\nif (!menu3dBot.tags.inPool) {\n    whisper(menu3dBot, 'onReleasedToPool');\n\n    thisBot.vars.pool.push(menu3dBot);\n\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] released to pool (${thisBot.vars.pool.length}):`, menu3dBot);\n    }\n} else {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] already in pool:`, menu3dBot);\n    }\n}\n","_newMenu3dBot":"@const menu3dBots = [];\n\nconst MENU3DBOT_BASE_TAGS = {\n    space: 'tempLocal',\n    manager: getLink(links.manager),\n    menu3dBotPool: getLink(thisBot),\n    menu3dPortalBot: tags.menu3dPortalBot,\n    keyboard_controller: getLink(links.manager.links.keyboard_controller),\n    debug: tags.debug,\n    draggable: false,\n    pointable: false,\n}\n\nconst menu3dRootBot = create({\n    ...MENU3DBOT_BASE_TAGS,\n    menu3dBotType: 'root',\n    form: 'nothing',\n    anchorPoint: 'center',\n    onRetrievedFromPool: ListenerString(() => {\n        tags.inPool = false;\n    }),\n    configure: ListenerString(() => {\n        const { menuBot, dimension } = that;\n\n        if (tags.debug) {\n            console.log(`[menu3dRootBot.${tagName}] that:`, that);\n        }\n\n        tags.menuBot = getLink(menuBot);\n        tags.dimension = dimension;\n        tags[dimension] = true;\n        tags[dimension + 'X'] = 0;\n        tags[dimension + 'Y'] = 0;\n        tags[dimension + 'Z'] = 0;\n\n        thisBot.vars.onMenuBotChanged = (listenerThat) => {\n            if (tags.debug) {\n                console.log(`[menu3dRootBot.onMenuBotChanged] changed tags:`, listenerThat.tags);\n            }\n\n            thisBot.resyncMenuBot();\n        }\n\n        thisBot.vars.onMenuBotDestroyed = () => {\n            if (tags.debug) {\n                console.log(`[${tags.system}.onMenuBotDestroyed] menu bot was just destroyed, destroy menu 3d bot.`);\n            }\n\n            // [SLOP] Do a full refresh of the menu 3d portal.\n            if (tags.debug) {\n                console.log(`[${tags.system}.${tagName}] going to refresh menu 3d portal because a menu bot was destroyed.`);\n            }\n\n            if (links.menu3dPortalBot) {\n                links.menu3dPortalBot.refreshPortal();\n            }\n        }\n\n        os.addBotListener(links.menuBot, 'onBotChanged', thisBot.vars.onMenuBotChanged);\n        os.addBotListener(links.menuBot, 'onDestroy', thisBot.vars.onMenuBotDestroyed);\n\n        // Adjust some settings for dropdown option buttons.\n        if (menuBot.tags.abDropdownOption) {\n            tags[dimension + 'X'] = 0.5;\n        } else {\n            tags[dimension + 'X'] = 0;\n        }\n\n        const otherMenu3dBots = links.menu3dBots.filter(b => b !== thisBot);\n\n        // Set up some parameters to be the same across all other related bots.\n        for (const bot of otherMenu3dBots) {\n            bot.tags.menuBot = getLink(menuBot);\n            bot.tags.dimension = dimension;\n            bot.tags[dimension] = true;\n            bot.tags[dimension + 'X'] = 0;\n            bot.tags[dimension + 'Y'] = 0;\n            bot.tags[dimension + 'Z'] = 0;\n        }\n\n        whisper(otherMenu3dBots, 'onConfigure', that);\n\n        thisBot.resyncMenuBot();\n    }),\n    onReleasedToPool: ListenerString(() => {\n        if (tags.debug) {\n            console.log(`[menu3dRootBot.${tagName}] invoke`);\n        }\n\n        tags.inPool = true;\n\n        const dimension = tags.dimension;\n\n        if (dimension) {\n            tags.dimension = null;\n            tags[dimension] = null;\n            tags[dimension + 'X'] = null;\n            tags[dimension + 'Y'] = null;\n            tags[dimension + 'Z'] = null;\n        }\n\n        if (links.menuBot) {\n            os.removeBotListener(links.menuBot, 'onBotChanged', thisBot.vars.onMenuBotChanged);\n            os.removeBotListener(links.menuBot, 'onDestroy', thisBot.vars.onMenuBotDestroyed);\n        }\n        \n        tags.menuBot = null;\n\n        if (links.menu3dBots) {\n            const otherMenu3dBots = links.menu3dBots.filter(b => b !== thisBot);\n\n            // Reset some parameters across all other related bots.\n            for (const bot of otherMenu3dBots) {\n                bot.tags.menuBot = null;\n\n                if (dimension) {\n                    bot.tags.dimension = null;\n                    bot.tags[dimension] = null;\n                    bot.tags[dimension + 'X'] = null;\n                    bot.tags[dimension + 'Y'] = null;\n                    bot.tags[dimension + 'Z'] = null;\n                }\n            }\n\n            whisper(otherMenu3dBots, 'onReleasedToPool');\n        }\n    }),\n    resyncMenuBot: ListenerString(() => {\n        const menuBot = links.menuBot;\n\n        if (!menuBot) {\n            if (tags.debug) {\n                console.log(`[menu3dRootBot.${tagName}] menu bot is no longer around, releasing back to pool.`);\n            }\n\n            links.menu3dBotPool.release(thisBot);\n            return;\n        }\n        \n        if (tags.debug) {\n            console.log(`[menu3dRootBot.onMenuBotChanged] resync menu bot.`);\n        }\n\n        whisper(links.menu3dBots, 'onResyncMenuBot');\n    }),\n    onDestroy: ListenerString(() => {\n        if (tags.debug) {\n            console.log(`[menu3dRootBot.${tagName}] invoke`);\n        }\n    })\n})\n\n// Every menu 3d bot after this point gets a link to the root bot.\nMENU3DBOT_BASE_TAGS.menu3dRootBot = getLink(menu3dRootBot);\n\n// Every menu 3d bot after this point is parented to the root bot.\nMENU3DBOT_BASE_TAGS.transformer = menu3dRootBot.id;\n\nconst menu3dShapeBot = create({\n    ...MENU3DBOT_BASE_TAGS,\n    menu3dBotType: 'shape',\n    form: 'cube',\n    pointable: true,\n    scaleX: tags.menu3dBot_width,\n    scaleY: tags.menu3dBot_height,\n    scaleZ: tags.menu3dBot_depth,\n    onClick: ListenerString(() => {\n        if (links.menuBot.tags.form === 'input') {\n            // Focus this bot for keyboard input.\n            links.keyboard_controller.focus({ targetBot: thisBot })\n        } else {\n            whisper(links.menuBot, 'onClick', that);\n        }\n    }),\n    onPointerEnter: ListenerString(() => {\n        tags.hover = true;\n    }),\n    onPointerExit: ListenerString(() => {\n        tags.hover = false;\n    }),\n    onPointerDown: ListenerString(() => {\n        tags.down = true;\n    }),\n    onPointerUp: ListenerString(() => {\n        tags.down = false;\n    }),\n    onKeyboardFocus: ListenerString(() => {\n        masks.strokeColor = 'white';\n        masks.strokeWidth = 5;\n    }),\n    onKeyboardBlur: ListenerString(() => {\n        masks.strokeColor = null;\n        masks.strokeWidth = null;\n    }),\n    onReleasedToPool: ListenerString(() => {\n        masks.strokeColor = null;\n        masks.strokeWidth = null;\n    }),\n    onKeyboardClick: ListenerString(() => {\n        const { key } = that;\n\n        if (key === 'Enter') {\n            // [SLOP] Treat enter as submit for 3d menu inputs.\n            if (links.menuBot.tags.menuItemText) {\n                whisper(links.menuBot, 'onSubmit', { text: links.menuBot.tags.menuItemText });\n            }\n        } else {\n            if (tags.debug) {\n                console.log(`[menu3dShapeBot.${tagName}] that:`, that);\n            }\n\n            links.menuBot.tags.menuItemText = ab.links.utils.applyKeyToText({ key, text: links.menuBot.tags.menuItemText });\n\n            whisper(links.menuBot, 'onInputTyping', { text: links.menuBot.tags.menuItemText });\n        }\n\n    }),\n    refreshPointerState: ListenerString(async () => {\n        if (tags.hover) {\n            if (tags.down) {\n                masks.color = await ab.links.utils.adjustBrightness({ color: tags.baseColor, factor: 0.9 });\n            } else {\n                masks.color = await ab.links.utils.adjustBrightness({ color: tags.baseColor, factor: 1.1 });\n            }\n        } else {\n            masks.color = null;\n        }\n    }),\n    onBotChanged: ListenerString(() => {\n        let baseColorChanged = false;\n        let hoverChanged = false;\n        let downChanged = false;\n\n        for (let tag of that.tags) {\n            if (tag === 'hover') {\n                hoverChanged = true;\n            } else if (tag === 'down') {\n                downChanged = true;\n            } else if (tag === 'baseColor') {\n                baseColorChanged = true;\n            }\n        }\n\n        if (hoverChanged || downChanged || baseColorChanged) {\n            thisBot.refreshPointerState();\n        }\n    }),\n    onResyncMenuBot: ListenerString(() => {\n        let cursor;\n        if (links.menuBot.tags.form === 'input') {\n            cursor = 'text';\n        } else {\n            if (links.menuBot.tags.onClick) {\n                cursor = 'pointer';\n            }\n        }\n\n        if (tags.cursor !== cursor) {\n            tags.cursor = cursor;\n        }\n\n        if (tags.color !== links.menuBot.tags.color) {\n            tags.baseColor = links.menuBot.tags.color;\n            tags.color = links.menuBot.tags.color;\n        }\n\n        if (tags.soundClick !== links.menuBot.tags.soundClick) {\n            tags.soundClick = links.menuBot.tags.soundClick;\n        }\n    })\n});\n\nmenu3dBots.push(menu3dShapeBot);\nmenu3dRootBot.tags.menu3dShapeBot = getLink(menu3dShapeBot);\n\nconst menu3dLabelBot = create({\n    ...MENU3DBOT_BASE_TAGS,\n    menu3dBotType: 'label',\n    color: 'clear',\n    // color: 'red',\n    pointable: false,\n    label: '',\n    scaleZ: 0,\n    labelFontSize: 1,\n    labelAlignment: 'left',\n    labelWordWrapMode: 'breakWords',\n    onResyncMenuBot: ListenerString(() => {\n        const inXR = configBot.tags.arEnabled || configBot.tags.vrEnabled;\n\n        // Label size\n        let labelWidth;\n        let labelX;\n        let labelZ = inXR ? 0 : links.menu3dBotPool.tags.menu3dBot_depth;\n\n        if (links.menuBot.tags.menuItemText) {\n            // Submit button should be enabled.\n            labelWidth = links.menu3dBotPool.tags.menu3dBot_width - (links.menu3dBotPool.tags.menu3dBot_iconWidth * 2);\n            labelX = 0;\n        } else {\n            // No submit button.\n            labelWidth = links.menu3dBotPool.tags.menu3dBot_width - links.menu3dBotPool.tags.menu3dBot_iconWidth;\n            labelX = links.menu3dBotPool.tags.menu3dBot_iconWidth / 2;\n        }\n\n        if (tags.scaleX !== labelWidth) {\n            tags.scaleX = labelWidth;\n        }\n        \n        if (tags[tags.dimension + 'X'] !== labelX) {\n            tags[tags.dimension + 'X'] = labelX;\n        }\n\n        if (tags[tags.dimension + 'Z'] !== labelZ) {\n            tags[tags.dimension + 'Z'] = labelZ;\n        }\n\n        // Label text\n        let labelText;\n\n        if (links.menuBot.tags.form === 'input') {\n            if (links.menuBot.tags.menuItemText) {\n                labelText = links.menuBot.tags.menuItemText;\n            } else {\n                labelText = links.menuBot.tags.label;\n            }\n        } else {\n            labelText = links.menuBot.tags.label;\n        }\n\n        if (tags.label !== labelText) {\n            tags.label = labelText;\n        }\n    })\n})\n\nmenu3dBots.push(menu3dLabelBot);\nmenu3dRootBot.tags.menu3dLabelBot = getLink(menu3dLabelBot);\n\nconst ICON_X = -(tags.menu3dBot_width / 2) + (tags.menu3dBot_iconWidth / 2);\n\nconst menu3dIconBot = create({\n    ...MENU3DBOT_BASE_TAGS,\n    menu3dBotType: 'icon',\n    form: 'nothing',\n    pointable: false,\n    scaleX: tags.menu3dBot_iconSize,\n    scaleY: tags.menu3dBot_iconSize,\n    scaleZ: 0.1,\n    iconX: ICON_X,\n    iconZ: tags.menu3dBot_depth,\n    onResyncMenuBot: ListenerString(async () => {\n        await os.sleep(0);\n        if (tags.icon !== links.menuBot.tags.formAddress) {\n            tags.icon = links.menuBot.tags.formAddress;\n\n            if (tags.icon) {\n                tags.form = 'sprite';\n\n                if (tags.icon.startsWith('https://')) {\n                    tags.formAddress = tags.icon;\n                } else  {\n                    const iconUrl = links.manager.getMaterialIconURL({ iconName: tags.icon });\n                    tags.formAddress = iconUrl;\n                }\n            } else {\n                tags.form = 'nothing';\n            }\n        }\n\n        if (tags[tags.dimension + 'X'] !== tags.iconX){\n            tags[tags.dimension + 'X'] = tags.iconX;\n        }\n\n        if (tags[tags.dimension + 'Z'] !== tags.iconZ){\n            tags[tags.dimension + 'Z'] = tags.iconZ;\n        }\n    }),\n})\n\nmenu3dBots.push(menu3dIconBot);\nmenu3dRootBot.tags.menu3dIconBot = getLink(menu3dIconBot);\n\nconst SUBMIT_X = (tags.menu3dBot_width / 2) - (tags.menu3dBot_iconWidth / 2);\n\nconst menu3dSubmitBot = create({\n    ...MENU3DBOT_BASE_TAGS,\n    menu3dBotType: 'submit',\n    pointable: true,\n    formAddress: links.manager.getMaterialIconURL({ iconName: 'send' }),\n    scaleX: tags.menu3dBot_iconSize,\n    scaleY: tags.menu3dBot_iconSize,\n    scaleZ: 0.1,\n    cursor: 'pointer',\n    submitX: SUBMIT_X,\n    submitZ: tags.menu3dBot_depth,\n    onClick: ListenerString(() => {\n        if (links.menuBot.tags.menuItemText) {\n            whisper(links.menuBot, 'onSubmit', { text: links.menuBot.tags.menuItemText });\n        }\n    }),\n    onResyncMenuBot: ListenerString(() => {\n        // Show/Hide submit button based on if there is text inputted.\n        let form = links.menuBot.tags.menuItemText ? 'sprite' : 'nothing';\n        if (tags.form !== form) {\n            tags.form = form;\n        }\n\n        if (tags[tags.dimension + 'X'] !== tags.submitX) {\n            tags[tags.dimension + 'X'] = tags.submitX\n        }\n        \n        if (tags[tags.dimension + 'Z'] !== tags.submitZ) {\n            tags[tags.dimension + 'Z'] = tags.submitZ\n        }\n    }),\n})\n\nmenu3dBots.push(menu3dSubmitBot);\nmenu3dRootBot.tags.menu3dSubmitBot = getLink(menu3dSubmitBot);\n\nmenu3dRootBot.masks.menu3dBots = getLink(menu3dBots);\n\nreturn menu3dRootBot;","menu3dBot_depth":"0.3","menu3dBot_height":"1","menu3dBot_iconSize":"0.5","menu3dBot_iconWidth":"1","menu3dBot_width":"8","manager":"ðŸ”—0ca6ad9a-e579-40a2-8e19-39ef65c59073","menu3dPortalBot":"ðŸ”—151be191-7a93-40d2-b58b-523e547fd6cc","abIDOrigin":"arWebSlinger"}}}}