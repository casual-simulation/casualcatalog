{"version":1,"state":{"13f5e816-1484-4924-9709-0a16d760455e":{"id":"13f5e816-1484-4924-9709-0a16d760455e","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeX":-2,"homeY":-7,"labelColor":"#1A1A1A","labelFontSize":"0.75","system":"msPuzzleExplorer.enemyLeftRightSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"enemyLeftRight\",\r\n    \"passable\": true,\r\n    \"harmful\": true,\r\n    \"moveLeftRight\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -2,\r\n        \"y\": -7\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/0e65b4f8d8a11877d23df386a08a6f900e1930c06aa108714049998b70860753.png","form":"sprite","scaleZ":"0.01","homeZ":0}},"173f2c36-5507-4479-8e37-7bce471c609f":{"id":"173f2c36-5507-4479-8e37-7bce471c609f","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeZ":0,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.keySpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"key\",\r\n    \"passable\": true,\r\n    \"key\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -2,\r\n        \"y\": -6\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/6431e8f857813d4f6ff2391eacf5ddd18cf98dcc702f3996a764c3476247915e.png","form":"sprite","scaleZ":"0.01","homeY":-6,"homeX":-2}},"196a148b-d4c8-481d-9535-164e08f0b51f":{"id":"196a148b-d4c8-481d-9535-164e08f0b51f","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":"false","labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.playerSpawnPoint","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"spawnPoint\",\r\n    \"passable\": true,\r\n    \"playerSpawnpoint\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -6,\r\n        \"y\": 4\r\n    },\r\n    \"maxCopies\": 1,\r\n    \"maxCopiesMessage\": \"There can only be 1 player at a time.\"\r\n}","puzzleExplorer":"true","abVersion":"10.10","scaleZ":"0.01","homeX":-6,"homeY":4,"formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeStartTile/6da7cbe043f4275f2965aa84c0b11d5d1bd9b0cb9104ef39b057dfe4c37ecc9e.png","form":"sprite","homeZ":0}},"295abc49-46d5-4874-acbf-4dc951d5771f":{"id":"295abc49-46d5-4874-acbf-4dc951d5771f","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abArtifactDependencies":"ðŸ§¬[\r\n    { \"abID\": \"msPuzzleExplorer\", \"recordKey\": \"f2723462-4a17-45cf-bd12-1a9a7438f377\" }\r\n]","abArtifactName":"msPuzzleExplorer","abIDOrigin":"puzzleExplorer","goal":"ðŸ”—389e9699-18ac-47e4-b1e4-d1b92ee31fc9","ground":"ðŸ”—58db4c40-1472-4a01-b95d-50c643dec038","onABArtifactReconstitute":"@const { abArtifactName, abArtifactData } = that;\r\n\r\nif (abArtifactName !== tags.abArtifactName) {\r\n    // This reconstitute shout is not for us.\r\n    return;\r\n}\r\n\r\nlinks.player ? null : tags.player = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.playerSpawn\")));\r\nlinks.goal ? null : tags.goal = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.goalSpawn\")));\r\nlinks.wall ? null : tags.wall = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.wallSpawn\")));\r\nlinks.ground ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.groundSpawn\")));\r\nlinks.key ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.keySpawn\")));\r\nlinks.lock ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.lockSpawn\")));\r\nlinks.controller ? null : tags.controller = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.controller\")));\r\n\r\nif(abArtifactData.tileSet){\r\n    let botLinks = [];\r\n\r\n    if(abArtifactData.tileSet.player != null){\r\n        setTag(links.player, \"formAddress\", abArtifactData.tileSet.player);\r\n        botLinks.push(links.player);\r\n    }\r\n    if(abArtifactData.tileSet.goal != null){\r\n        setTag(links.goal, \"formAddress\", abArtifactData.tileSet.goal);\r\n        botLinks.push(links.goal);\r\n    }\r\n    if(abArtifactData.tileSet.wall != null){\r\n        setTag(links.wall, \"formAddress\", abArtifactData.tileSet.wall);\r\n        botLinks.push(links.wall);\r\n    }\r\n    if(abArtifactData.tileSet.ground != null){\r\n        setTag(links.ground, \"formAddress\", abArtifactData.tileSet.ground);\r\n        botLinks.push(links.ground)\r\n    }\r\n    if(abArtifactData.tileSet.key != null){\r\n        setTag(links.key, \"formAddress\", abArtifactData.tileSet.key);\r\n        botLinks.push(links.key)\r\n    }\r\n    if(abArtifactData.tileSet.lock != null){\r\n        setTag(links.lock, \"formAddress\", abArtifactData.tileSet.lock);\r\n        botLinks.push(links.lock)\r\n    }\r\n\r\n    setTag(botLinks, \"color\", null);\r\n    setTag(botLinks, \"label\", null);\r\n}\r\n\r\nif (abArtifactData.tiles) {\r\n    for (const tile of abArtifactData.tiles) {\r\n        let whisperObject = {\r\n            \"bot\": links[tile.tileType],\r\n            \"to\": {\r\n                \"x\": tile.tilePosition.x,\r\n                \"y\": tile.tilePosition.y\r\n            },\r\n            \"from\": {\r\n                \"x\": getTag(links[tile.tileType], \"homeX\"),\r\n                \"y\": getTag(links[tile.tileType], \"homeY\")\r\n            },\r\n            \"extraMods\": {\r\n                \"homeRotationZ\": tile.tileRotation\r\n            }\r\n        }\r\n\r\n        whisper(links.controller, \"onAnyBotDrop\", whisperObject);\r\n    }\r\n}","onABCollectArtifactShards":"@links.player ? null : tags.player = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.playerSpawn\")));\r\nlinks.goal ? null : tags.goal = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.goalSpawn\")));\r\nlinks.wall ? null : tags.wall = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.wallSpawn\")));\r\nlinks.ground ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.groundSpawn\")));\r\nlinks.key ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.keySpawn\")));\r\nlinks.lock ? null : tags.ground = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer.lockSpawn\")));\r\n\r\nlet shards = {\r\n    tiles: [],\r\n    tileSet: {\r\n        \"player\": links.player.tags.formAddress ?? null,\r\n        \"goal\": links.goal.tags.formAddress ?? null,\r\n        \"wall\": links.wall.tags.formAddress ?? null,\r\n        \"ground\": links.ground.tags.formAddress ?? null,\r\n        \"key\": links.key.tags.formAddress ?? null,\r\n        \"lock\": links.key.tags.formAddress ?? null\r\n    }\r\n}\r\n\r\ngetBots(b => {\r\n    if(b.tags.copyType){\r\n        let masks = {\r\n            x: b.masks.homeX,\r\n            y: b.masks.homeY\r\n        }\r\n\r\n        setTagMask(b, \"homeX\", null);\r\n        setTagMask(b, \"homeY\", null);\r\n\r\n        shards.tiles.push({\r\n            tileType: b.tags.copyType,\r\n            tilePosition: {\r\n                \"x\": b.tags.homeX,\r\n                \"y\": b.tags.homeY\r\n            },\r\n            tileRotation: b.tags.homeRotationZ\r\n        })\r\n\r\n        setTagMask(b, \"homeX\", masks.x);\r\n        setTagMask(b, \"homeY\", masks.y);\r\n    }\r\n})\r\n\r\nreturn shards;","player":"ðŸ”—8af8567c-b178-4cc2-8cd9-c9bd471d4667","system":"msPuzzleExplorer._abArtifactHandler","wall":"ðŸ”—e9099258-d8dc-4db5-85b5-973a537ce825","puzzleExplorer":"true","abVersion":"10.10"}},"2d2c1112-9a63-4332-b8ae-12567dd83982":{"id":"2d2c1112-9a63-4332-b8ae-12567dd83982","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","createTagPortal":"@// console.log(\"createTagPortal that:\", that)\r\nlet { id, tag, size, space } = that \r\nif (!size) size = 'small'\r\n\r\nconfigBot.tags.tagPortalSpace = space\r\nconfigBot.tags.tagPortal = `${id}.${tag}`\r\n\r\n// Helper Function\r\nconst clamp = (num, min, max) => Math.min(Math.max(num, min), max);\r\n\r\n// Make button to close the tag portal\r\ntagPortalBot.tags.tagPortalShowButton = true\r\ntagPortalBot.tags.onClick = `@\r\n    configBot.tags.tagPortal = null;\r\n    shout(\"tptBotReset\");    \r\n`\r\ntagPortalBot.tags.tagPortalButtonIcon = \"done\"\r\n\r\nlet portalStyle = thisBot.tags[`${size}PortalStyle`]\r\n\r\n// Get size of window\r\nconst windowWidth = gridPortalBot.tags.pixelWidth\r\nconst windowHeight = gridPortalBot.tags.pixelHeight\r\n\r\n// Determine size of tag portal\r\nlet tagPortalHeight\r\nlet tagPortalWidth\r\nswitch (size) {\r\n    case 'large':\r\n    tagPortalHeight = 360\r\n        tagPortalWidth = clamp(windowWidth * 0.4, 500, 1000)\r\n        if (tagPortalWidth > windowWidth * 0.9) tagPortalWidth = windowWidth - 10\r\n        break\r\n\r\n    default:\r\n        tagPortalHeight = 210\r\n        tagPortalWidth = clamp(windowWidth * 0.2, 350, 600)\r\n}\r\n\r\n// Keep from going off top or bottom\r\n// let top = clamp(gridPortalBot.tags.pointerPixelY - tagPortalHeight, 5, windowHeight - tagPortalHeight - 5)\r\nlet verticalOffset = 50; // Move up by 50 pixels\r\nlet top = clamp(gridPortalBot.tags.pointerPixelY - tagPortalHeight - verticalOffset, 5, windowHeight - tagPortalHeight - 5)\r\n\r\n\r\n\r\n// Keep from going off left or right\r\nlet left = clamp(\r\n    gridPortalBot.tags.pointerPixelX - (tagPortalWidth / 2), // Number\r\n    5, // Min\r\n    windowWidth - tagPortalWidth - 5, // Max\r\n)\r\n\r\n// Update style object\r\nportalStyle.top  = `${ top }px`\r\nportalStyle.left = `${ left }px`\r\n\r\n// Update tag portal style\r\ntagPortalBot.tags.tagPortalStyle = `ðŸ§¬${JSON.stringify(portalStyle)}`","createTagPortalTools":"@shout(\"tptBotReset\");\r\n\r\nconst baseMods = {\r\n    space: \"tempLocal\",\r\n    tagPortalTool: true,\r\n    tptBotReset: `@ console.log(\"destroying toolPortalTool: \" + tags.tagToShow); destroy(thisBot);`,\r\n    onClick: `@\r\n        let tagPortalAddress = configBot.tags.tagPortal;\r\n        let parts = tagPortalAddress.split(\".\");\r\n        let id = parts[0];\r\n        configBot.tags.tagPortal = id + \".\" + tags.tagToShow;\r\n        configBot.tags.lastTagShown = tags.tagToShow;\r\n        shout(\"createTagPortalTools\", tags.tagToShow);\r\n    `,\r\n    onBotAdded: '@ tags.system = `tagPortalTools.${tags.tagToShow}`'\r\n}\r\n\r\nconst tagList = {\r\n    \"tileProperties\": \"Tile Properties\",\r\n    \"color\": \"Color\",\r\n    \"form\": \"Form\",\r\n    \"formAddress\": \"Form Address\",\r\n    \"label\": \"Label\"\r\n}\r\n\r\nconst tagKeys = Object.keys(tagList);\r\nconst tagPosition = tagKeys.findIndex(e => e == that);\r\n\r\nlet backEntry, forwardEntry;\r\n\r\nif (tagPosition == 0) {\r\n    backEntry = tagKeys[tagKeys.length - 1];\r\n    forwardEntry = tagKeys[tagPosition + 1];\r\n}\r\nelse if (tagPosition == tagKeys.length - 1) {\r\n    backEntry = tagKeys[tagPosition - 1];\r\n    forwardEntry = tagKeys[0];\r\n}\r\nelse {\r\n    backEntry = tagKeys[tagPosition - 1];\r\n    forwardEntry = tagKeys[tagPosition + 1];\r\n}\r\n\r\ncreate(baseMods, {\r\n    tagToShow: backEntry,\r\n    label: \"â—€ \" + tagList[backEntry] + \"\",\r\n    tagPortalToolSortOrder: 1\r\n})\r\n\r\ncreate(baseMods, {\r\n    label: \"â”ƒ\",\r\n    onClick: \"@\",\r\n    pointable: false,\r\n    tagPortalToolSortOrder: 2,\r\n})\r\n\r\ncreate(baseMods, {\r\n    tagToShow: forwardEntry,\r\n    label: \"\" + tagList[forwardEntry] + \" â–¶\",\r\n    tagPortalToolSortOrder: 3\r\n})","largePortalStyle":"ðŸ§¬{\r\n    \"top\": \"10%\",\r\n    \"left\": \"10%\",\r\n    \"width\": \"clamp(500px, 40vw, 1000px)\",\r\n    \"max-width\": \"calc(100vw - 10px)\",\r\n    \"height\": \"360px\",\r\n    \"box-shadow\": \"2px 5px 19px -4px rgba(0,0,0,0.48)\",\r\n    \"border-radius\": \"1rem\",\r\n    \"border\": \"4px solid #f2f2f2\"\r\n}","mediumPortalStyle":"ðŸ§¬{\r\n    \"top\": \"10%\",\r\n    \"left\": \"10%\",\r\n    \"width\": \"clamp(420px, 30vw, 800px)\",\r\n    \"max-width\": \"calc(100vw - 10px)\",\r\n    \"height\": \"240px\",\r\n    \"box-shadow\": \"2px 5px 19px -4px rgba(0,0,0,0.48)\",\r\n    \"border-radius\": \"1rem\",\r\n    \"border\": \"4px solid #f2f2f2\"\r\n}","onAnyBotClicked":"@// if(that.bot.tags.tileProperties && !that.bot.tags.tileCopy){\r\n//     configBot.tags.codeToolsPortal = \"tagPortalTool\";\r\n\r\n//     thisBot.openTagPortal({\r\n//         size: \"large\",\r\n//         tag: configBot.tags.lastTagShown ?? \"tileProperties\",\r\n//         id: that.bot.id\r\n//     })\r\n// }","openTagPortal":"@thisBot.createTagPortal(that);\r\nthisBot.createTagPortalTools(that.tag);","smallPortalStyle":"ðŸ§¬{\r\n    \"top\": \"10%\",\r\n    \"left\": \"10%\",\r\n    \"width\": \"clamp(350px, 20vw, 600px)\",\r\n    \"max-width\": \"calc(100vw - 10px)\",\r\n    \"height\": \"180px\",\r\n    \"box-shadow\": \"2px 5px 19px -4px rgba(0,0,0,0.48)\",\r\n    \"border-radius\": \"1rem\",\r\n    \"border\": \"4px solid #f2f2f2\"\r\n}","system":"msPuzzleExplorer._tagPortalManager","puzzleExplorer":"true","abVersion":"10.10"}},"351afb9b-bff6-401e-938b-37b417f18d00":{"id":"351afb9b-bff6-401e-938b-37b417f18d00","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeY":-6,"homeZ":0,"labelColor":"#1A1A1A","labelFontSize":0.7,"system":"msPuzzleExplorer.pushableBlockSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"pushableBlock\",\r\n    \"passable\": false,\r\n    \"pushable\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": 0,\r\n        \"y\": -6\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/a53b8f79d08e8dfdb7860b3d04456eca7d8fca098a9d1c9533430c8535990ad3.png","form":"sprite","scaleZ":"0.01","homeX":0}},"389e9699-18ac-47e4-b1e4-d1b92ee31fc9":{"id":"389e9699-18ac-47e4-b1e4-d1b92ee31fc9","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":"false","labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.goalSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"goal\",\r\n    \"passable\": true,\r\n    \"winTile\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -5,\r\n        \"y\": 4\r\n    },\r\n    \"maxCopies\": 1,\r\n    \"maxCopiesMessage\": \"There can only be 1 goal at a time.\"\r\n}","puzzleExplorer":"true","abVersion":"10.10","homeX":-5,"formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeEndTile/a47aae2975df54f25babdc9d8e07faabab8b73c74d7ac0eb2d53f9c668890ce8.png","form":"sprite","scaleZ":"0.01","homeZ":0,"homeY":4}},"404150d6-cfab-4ccd-ab22-9472171aaadc":{"id":"404150d6-cfab-4ccd-ab22-9472171aaadc","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"pieceCopies.goalCopy","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"goal\",\r\n    \"passable\": true,\r\n    \"winTile\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -5,\r\n        \"y\": 4\r\n    },\r\n    \"maxCopies\": 1,\r\n    \"maxCopiesMessage\": \"There can only be 1 goal at a time.\"\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeEndTile/a47aae2975df54f25babdc9d8e07faabab8b73c74d7ac0eb2d53f9c668890ce8.png","form":"sprite","scaleZ":"0.01","homeZ":0,"homeY":-3,"boardOffset":{"x":3.5,"y":-3.5},"goalCopy":true,"copyType":"goal","tileCopy":true,"mode":"edit","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.mode = \"play\";\r\n    tags.gameStart ? thisBot.gameStart() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true, xPos: 0.5, yPos: -1.25, zoom: 18 }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners() : null;\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.mode = \"edit\";\r\n    tags.gameEnd ? thisBot.gameEnd() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners(false) : null;\r\n}","resetBoardCopies":"@ clearTagMasks(thisBot); masks.homeX = null; masks.homeY = null;","clearBoardCopies":"@ destroy(thisBot);","onDrag":"@if(tags.mode == \"play\"){ os.enableCustomDragging() }","onDrop":"@const fromX = Math.round(that.from.x * 100) / 100;\r\nconst fromY = Math.round(that.from.y * 100) / 100;\r\nconst toX = Math.round(that.to.x * 100) / 100;\r\nconst toY = Math.round(that.to.y * 100) / 100;\r\n\r\nconst offset = await thisBot.getOffset();\r\n\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y;\r\n\r\nconst coordCheck = (toX >= xMin && toX <= xMax) && (toY >= yMin && toY <= yMax);\r\n// const botCheck = !that.to.bot ? true : !that.to.bot.tags.tileProperties ? false : that.to.bot.tags.tileProperties.ground == true ? true : false;\r\nconst draggedBotCheck = that.dragBot.id == thisBot.id;\r\nconst playCheck = tags.mode == \"edit\";\r\n\r\nlet botCheck, vertOffset;\r\nif (!that.to.bot) { botCheck = true; }\r\nelse if (!that.to.bot.tags.tileProperties) { botCheck = false; }\r\nelse if (that.to.bot.tags.tileProperties.ground == true) { botCheck = true; vertOffset = that.to.bot.tags.homeZ + 0.01 ?? 0.01; }\r\nelse { botCheck = false; }\r\n\r\nif (draggedBotCheck) {\r\n    if (playCheck) {\r\n        if (coordCheck) {\r\n            if (botCheck) {\r\n                moveTileCopy(\"move\");\r\n            }\r\n            else {\r\n                moveTileCopy(\"stay\");\r\n            }\r\n        }\r\n        else if (tags.system == \"pieceCopies.goalCopy\" || tags.system == \"pieceCopies.spawnPointCopy\") {\r\n            moveTileCopy(\"stay\");\r\n        }\r\n        else {\r\n            destroy(thisBot);\r\n        }\r\n    }\r\n    else {\r\n        moveTileCopy(\"stay\");\r\n    }\r\n}\r\n\r\nfunction moveTileCopy(toFrom) {\r\n    let posX, posY;\r\n\r\n    if(toFrom == \"move\"){\r\n        posX = toX;\r\n        posY = toY;\r\n    }\r\n    else if (toFrom == \"stay\"){\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n    else {\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n\r\n    tags.homeX = posX;\r\n    tags.homeY = posY;\r\n    tags.boardOffset = {\r\n        x: posX - links.gameBoard.tags.homeX,\r\n        y: posY - links.gameBoard.tags.homeY\r\n    }\r\n}","onClick":"@if (tags.mode == \"edit\") {\r\n    if (tags.homeRotationZ) {\r\n        if (tags.homeRotationZ < -4.6) {\r\n            tags.homeRotationZ = 0;\r\n        }\r\n        else {\r\n            tags.homeRotationZ -= Math.PI / 2;\r\n        }\r\n    }\r\n    else {\r\n        tags.homeRotationZ = -Math.PI / 2;\r\n    }\r\n}","gameBoard":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","getOffset":"@if(links.gameBoard){\r\n    return {\r\n        x: Math.round((links.gameBoard.tags.homeX - 0.5)*100)/100,\r\n        y: Math.round((links.gameBoard.tags.homeY - 0.5)*100)/100\r\n    }\r\n}\r\nelse {\r\n    console.error(\"Game board not found. Unable to find offset.\")\r\n}","resetBoardTilePositions":"@const xMask = tags.homeX;\r\nconst yMask = tags.homeY;\r\n\r\nthisBot.masks.homeX = null;\r\nthisBot.masks.homeY = null;\r\n\r\nconst xPos = tags.homeX;\r\nconst yPos = tags.homeY;\r\n\r\nconst xDiff = xMask - xPos;\r\nconst yDiff = yMask - yPos;\r\n\r\nconst offset = thisBot.getOffset();\r\nconst boardOffset = tags.boardOffset;\r\n\r\ntags.homeX = 0.5 + offset.x + boardOffset.x;\r\ntags.homeY = 0.5 + offset.y + boardOffset.y;\r\n\r\nsetTagMask(thisBot, \"homeX\", tags.homeX + xDiff, \"shared\");\r\nsetTagMask(thisBot, \"homeY\", tags.homeY + yDiff, \"shared\");","winTile":true,"ignoreTouch":false,"winTileTouched":"@let playerTile = getTag(that, \"playerTile\");\r\n\r\nif (playerTile == true && tags.ignoreTouch == false) {\r\n    whisper(that, \"lock\");\r\n\r\n    let tempTileProperties = tags.tileProperties;\r\n    tempTileProperties.reached = true;\r\n    setTagMask(thisBot, \"tileProperties\", tempTileProperties, \"shared\");\r\n\r\n    let winTiles = {\r\n        reached: [],\r\n        remaining: []\r\n    };\r\n\r\n    getBots(b => {\r\n        let tileProperties = b.tags.tileProperties;\r\n        if (tileProperties) {\r\n            if (tileProperties.winTile == true && b.tags.tileCopy == true) {\r\n                tileProperties.reached == true ? winTiles.reached.push(b) : winTiles.remaining.push(b);\r\n            }\r\n        }\r\n    })\r\n\r\n    let remainingGoals = winTiles.remaining.length;\r\n\r\n    if (remainingGoals == 0) {\r\n        shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"levelComplete\" });\r\n        shout(\"doSharedAction\", { actionType: \"showMessage\", actionData: \"Level Complete!\" });\r\n        shout(\"levelComplete\");\r\n        shout(\"resetBoardCopies\");\r\n        shout(\"onBoardStateChange\", \"edit\");\r\n        shout(\"onBoardStateChange\", \"play\");\r\n        // await os.sleep(10);\r\n        // shout(\"setCurrentPlayer\", configBot.id);\r\n    }\r\n    else {\r\n        shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"goalReached\" });\r\n        shout(\"doSharedAction\", { actionType: \"showToast\", actionData: `Goal collected! Only ${remainingGoals} more to go!` });\r\n    }\r\n}","collectablesCheck":"@let collectables = getBots(byTag(\"collectableTile\", true), byTag(\"tileCopy\", true)); \r\n\r\nif(collectables.length > 0){\r\n    setTagMask(thisBot, \"ignoreTouch\", true, \"shared\");\r\n    setTagMask(thisBot, \"color\", \"grey\", \"shared\");\r\n}","allCollectablesGotten":"@ masks.color = null; masks.ignoreTouch = null;","gameStart":"@thisBot.collectablesCheck();\n if(tags.animationIdle){ os.startFormAnimation(thisBot, tags.animationIdle, { loop: true }) };","touched":"@thisBot.winTileTouched(that);","gameEnd":"@ \n if(tags.animationIdle){ os.stopFormAnimation(thisBot) };","homeX":4}},"4ccbf49c-2119-4e54-8ff8-56a1ed95b75b":{"id":"4ccbf49c-2119-4e54-8ff8-56a1ed95b75b","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.6","system":"msPuzzleExplorer.collectableSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"collectable\",\r\n    \"passable\": true,\r\n    \"collectable\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -1,\r\n        \"y\": -6\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/b103d72d0758bebcfadbf3a5c5dab569ff6127e8c67da8a2f4caf4a0887cde30.png","form":"sprite","scaleZ":"0.01","homeZ":0,"homeX":-1,"homeY":-6}},"58db4c40-1472-4a01-b95d-50c643dec038":{"id":"58db4c40-1472-4a01-b95d-50c643dec038","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.lockSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"lock\",\r\n    \"passable\": false,\r\n    \"lock\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -3,\r\n        \"y\": -6\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/9a48a670c751db59587fd85a274bc0c5ef4e52e38b87a6d12d0d1630161389a5.png","form":"sprite","scaleZ":"0.01","homeX":-3,"homeY":-6,"homeZ":0}},"6512ce22-bdc5-45eb-b6ac-d8740638e751":{"id":"6512ce22-bdc5-45eb-b6ac-d8740638e751","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"msPuzzleExplorer._dirButtonLeft","scaleZ":"0.01","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.form = \"sprite\";\r\n    tags.formAddress = \"https://auth-aux-dev-filesbucket-682397690660.s3.amazonaws.com/msTriangle20b2/02a0f3d98f9e944c430fc760b47ace45093cd48a8863516c1fd0847a000dd6f7.png\";\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.form = \"cube\";\r\n    tags.formAddress = null;\r\n}","onClick":"@if (tags.form != \"sprite\") {\r\n    links.playEdit.onClick();\r\n}\r\nelse {\r\n    shout(\"controllerTouched\", {\r\n        user: configBot.id,\r\n        direction: \"left\",\r\n        button: thisBot.id\r\n    })\r\n}","homeZ":0,"draggable":"false","labelFontSize":"1","puzzleExplorer":"true","abVersion":"10.10","strokeColor":"black","abIDOrigin":"puzzleExplorer","homeY":"-6","homeX":"2","setCurrentPlayer":"@// that == configBot.id ? masks.home = true : null","homeRotationZ":1.5707963267948966,"onPointerEnter":"@tags.form == \"sprite\" ? tags.color = \"grey\" : null;","onPointerExit":"@tags.form == \"sprite\" ? tags.color = null : null;","onPointerDown":"@tags.form == \"sprite\" ? tags.color = \"#303030\" : null;","onPointerUp":"@thisBot.onPointerEnter();","onGridClick":"@tags.color = null;","home":true,"controllerTouched":"@that == thisBot.id ? null : thisBot.onPointerExit();","form":"cube","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2"}},"8024cdf1-efb1-4990-b2fb-40daf5dc668a":{"id":"8024cdf1-efb1-4990-b2fb-40daf5dc668a","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","App":"@const { useEffect, useState, useCallback } = os.appHooks;\r\n\r\nlet message = that;\r\n\r\nconst App = () => {\r\n    const [closing, setClosing] = useState(false);\r\n\r\n    const onCloseClick = useCallback(() => {\r\n        setClosing(true);\r\n    }, []);\r\n\r\n    useEffect(() => {\r\n        if (closing) {\r\n            const timer = setTimeout(() => {\r\n                thisBot.unmount();\r\n            }, 300); // match exit animation duration\r\n            return () => clearTimeout(timer);\r\n        }\r\n    }, [closing]);\r\n\r\n    return (\r\n        <>\r\n            <style>{tags['style.css']}</style>\r\n            <div className='messageContainer' onClick={onCloseClick}>\r\n                <div className={`messageBox ${closing ? 'slideOut' : 'slideIn'}`}>\r\n                    <span>{`${message}`}</span>\r\n                </div>\r\n            </div>\r\n        </>\r\n    );\r\n};\r\n\r\nreturn App;\r\n","abIDOrigin":"puzzleExplorer","bufferSounds":"@let soundCatalogue = tags.sounds;\r\n\r\nfor(const sound in soundCatalogue){\r\n    console.log(`Buffering Sound ${sound}:`, soundCatalogue[sound])\r\n    await os.bufferSound(soundCatalogue[sound]);\r\n}","clearBoard":"ðŸ”—d2c9082c-4c0a-4841-94c3-434207f08aed","csvToJson":"@let csv = that.replaceAll(\"\\r\", \"\");\r\nconst rows = csv.split(\"\\n\").filter(row => row.trim() !== \"\");\r\n\r\nconst result = { tilesetName: [] };\r\nlet currentHeader = null;\r\n\r\nfor (let i = 0; i < rows.length; i++) {\r\n    let line = rows[i];\r\n    let inQuotes = false;\r\n    let modifiedLine = \"\";\r\n\r\n    // Handle commas inside quotes\r\n    for (let j = 0; j < line.length; j++) {\r\n        let char = line[j];\r\n        if (char === `\"`) {\r\n            inQuotes = !inQuotes;\r\n            modifiedLine += char;\r\n        } else if (char === \",\" && inQuotes) {\r\n            modifiedLine += \"&&&\"; // placeholder for in-quote commas\r\n        } else {\r\n            modifiedLine += char;\r\n        }\r\n    }\r\n\r\n    const splitLine = modifiedLine.split(\",\").map(entry => {\r\n        let cleaned = entry.replaceAll(\"&&&\", \",\").trim();\r\n\r\n        // Remove surrounding quotes if present\r\n        if (cleaned.startsWith('\"') && cleaned.endsWith('\"')) {\r\n            cleaned = cleaned.slice(1, -1);\r\n        }\r\n\r\n        // Convert double double-quotes to real quotes\r\n        cleaned = cleaned.replaceAll('\"\"', '\"');\r\n\r\n        // Convert empty strings to null\r\n        if (cleaned === \"\") {\r\n            return null;\r\n        }\r\n\r\n        // Try parsing JSON if it looks like JSON\r\n        const trimmed = cleaned.trim();\r\n        const looksLikeJson = (trimmed.startsWith(\"{\") && trimmed.endsWith(\"}\")) ||\r\n                              (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\"));\r\n        if (looksLikeJson) {\r\n            try {\r\n                return JSON.parse(trimmed);\r\n            } catch {\r\n                return cleaned;\r\n            }\r\n        }\r\n\r\n        return cleaned;\r\n    });\r\n\r\n    // First row: tileset names\r\n    if (i === 0) {\r\n        result.tilesetName = splitLine.slice(2);\r\n        continue;\r\n    }\r\n\r\n    const header = splitLine[0];\r\n    const property = splitLine[1];\r\n    const values = splitLine.slice(2);\r\n\r\n    // Update currentHeader if found\r\n    if (header) {\r\n        currentHeader = header;\r\n        if (!result[currentHeader]) {\r\n            result[currentHeader] = {};\r\n        }\r\n    }\r\n\r\n    // Skip if we don't have a current header or property name\r\n    if (!currentHeader || !property) continue;\r\n\r\n    // Add property values to the correct header\r\n    result[currentHeader][property] = values;\r\n}\r\n\r\nreturn result;\r\n","doSharedAction":"@console.log(\"doSharedAction: \", that);\r\n\r\nconst {\r\n    actionType,\r\n    actionData\r\n} = that;\r\n\r\nconst collaborative = await os.isCollaborative();\r\n\r\nif (collaborative){\r\n    const remotes = await os.remotes();\r\n    sendRemoteData(remotes, actionType, {\r\n        message: actionData\r\n    });\r\n}\r\nelse {\r\n    shout(\"onRemoteData\", { \"name\": actionType, \"that\": { \"message\": actionData } });\r\n}","gameBoard":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","gameStart":"@thisBot.bufferSounds();","getOffset":"@if(links.gameBoard){\r\n    return {\r\n        x: Math.round((links.gameBoard.tags.homeX - 0.5)*100)/100,\r\n        y: Math.round((links.gameBoard.tags.homeY - 0.5)*100)/100\r\n    }\r\n}\r\nelse {\r\n    console.error(\"Game board not found. Unable to find offset.\")\r\n}","goalSound":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeGoalSound/15c1eb86be12fd286f6c435ffe881568e7cc49a7b0ef329f370385cb09ffdb86.wav","hideTileSpawners":"@let hide = that ?? true;\r\n\r\ngetBots(b => {\r\n    let tileSpawner = b.tags.tileProperties ? true : false;\r\n    let tileCopy = b.tags.tileCopy == true;\r\n    let addTileButton = b.tags.system == \"msPuzzleExplorer._addTileButton\";\r\n    let hiddenTile = b.tags.hiddenTiles == true;\r\n\r\n    if(addTileButton){\r\n        hide == true ? setTagMask(b, \"home\", false, \"shared\") : setTagMask(b, \"home\", null, \"shared\");\r\n    }\r\n    else if(tileSpawner && !tileCopy && !hiddenTile){\r\n        hide == true ? setTagMask(b, \"home\", false, \"shared\") : setTagMask(b, \"home\", null, \"shared\");\r\n    }\r\n\r\n});","levelFinishSound":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeLevelSound/c15616ba1845a5da3e69dd8405d3a4036024da8b6f53e4982fa41f344c14ad41.wav","loadArtSheets":"@//loads a csv through a google sheet url (the sheet url or share url)\r\nlet sheetLink = \"https://docs.google.com/spreadsheets/d/1j8EHqkK1AN7MZLVKVA2y79nO_xecgXtc__7dJxXed54/edit?usp=sharing\";\r\n\r\n// temporary, revert back after updating the main sheet\r\n// let sheetLink = \"https://docs.google.com/spreadsheets/d/1RwLmNBjY8LrsuM0966LZ1H-k8gewkuRh-EFjmSgzoVs/edit?usp=sharing\";\r\n\r\nlet possibleGID = sheetLink.indexOf(\"#gid\");\r\n\r\nif (possibleGID != -1) {\r\n    possibleGID = sheetLink.substring(possibleGID);\r\n}\r\n\r\nsheetLink = sheetLink.replace(\"?usp=sharing\" || possibleGID, \"\");\r\n\r\nsheetLink = sheetLink.replace(\"edit\", \"export?format=csv\");\r\n\r\nlet response = await web.hook({\r\n    method: 'GET',\r\n    url: sheetLink\r\n});\r\nif (response.status == 200) {\r\n    let processedData = thisBot.csvToJson(response.data);\r\n    console.log(\"processedData: \", processedData);\r\n    // const dataKeys = Object.keys(processedData);\r\n    let offset = await thisBot.getOffset();\r\n\r\n    for (let i = 0; i < processedData.tilesetName.length; i++) {\r\n        let xCoord = i < 3 ? [-3, -1, 1][i] : [-3, -1, 1, 3][(i - 3) % 4];\r\n        let yCoord = i < 3 ? 6 : 8 + 2 * Math.floor((i - 3) / 4);\r\n\r\n        let tilesetBot = getBot(byTag(\"tilesetName\", processedData.tilesetName[i]));\r\n\r\n        if (!tilesetBot) {\r\n            let imageSetBot = {\r\n                space: \"tempLocal\",\r\n                gameBoard: tags.gameBoard,\r\n                getOffset: tags.getOffset,\r\n                tilesetBot: true,\r\n                tilesetName: processedData.tilesetName[i],\r\n                // onBoardStateChange: `@  if(that == \"play\"){ tags.home = false; } else if(that == \"edit\"){ tags.home = true; };`,\r\n                tilesetNumber: i,\r\n                resetTilesetPositions: `@\r\n                    let i = tags.tilesetNumber;\r\n                    let xCoord = i < 3 ? [-3, -1, 1][i] : [-3, -1, 1, 3][(i - 3) % 4];\r\n                    let yCoord = i < 3 ? 6 : 8 + 2 * Math.floor((i - 3) / 4);\r\n                    let offset = thisBot.getOffset();\r\n\r\n                    tags.homeX = offset ? xCoord + offset.x : xCoord;\r\n                    tags.homeY = offset ? yCoord + offset.y : yCoord;\r\n                `,\r\n                form: processedData.previewImage.assetType[i] == \"3D\" ? \"mesh\" : processedData.previewImage.assetType[i] == \"2D\" ? \"sprite\" : \"cube\",\r\n                formSubtype: processedData.previewImage.assetType[i] == \"3D\" ? \"gltf\" : null,\r\n                formAddress: processedData.previewImage.assetType[i] == \"json\" ? null : processedData.previewImage.asset[i],\r\n                home: false,\r\n                homeX: offset.x ? xCoord + offset.x : xCoord,\r\n                homeY: offset.y ? yCoord + offset.y : yCoord,\r\n                tilesetsVisible: `@ tags.home == true ? tags.home = false : tags.home = true`,\r\n                draggable: false,\r\n                onClick: `@\r\n                getBots(b => {\r\n                    let tileType = b.tags.tileProperties ? b.tags.tileProperties.tileType : null;\r\n\r\n                    if(tags[tileType]){\r\n                        tags[tileType].asset || tags[tileType].extraMods ? setTag(b, \"formAddress\", tags[tileType].asset) : null;\r\n\r\n                        if(b.tags.formAddress != null){\r\n                            setTag(b, \"color\", null);\r\n                            setTag(b, \"label\", null);\r\n                        }\r\n                        \r\n                        if(tags[tileType].assetType == \"3D\"){\r\n                            setTag(b, \"form\", \"mesh\");\r\n                            setTag(b, \"formSubtype\", \"gltf\");\r\n                            setTag(b, \"scaleZ\", null);\r\n                        }\r\n                        else if(tags[tileType].assetType == \"2D\"){\r\n                            setTag(b, \"form\", \"sprite\");\r\n                            setTag(b, \"formSubtype\", null);\r\n                            setTag(b, \"scaleZ\", \"0.01\");\r\n                        }\r\n                        else if(tags[tileType].extraMods) {\r\n                            setTag(b, \"form\", null);\r\n                            setTag(b, \"formSubtype\", null);\r\n                            setTag(b, \"scaleZ\", null);\r\n                        }\r\n\r\n                        tags[tileType].animationIdle ? setTag(b, \"animationIdle\", tags[tileType].animationIdle) : setTag(b, \"animationIdle\", null);\r\n                        tags[tileType].toggleAsset ? setTag(b, \"toggleAsset\", tags[tileType].toggleAsset) : setTag(b, \"animationIdle\", null);\r\n\r\n                        if(tags[tileType].extraMods){\r\n                            for(const mod in tags[tileType].extraMods){\r\n                                if(mod == \"label\" && b.tags.labelPosition && b.tags.labelPosition == \"floatingBillboard\"){\r\n                                    null\r\n                                }\r\n                                else {\r\n                                    setTag(b, mod, tags[tileType].extraMods[mod]);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                })\r\n\r\n                shout(\"setCameraVariables\", { \"skipWait\": true });\r\n                shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"tilesetClicked\" });\r\n            `\r\n            }\r\n\r\n            for (const tile in processedData) {\r\n                if (Array.isArray(processedData[tile])) {\r\n                    imageSetBot[tile] = processedData[tile][i]\r\n                }\r\n                else {\r\n                    let props = Object.entries(processedData[tile]);\r\n                    imageSetBot[tile] = {};\r\n\r\n                    for (const prop of props) {\r\n                        imageSetBot[tile][prop[0]] = prop[1][i]\r\n                    }\r\n                }\r\n            }\r\n\r\n            console.log(\"imageSetBot\", imageSetBot)\r\n\r\n            if (processedData.previewImage.extraMods[i]) {\r\n                create(imageSetBot, processedData.previewImage.extraMods[i])\r\n            }\r\n            else {\r\n                create(imageSetBot)\r\n            };\r\n        }\r\n\r\n\r\n    }\r\n}\r\nelse {\r\n    console.error(\"sheet grab error\");\r\n}","mount":"@const App = thisBot.App(that.message);\r\n\r\nconsole.log(\"app prop: \", that)\r\n\r\nawait os.registerApp(\"messageApp\", thisBot);\r\nawait os.compileApp(\"messageApp\", <App/>)","onAnyBotDrop":"@const draggedBot = that.bot;\r\nconst remotes = await os.remotes();\r\nconst tileProperties = getTag(draggedBot, \"tileProperties\");\r\n\r\nlet copyType, copyTag, maxCopies, maxCopiesMessage;\r\nlet offset = await thisBot.getOffset();\r\n\r\nif (tileProperties) {\r\n    copyType = tileProperties.tileType;\r\n    copyTag = copyType + \"Copy\";\r\n    maxCopies = tileProperties.copiesPerPlayer ? remotes.length * tileProperties.copiesPerPlayer : tileProperties.maxCopies ? tileProperties.maxCopies : null;\r\n    maxCopiesMessage = tileProperties.maxCopiesMessage;\r\n}\r\nelse {\r\n    copyType = null;\r\n    copyTag = null;\r\n    maxCopies = null;\r\n    maxCopiesMessage = null;\r\n}\r\n\r\nconst fromX = Math.round(that.from.x * 100)/100;\r\nconst fromY = Math.round(that.from.y * 100)/100;\r\nconst toX = Math.round(that.to.x * 100)/100;\r\nconst toY = Math.round(that.to.y * 100)/100;\r\n\r\nconsole.log(`fromX: ${that.from.x}, fromY: ${that.from.y}`);\r\n\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y\r\n\r\nconst copyCheck = !getTag(draggedBot, \"copyType\");\r\nconst coordCheck = (toX >= xMin && toX <= xMax) && (toY >= yMin && toY <= yMax);\r\n// const botCheck = !that.to.bot ? true : !that.to.bot.tags.tileProperties ? false : that.to.bot.tags.tileProperties.ground == true ? true : false;\r\n\r\nlet botCheck, vertOffset;\r\nif(!that.to.bot){ botCheck = true; }\r\nelse if(!that.to.bot.tags.tileProperties){ botCheck = false; }\r\nelse if(that.to.bot.tags.tileProperties.ground == true){ botCheck = true; vertOffset = that.to.bot.tags.homeZ + 0.01 ?? 0.01; }\r\nelse { botCheck = false; }\r\n\r\nconsole.log(\"bot check: \", botCheck)\r\n\r\n\r\nif (copyCheck && copyType) {\r\n    setTag(draggedBot, \"homeX\", fromX);\r\n    setTag(draggedBot, \"homeY\", fromY);\r\n\r\n    if (coordCheck && botCheck && tags.mode == \"edit\") {\r\n        if (maxCopies) {\r\n            let pieceCopies = getBots(byTag(copyTag, true));\r\n\r\n            if (pieceCopies.length >= maxCopies) {\r\n                os.toast(maxCopiesMessage);\r\n            }\r\n            else {\r\n                thisBot.spawnTileCopy({\r\n                    tile: draggedBot,\r\n                    position: {\r\n                        x: toX,\r\n                        y: toY,\r\n                        z: vertOffset ?? null\r\n                    },\r\n                    extraMods: that.extraMods\r\n                })\r\n            }\r\n        }\r\n        else {\r\n            thisBot.spawnTileCopy({\r\n                tile: draggedBot,\r\n                position: {\r\n                    x: toX,\r\n                    y: toY,\r\n                    z: vertOffset ?? null\r\n                },\r\n                extraMods: that.extraMods\r\n            })\r\n        }\r\n    }\r\n}","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.mode = \"play\";\r\n    tags.gameStart ? thisBot.gameStart() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true, xPos: 0.5, yPos: -1.25, zoom: 18 }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners() : null;\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.mode = \"edit\";\r\n    tags.gameEnd ? thisBot.gameEnd() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners(false) : null;\r\n}","onEggHatch":"@thisBot.setCameraVariables();\r\nthisBot.loadArtSheets();","onInstJoined":"@thisBot.setCameraVariables();\r\nthisBot.loadArtSheets();\r\nthisBot.bufferSounds();\r\nthisBot.setPEBotPositions();","onRemoteData":"@let event = that.name;\r\nlet data = that.that;\r\n\r\nconsole.log(\"Remote Data:\", that);\r\n\r\nswitch (event) {\r\n    case \"showToast\":\r\n        os.toast(data.message);\r\n        break;\r\n    case \"playSound\":\r\n        os.playSound(tags.sounds[data.message]);\r\n        break;\r\n    case \"showMessage\":\r\n        // thisBot.mount({ message: data.message });\r\n        // thisBot.mount({ message: \"bcdkbfkbbdjkfnfcvkljdanvo;jdas\" });\r\n        let messageBot = getBot(byTag(\"system\", \"gameMessage.levelComplete\"));\r\n        if (messageBot?.tags?.label != data.message) {\r\n            let offset = await thisBot.getOffset();\r\n            create({\r\n                space: \"tempLocal\",\r\n                home: true,\r\n                homeX: 0.5 + offset.x,\r\n                homeY: 0.5 + offset.y,\r\n                homeZ: 3,\r\n                orientationMode: \"billboard\",\r\n                label: data.message,\r\n                labelFontSize: 3,\r\n                onClick: `@ destroy(thisBot)`,\r\n                system: \"gameMessage.levelComplete\",\r\n                scale: 10,\r\n                scaleY: 0.5,\r\n                scaleZ: 0.01,\r\n            });\r\n        }\r\n\r\n        break;\r\n}","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2","playGameSound":"@let sound = that;\r\nconst collaborative = await os.isCollaborative();\r\n\r\nif (collaborative) {\r\n    let remotes = await os.remotes();\r\n    sendRemoteData(remotes, \"playSound\", {\r\n        message: that\r\n    });\r\n}\r\nelse {\r\n    shout(\"onRemoteData\", { \"name\": \"playSound\", \"that\": { \"message\": that } });\r\n}","propertyHolder":"ðŸ”—862241e7-dc8e-4fa7-8f9a-7c31460d3336","resetTilePosition":"@const xMask = tags.homeX;\r\nconst yMask = tags.homeY;\r\n\r\nthisBot.masks.homeX = null;\r\nthisBot.masks.homeY = null;\r\n\r\nconst xPos = tags.homeX;\r\nconst yPos = tags.homeY;\r\n\r\nconst xDiff = xMask - xPos;\r\nconst yDiff = yMask - yPos;\r\n\r\nconst offset = thisBot.getOffset();\r\nconst boardOffset = tags.boardOffset;\r\n\r\ntags.homeX = 0.5 + offset.x + boardOffset.x;\r\ntags.homeY = 0.5 + offset.y + boardOffset.y;\r\n\r\nsetTagMask(thisBot, \"homeX\", tags.homeX + xDiff, \"shared\");\r\nsetTagMask(thisBot, \"homeY\", tags.homeY + yDiff, \"shared\");","setCameraVariables":"@let {\n    skipWait = false,\n    xPos = 0.5,\n    yPos = -1.25,\n    zoom = 18\n} = that || {};\n\nif(skipWait != true){ await os.sleep(1000); }\n\nlet offset = await thisBot.getOffset();\nlet meshBots = false;\n\ngetBots(b => {\n    if (b.tags.tileProperties && b.tags.form == \"mesh\") {\n        meshBots = true;\n    }\n})\n\nawait os.focusOn({\n    x: xPos + offset.x,\n    y: yPos + offset.y\n}, {\n    rotation: {\n        x: 0,\n        y: 0\n    },\n    duration: 1,\n    zoom: zoom\n});\n\nif (!meshBots) {\n    gridPortalBot.tags.portalRotatable = false;\n    // gridPortalBot.tags.portalPannable = false;\n    gridPortalBot.tags.portalPannableMaxX = 20 + offset.x;\n    gridPortalBot.tags.portalPannableMaxY = 20 + offset.y;\n    gridPortalBot.tags.portalPannableMinX = -20 + offset.x;\n    gridPortalBot.tags.portalPannableMinY = -20 + offset.y;\n    gridPortalBot.tags.portalZoomableMax = 30;\n    gridPortalBot.tags.portalZoomableMin = 10;\n}\nelse {\n    gridPortalBot.tags.portalRotatable = true;\n    gridPortalBot.tags.portalPannableMaxX = 20 + offset.x;\n    gridPortalBot.tags.portalPannableMaxY = 20 + offset.y;\n    gridPortalBot.tags.portalPannableMinX = -20 + offset.x;\n    gridPortalBot.tags.portalPannableMinY = -20 + offset.y;\n    gridPortalBot.tags.portalZoomableMax = 30;\n    gridPortalBot.tags.portalZoomableMin = 10;\n}","setPEBotPositions":"@const offset = thisBot.getOffset();\r\nconst botsToPosition = [\r\n    {\r\n        bot: links.playEdit,\r\n        pos: {\r\n            x: links.playEdit.tags.label == \"Play\" ? 3 + offset.x : -2 + offset.x,\r\n            y: links.playEdit.tags.label == \"Play\" ? -6 + offset.y : -6.5 + offset.y\r\n        }\r\n    },\r\n    {\r\n        bot: links.clearBoard,\r\n        pos: {\r\n            x: -4 + offset.x,\r\n            y: -5 + offset.y\r\n        }\r\n    }\r\n]\r\n\r\ngetBots(b => {\r\n    if(b.tags.tileProperties){\r\n        if(b.tags.tileCopy == true){\r\n            null\r\n        }\r\n        else if(b.tags.tileProperties.spawnPosition) {\r\n            botsToPosition.push({\r\n                bot: b,\r\n                pos: {\r\n                    x: b.tags.tileProperties.spawnPosition.x + offset.x,\r\n                    y: b.tags.tileProperties.spawnPosition.y + offset.y\r\n                }\r\n            })\r\n        }\r\n    }\r\n})\r\n\r\nfor(const botEntry of botsToPosition){\r\n    setTag(botEntry.bot, \"homeX\", botEntry.pos.x);\r\n    setTag(botEntry.bot, \"homeY\", botEntry.pos.y);\r\n}\r\n\r\nshout(\"resetTilesetPositions\");\r\nshout(\"resetBoardTilePositions\");","sounds":"ðŸ§¬{\r\n    \"goalReached\": \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeGoalSound/15c1eb86be12fd286f6c435ffe881568e7cc49a7b0ef329f370385cb09ffdb86.wav\",\r\n    \"levelComplete\": \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeLevelSound/c15616ba1845a5da3e69dd8405d3a4036024da8b6f53e4982fa41f344c14ad41.wav\",\r\n    \"teleport\": \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeTeleport/71af3176ff47f515ccc9d3496e587b0737a8fd55ceca7d606f2313fa54028e1c.wav\",\r\n    \"collectablePickup\": \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeCollectablePickup/358b505b98dbf7dc6cbd93da893af778c40885cb64f1bf996dcba0c625329737.wav\",\r\n    \"tilesetClicked\": \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeTilesetSound/e50e659a71f54b87e76551a85007700659b304380bdef44cc5aa45dd146a4906.mpga\"\r\n}","spawnTileCopy":"@const {\r\n    tile,\r\n    position,\r\n    extraMods\r\n} = that;\r\n\r\nconst tileProperties = getTag(tile, \"tileProperties\");\r\n\r\nlet copyType, copyTag;\r\n\r\ncopyType = tileProperties.tileType;\r\ncopyTag = copyType + \"Copy\";\r\n\r\nlet copyMods = {\r\n    homeX: position.x,\r\n    homeY: position.y,\r\n    homeZ: position.z ?? 0,\r\n    boardOffset: { \r\n        x: position.x - (links.gameBoard.tags.homeX), \r\n        y: position.y - (links.gameBoard.tags.homeY)\r\n    },\r\n    system: \"pieceCopies.\" + copyTag,\r\n    label: tile.tags.formAddress ? null : tile.tags.label,\r\n    [copyTag]: true,\r\n    copyType: copyType,\r\n    tileCopy: true,\r\n    mode: tags.mode,\r\n    onBoardStateChange: tags.onBoardStateChange,\r\n    resetBoardCopies: `@ clearTagMasks(thisBot); masks.homeX = null; masks.homeY = null;`,\r\n    clearBoardCopies: `@ destroy(thisBot);`,\r\n    onDrag: tags.tileCopyDrag,\r\n    onDrop: tags.tileCopyDrop,\r\n    onClick: tags.tileCopyClicked,\r\n    gameBoard: tags.gameBoard,\r\n    getOffset: tags.getOffset,\r\n    resetBoardTilePositions: tags.resetTilePosition\r\n}\r\n\r\nconst propsToGet = [];\r\n\r\ntileProperties.player == true ? propsToGet.push(\"player\") : null;\r\ntileProperties.lock == true ? propsToGet.push(\"lock\") : null;\r\ntileProperties.key == true ? propsToGet.push(\"key\") : null;\r\ntileProperties.winTile == true ? propsToGet.push(\"winTile\") : null;\r\ntileProperties.moveUpDown == true ? propsToGet.push(\"moveUpDown\") : null;\r\ntileProperties.moveLeftRight == true ? propsToGet.push(\"moveLeftRight\") : null;\r\ntileProperties.harmful == true ? propsToGet.push(\"harmful\") : null;\r\ntileProperties.playerSpawnpoint == true ? propsToGet.push(\"playerSpawnpoint\") : null;\r\ntileProperties.collectable == true ? propsToGet.push(\"collectable\") : null;\r\ntileProperties.paired == true ? propsToGet.push(\"paired\") : null;\r\ntileProperties.teleporter == true ? propsToGet.push(\"teleporter\") : null;\r\ntileProperties.pressurePlate == true ? propsToGet.push(\"pressurePlate\") : null;\r\ntileProperties.pressureDoor == true ? propsToGet.push(\"pressureDoor\") : null;\r\ntileProperties.pushable == true ? propsToGet.push(\"pushable\") : null;\r\n\r\nconst tileFunctions = links.propertyHolder._getTileFunctions(propsToGet);\r\n\r\nconsole.log(\"tileFunctions:\", tileFunctions)\r\n\r\nfor (const tag in tileFunctions.tagsToAdd) {\r\n    copyMods[tag] = tileFunctions.tagsToAdd[tag];\r\n}\r\ntileFunctions.gameStart.length > 0 ? copyMods.gameStart = `@` + tileFunctions.gameStart.join(\"\\n\") : null;\r\ntileFunctions.gameEnd.length > 0 ? copyMods.gameEnd = `@` + tileFunctions.gameEnd.join(\"\\n\") : null;\r\ntileFunctions.touched.length > 0 ? copyMods.touched = `@` + tileFunctions.touched.join(\"\\n\") : null;\r\ntileFunctions.left.length > 0 ? copyMods.left = `@` + tileFunctions.left.join(\"\\n\") : null;\r\ntileFunctions.levelComplete.length > 0 ? copyMods.levelComplete = `@` + tileFunctions.levelComplete.join(\"\\n\") : null;\r\n\r\nlet animationIdleStartString = `\\n if(tags.animationIdle){ os.startFormAnimation(thisBot, tags.animationIdle, { loop: true }) };`;\r\nlet animationIdleStopString = `\\n if(tags.animationIdle){ os.stopFormAnimation(thisBot) };`;\r\n\r\nconsole.log(copyMods.gameStart)\r\n\r\ncopyMods.gameStart ? copyMods.gameStart += animationIdleStartString : copyMods.gameStart = `@ ` + animationIdleStartString;\r\ncopyMods.gameEnd ? copyMods.gameEnd += animationIdleStopString : copyMods.gameEnd = `@ ` + animationIdleStopString;\r\n\r\nconsole.log(copyMods.gameStart)\r\n\r\nif (extraMods) {\r\n    for (const mod in extraMods) {\r\n        copyMods[mod] = extraMods[mod];\r\n    }\r\n}\r\n\r\ncreate(tile, copyMods);\r\n\r\nconsole.log(\"copyMods: \", copyMods);","style.css":".messageContainer {\r\n    width: 100%;\r\n    height: 100%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    align-items: center;\r\n    justify-content: center;\r\n    /* background-color: rgba(0, 0, 0, 0.5); */\r\n    overflow: hidden;\r\n    user-select: none;\r\n}\r\n\r\n.messageBox {\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n    padding: 1.5rem 2rem;\r\n    max-width: 80%;\r\n    max-height: 80%;\r\n    background-color: white;\r\n    border: 1px solid black;\r\n    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);\r\n    font-size: 3rem;\r\n}\r\n\r\n@keyframes slideIn {\r\n    from {\r\n        transform: translateY(100vh);\r\n        opacity: 0;\r\n    }\r\n    to {\r\n        transform: translateY(0);\r\n        opacity: 1;\r\n    }\r\n}\r\n\r\n@keyframes slideOut {\r\n    from {\r\n        transform: translateY(0);\r\n        opacity: 1;\r\n    }\r\n    to {\r\n        transform: translateY(100vh);\r\n        opacity: 0;\r\n    }\r\n}\r\n\r\n\r\n.slideIn {\r\n    animation: slideIn 0.3s ease-out forwards;\r\n}\r\n\r\n.slideOut {\r\n    animation: slideOut 0.3s ease-in forwards;\r\n}\r\n","system":"msPuzzleExplorer._controller","tileCopyClicked":"@if (tags.mode == \"edit\") {\r\n    if (tags.homeRotationZ) {\r\n        if (tags.homeRotationZ < -4.6) {\r\n            tags.homeRotationZ = 0;\r\n        }\r\n        else {\r\n            tags.homeRotationZ -= Math.PI / 2;\r\n        }\r\n    }\r\n    else {\r\n        tags.homeRotationZ = -Math.PI / 2;\r\n    }\r\n}","tileCopyDrag":"@if(tags.mode == \"play\"){ os.enableCustomDragging() }","tileCopyDrop":"@const fromX = Math.round(that.from.x * 100) / 100;\r\nconst fromY = Math.round(that.from.y * 100) / 100;\r\nconst toX = Math.round(that.to.x * 100) / 100;\r\nconst toY = Math.round(that.to.y * 100) / 100;\r\n\r\nconst offset = await thisBot.getOffset();\r\n\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y;\r\n\r\nconst coordCheck = (toX >= xMin && toX <= xMax) && (toY >= yMin && toY <= yMax);\r\n// const botCheck = !that.to.bot ? true : !that.to.bot.tags.tileProperties ? false : that.to.bot.tags.tileProperties.ground == true ? true : false;\r\nconst draggedBotCheck = that.dragBot.id == thisBot.id;\r\nconst playCheck = tags.mode == \"edit\";\r\n\r\nlet botCheck, vertOffset;\r\nif (!that.to.bot) { botCheck = true; }\r\nelse if (!that.to.bot.tags.tileProperties) { botCheck = false; }\r\nelse if (that.to.bot.tags.tileProperties.ground == true) { botCheck = true; vertOffset = that.to.bot.tags.homeZ + 0.01 ?? 0.01; }\r\nelse { botCheck = false; }\r\n\r\nif (draggedBotCheck) {\r\n    if (playCheck) {\r\n        if (coordCheck) {\r\n            if (botCheck) {\r\n                moveTileCopy(\"move\");\r\n            }\r\n            else {\r\n                moveTileCopy(\"stay\");\r\n            }\r\n        }\r\n        else if (tags.system == \"pieceCopies.goalCopy\" || tags.system == \"pieceCopies.spawnPointCopy\") {\r\n            moveTileCopy(\"stay\");\r\n        }\r\n        else {\r\n            destroy(thisBot);\r\n        }\r\n    }\r\n    else {\r\n        moveTileCopy(\"stay\");\r\n    }\r\n}\r\n\r\nfunction moveTileCopy(toFrom) {\r\n    let posX, posY;\r\n\r\n    if(toFrom == \"move\"){\r\n        posX = toX;\r\n        posY = toY;\r\n    }\r\n    else if (toFrom == \"stay\"){\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n    else {\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n\r\n    tags.homeX = posX;\r\n    tags.homeY = posY;\r\n    tags.boardOffset = {\r\n        x: posX - links.gameBoard.tags.homeX,\r\n        y: posY - links.gameBoard.tags.homeY\r\n    }\r\n}","unmount":"@// Compiling the app with an empty root value is a workaround that allows the\r\n// previous components to perform their unmounting code properly.\r\nawait os.compileApp(\"messageApp\", <></>);\r\nawait os.unregisterApp(\"tags.system\");","puzzleExplorer":"true","abVersion":"10.10","versionNumber":"0.8.1","allowCameraRotation":"@that == true ? gridPortalBot.tags.portalRotatable = true : gridPortalBot.tags.portalRotatable = false;","restartPuzzle":"@shout(\"resetBoardCopies\");\r\n\r\n// await os.sleep(50);\r\n\r\nshout(\"onBoardStateChange\", \"edit\");\r\nshout(\"onBoardStateChange\", \"play\");\r\n\r\nawait os.sleep(50);\r\n\r\nshout(\"setCurrentPlayer\", configBot.id);","mode":"edit"}},"862241e7-dc8e-4fa7-8f9a-7c31460d3336":{"id":"862241e7-dc8e-4fa7-8f9a-7c31460d3336","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","_getTileFunctions":"@const properties = Array.isArray(that) ? that : null;\r\nconst tileFunctions = {\r\n    tagsToAdd: {},\r\n    gameStart: [],\r\n    gameEnd: [],\r\n    touched: [],\r\n    left: [],\r\n    levelComplete: []\r\n}\r\n\r\nif (properties == null) {\r\n    return tileFunctions;\r\n}\r\nelse {\r\n    const tagsToAdd = tileFunctions.tagsToAdd;\r\n    const gameStart = tileFunctions.gameStart;\r\n    const touched = tileFunctions.touched;\r\n    const gameEnd = tileFunctions.gameEnd;\r\n    const levelComplete = tileFunctions.levelComplete;\r\n    const left = tileFunctions.left;\r\n\r\n    for (const prop of properties) {\r\n        switch (prop) {\r\n            case \"player\":\r\n                // const playerNumber = getBots(byTag(\"playerTile\", true)).length + 1;\r\n\r\n                tagsToAdd.playerTile = true;\r\n                tagsToAdd.onKeyDown = tags.playerMovement;\r\n                tagsToAdd.onDragging = tags.dragControls;\r\n                tagsToAdd.move = tags.moveTile;\r\n                // tagsToAdd.labelPosition = \"floatingBillboard\";\r\n                tagsToAdd.labelFloatingBackgroundColor = thisBot.getRandomColor();\r\n                // tagsToAdd.playerNumber = playerNumber;\r\n                // tagsToAdd.label = \"Player \" + playerNumber;\r\n                tagsToAdd.lock = tags.lockControls;\r\n                tagsToAdd.hide = tags.hideTile;\r\n                tagsToAdd.playerTouched = tags.playerTouched;\r\n                tagsToAdd.labelFontSize = 0.7;\r\n                tagsToAdd.playEdit = tags.playEdit;\r\n\r\n                touched.push(\"thisBot.playerTouched(that);\");\r\n\r\n\r\n\r\n                break;\r\n            case \"lock\":\r\n                tagsToAdd.unlockPuzzleLocks = tags.hideTile;\r\n                break;\r\n            case \"key\":\r\n                tagsToAdd.keyTouched = `@ shout(\"unlockPuzzleLocks\"); setTagMask(thisBot, \"home\", false, \"shared\");`;\r\n                touched.push(\"thisBot.keyTouched();\")\r\n                break;\r\n            case \"unlock\":\r\n                tagsToAdd.unlockTouched = `@ shout(\"unlockPuzzleLocks\");`;\r\n                touched.push(\"thisBot.unlockTouched();\");\r\n                break;\r\n            case \"winTile\":\r\n                tagsToAdd.winTile = true;\r\n                tagsToAdd.ignoreTouch = false;\r\n                tagsToAdd.winTileTouched = tags.winTileTouched;\r\n                touched.push(\"thisBot.winTileTouched(that);\")\r\n                tagsToAdd.collectablesCheck = tags.collectablesCheck;\r\n                gameStart.push(\"thisBot.collectablesCheck();\");\r\n                tagsToAdd.allCollectablesGotten = `@ masks.color = null; masks.ignoreTouch = null;`;\r\n\r\n                break;\r\n            case \"moveUpDown\":\r\n                tagsToAdd.move = tags.moveTile;\r\n                tagsToAdd.moveUpDown = tags.moveUpDown;\r\n                tagsToAdd.moveAllowed = false;\r\n                gameStart.push(`setTagMask(thisBot, \"moveAllowed\", uuid(), \"shared\");`);\r\n                gameStart.push(`thisBot.moveUpDown({ direction:'up', uuid: tags.moveAllowed });`);\r\n                levelComplete.push(`setTagMask(thisBot, \"moveAllowed\", false, \"shared\");`);\r\n                break;\r\n            case \"moveLeftRight\":\r\n                tagsToAdd.move = tags.moveTile;\r\n                tagsToAdd.moveLeftRight = tags.moveLeftRight;\r\n                tagsToAdd.moveAllowed = false;\r\n                gameStart.push(`setTagMask(thisBot, \"moveAllowed\", uuid(), \"shared\");`);\r\n                gameStart.push(\"thisBot.moveLeftRight({ direction: 'left', uuid: tags.moveAllowed });\");\r\n                levelComplete.push(`setTagMask(thisBot, \"moveAllowed\", false, \"shared\");`);\r\n                break;\r\n            case \"harmful\":\r\n                tagsToAdd.harmfulTouched = `@ whisper(that, \"hide\");`;\r\n                tagsToAdd.harmfulTile = true;\r\n                touched.push(\"thisBot.harmfulTouched(that);\");\r\n                break;\r\n            case \"playerSpawnpoint\":\r\n                tagsToAdd.timeAdded = os.isCollaborative() ? os.agreedUponTime : os.localTime;\r\n                tagsToAdd.countAsPlayer = true;\r\n                tagsToAdd.playerSpawnerTile = true;\r\n                tagsToAdd.spawnPlayerBot = tags.spawnPlayerBot;\r\n                tagsToAdd.removePlayerBot = `@ shout(\"tempPlayerBotRemove\");`;\r\n                tagsToAdd.gameBoard = tags.gameBoard;\r\n                tagsToAdd.getOffset = tags.getOffset;\r\n                tagsToAdd.spawnPlayerSelector = tags.playerSelector;\r\n                gameStart.push(\"thisBot.spawnPlayerBot();\");\r\n                gameStart.push(`setTagMask(thisBot, \"home\", false, \"shared\");`)\r\n                gameEnd.push(\"thisBot.removePlayerBot();\");\r\n                gameEnd.push(\"shout('removePlayerSelector');\");\r\n                break;\r\n            case \"paired\":\r\n                tagsToAdd.timeAdded = os.isCollaborative() ? os.agreedUponTime : os.localTime;\r\n                tagsToAdd.pairType = \"portal\";\r\n                tagsToAdd.pairUp = tags.pairUp;\r\n                gameStart.push(\"thisBot.pairUp();\");\r\n                break;\r\n            case \"teleporter\":\r\n                tagsToAdd.teleporterTouched = tags.teleporterTouched;\r\n                touched.push(\"thisBot.teleporterTouched(that);\");\r\n                break;\r\n            case \"collectable\":\r\n                tagsToAdd.collectableTile = true;\r\n                tagsToAdd.hideTile = tags.hideTile;\r\n                tagsToAdd.collectableTouched = tags.collectableTouched;\r\n                touched.push(\"thisBot.collectableTouched(that);\");\r\n                break;\r\n            case \"pressurePlate\":\r\n                tagsToAdd.pressurePlate = true;\r\n                tagsToAdd.active = false;\r\n                touched.push(`shout(\"unlockPressureDoors\");`);\r\n                left.push(`shout(\"lockPressureDoors\");`);\r\n                break;\r\n            case \"pressureDoor\":\r\n                tagsToAdd.pressureDoor = true;\r\n                tagsToAdd.maskTileProperties = tags.maskTileProperties;\r\n                tagsToAdd.unlockPressureDoors = tags.hideTile;\r\n                tagsToAdd.lockPressureDoors = `@ masks.home = null; masks.formAddress = null; thisBot.maskTileProperties({ property: \"passable\", value: false })`;\r\n                break;\r\n            case \"pushable\":\r\n                tagsToAdd.tilePushed = tags.tilePushed;\r\n                tagsToAdd.move = tags.moveTile;\r\n                touched.push(\"thisBot.tilePushed(that);\");\r\n                break;\r\n            default:\r\n                console.log(`Tile Property ${prop} is not currently supported.`)\r\n                break;\r\n        }\r\n    }\r\n\r\n    return tileFunctions;\r\n}\r\n","abIDOrigin":"puzzleExplorer","collectableTouched":"@console.log(\"collectable touched that: \", that)\r\n\r\nif (tags.home == tru    \r\n    if (that.tags.playerTile == true) {\r\n        shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"collectablePickup\" });\r\n\r\n        thisBot.hideTile();\r\n\r\n        await os.sleep(10);\r\n\r\n        let collectablesLeft = 0;\r\n\r\n        getBots(b => {\r\n            if (b.tags.collectableTile == true && b.tags.tileCopy == true && b.tags.home == true) {\r\n                collectablesLeft++;\r\n            }\r\n        })\r\n\r\n        console.log(\"collectables left: \", collectablesLeft)\r\n\r\n        if (collectablesLeft == 0) {\r\n            shout(\"allCollectablesGotten\");\r\n            console.log(\"all collectables gotten\")\r\n        }\r\n    }\r\n    else if (that.tags.harmfulTile == true) {\r\n        thisBot.hideTile();\r\n        await os.sleep(100);\r\n        shout(\"restartPuzzle\");\r\n    }\r\n}","collectablesCheck":"@let collectables = getBots(byTag(\"collectableTile\", true), byTag(\"tileCopy\", true)); \r\n\r\nif(collectables.length > 0){\r\n    setTagMask(thisBot, \"ignoreTouch\", true, \"shared\");\r\n    setTagMask(thisBot, \"color\", \"grey\", \"shared\");\r\n}","dragControls":"@let xCoord = Math.round(that.to.x * 100)/100;\r\nlet yCoord = Math.round(that.to.y * 100)/100;\r\n\r\nlet currX = tags.homeX;\r\nlet currY = tags.homeY;\r\n\r\nlet up = xCoord == currX && yCoord == currY+1;\r\nlet down = xCoord == currX && yCoord == currY-1;\r\nlet left = yCoord == currY && xCoord == currX-1;\r\nlet right = yCoord == currY && xCoord == currX+1;\r\n\r\nif(up){\r\n    thisBot.onKeyDown({ keys: [\"w\"] })\r\n    // thisBot.move(\"up\");\r\n}\r\nif(down){\r\n    thisBot.onKeyDown({ keys: [\"s\"] })\r\n    // thisBot.move(\"down\");\r\n}\r\nif(left){\r\n    thisBot.onKeyDown({ keys: [\"a\"] })\r\n    // thisBot.move(\"left\");\r\n}\r\nif(right){\r\n    thisBot.onKeyDown({ keys: [\"d\"] })\r\n    // thisBot.move(\"right\");\r\n}","gameBoard":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","getOffset":"@if(links.gameBoard){\r\n    return {\r\n        x: Math.round((links.gameBoard.tags.homeX - 0.5)*100)/100,\r\n        y: Math.round((links.gameBoard.tags.homeY - 0.5)*100)/100\r\n    }\r\n}\r\nelse {\r\n    console.error(\"Game board not found. Unable to find offset.\")\r\n}","getRandomColor":"@const h = Math.floor(Math.random() * 360);\r\nconst s = 100;\r\nconst l = 60 + Math.random() * 20;\r\n\r\nconst a = s * Math.min(l / 100, 1 - l / 100) / 100;\r\nconst f = n => {\r\n    const k = (n + h / 30) % 12;\r\n    const color = l / 100 - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);\r\n    return Math.round(255 * color).toString(16).padStart(2, '0');\r\n};\r\n\r\nreturn `#${f(0)}${f(8)}${f(4)}`;","hideTile":"@tags.lock ? thisBot.lock() : null; \r\ntags.moveAllowed ? setTagMask(thisBot, \"moveAllowed\", false, \"shared\") : null;\r\ntags.toggleAsset ? setTagMask(thisBot, \"formAddress\", tags.toggleAsset, \"shared\") : setTagMask(thisBot, \"home\", false, \"shared\");\r\n// setTagMask(thisBot, \"touched\", \"@\", \"shared\");\r\n\r\n// setTagMask(thisBot, \"homeX\", 99, \"shared\");\r\n// setTagMask(thisBot, \"homeY\", 99, \"shared\");\r\n\r\nlet tempProps = tags.tileProperties; \r\ntempProps.passable = true; \r\nsetTagMask(thisBot, \"tileProperties\", tempProps, \"shared\");","lockControls":"@setTagMask(thisBot, \"onKeyDown\", \"@\", \"shared\");\r\nsetTagMask(thisBot, \"onDragging\", \"@\", \"shared\");","maskTileProperties":"@let tempTileProperties = tags.tileProperties;\r\nlet thatForm = Array.isArray(that) ? \"array\" : \"object\";\r\n\r\nif (tempTileProperties && that) {\r\n    if (Array.isArray(that)) {\r\n        for(const entry of that){\r\n            tempTileProperties[entry.property] = entry.value;\r\n        }\r\n    }\r\n    else {\r\n        tempTileProperties[that.property] = that.value;\r\n    }\r\n\r\n    setTagMask(thisBot, \"tileProperties\", tempTileProperties, \"shared\");\r\n}","moveLeftRight":"@let direction = that.direction;\r\n\r\nawait os.sleep(1000);\r\n\r\nlet startPos = {\r\n    x: tags.homeX,\r\n    y: tags.homeY\r\n}\r\n\r\nif (tags.mode == \"play\" && tags.moveAllowed == that.uuid) {\r\n    await thisBot.move(direction);\r\n\r\n    let xCheck = startPos.x == tags.homeX;\r\n    let yCheck = startPos.y == tags.homeY;\r\n\r\n    if (xCheck && yCheck) {\r\n        direction = direction == \"left\" ? \"right\" : \"left\";\r\n        await thisBot.move(direction)\r\n    }\r\n\r\n    thisBot.moveLeftRight({direction: direction, uuid: that.uuid})\r\n}\r\n\r\n// tags.mode == \"play\" ? thisBot.moveLeftRight({direction: direction, uuid: that.uuid}) : null;","moveTile":"@let xMod = 0;\r\nlet yMod = 0;\r\n\r\nconst offset = await thisBot.getOffset();\r\n\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y;\r\n\r\nswitch (that) {\r\n    case \"up\":\r\n        tags.homeY < yMax ? yMod = 1 : null;\r\n        break;\r\n    case \"down\":\r\n        tags.homeY > yMin ? yMod = -1 : null;\r\n        break;\r\n    case \"left\":\r\n        tags.homeX > xMin ? xMod = -1 : null;\r\n        break;\r\n    case \"right\":\r\n        tags.homeX < xMax ? xMod = 1 : null;\r\n        break;\r\n}\r\n\r\nif(xMod == 0 && yMod == 0){\r\n    return;\r\n}\r\n\r\nlet targX = tags.homeX + xMod;\r\nlet targY = tags.homeY + yMod;\r\n\r\nlet passable = true;\r\nlet touchedBots = [];\r\ngetBots(b => {\r\n    if (b.tags.tileCopy) {\r\n        let botX = b.masks.homeX ? b.masks.homeX : b.tags.homeX;\r\n        let botY = b.masks.homeY ? b.masks.homeY : b.tags.homeY;\r\n\r\n        if (botX == targX && botY == targY) {\r\n            let tileProperties = getTag(b, \"tileProperties\");\r\n            tileProperties.passable == true || tileProperties.player == true ? touchedBots.push(b.id) : passable = false;\r\n            let bHeight = getTag(b, \"homeZ\");\r\n            if(bHeight >= tags.homeZ){\r\n                setTagMask(thisBot, \"homeZ\", bHeight + 0.01, \"shared\");\r\n            }\r\n            whisper(b, \"touched\", thisBot);\r\n        }\r\n    }\r\n})\r\n\r\nconsole.log(\"touchedBots\", touchedBots);\r\n\r\nif (passable) {\r\n    tags.touching ? whisper(tags.touching, \"left\") : null;\r\n    setTagMask(thisBot, \"homeX\", targX, \"shared\");\r\n    setTagMask(thisBot, \"homeY\", targY, \"shared\");\r\n    setTagMask(thisBot, \"touching\", touchedBots, \"shared\");\r\n}","moveUpDown":"@let direction = that.direction;\r\n\r\nawait os.sleep(1000);\r\n\r\nlet startPos = {\r\n    x: tags.homeX,\r\n    y: tags.homeY\r\n}\r\n\r\nif (tags.mode == \"play\" && tags.moveAllowed == that.uuid) {\r\n    await thisBot.move(direction);\r\n\r\n    let xCheck = startPos.x == tags.homeX;\r\n    let yCheck = startPos.y == tags.homeY;\r\n\r\n    if (xCheck && yCheck) {\r\n        direction = direction == \"up\" ? \"down\" : \"up\";\r\n        await thisBot.move(direction)\r\n    }\r\n\r\n    thisBot.moveUpDown({direction: direction, uuid: that.uuid})\r\n}\r\n\r\n// tags.mode == \"play\" ? thisBot.moveUpDown({direction: direction, uuid: that.uuid}) : null;","pairUp":"@let pairingBots = getBots(byTag(\"pairType\", tags.pairType));\r\n\r\npairingBots = pairingBots.sort((a, b) => a.tags.timeAdded - b.tags.timeAdded);\r\n\r\nlet pairIndex = pairingBots.findIndex(bot => bot.id === thisBot.id);\r\n\r\nif(pairIndex % 2 == 0){\r\n    if(pairIndex == pairingBots.length-1){\r\n        setTagMask(thisBot, \"color\", \"grey\", \"shared\");\r\n    }\r\n    else {\r\n        setTagMask(thisBot, \"pairedTile\", getLink(pairingBots[pairIndex+1]), \"shared\");\r\n    }\r\n}\r\nelse {\r\n    setTagMask(thisBot, \"pairedTile\", getLink(pairingBots[pairIndex-1]), \"shared\");\r\n}","playerMovement":"@// console.log(that.keys)\r\n\r\nlinks.playEdit ? null : tags.playEdit = getLink(getBot(byTag(\"system\", \"msPuzzleExplorer._playEdit\")));\r\n\r\nlet keyDown = that.keys[0];\r\nlet upCheck = keyDown.includes(\"ArrowUp\") || keyDown.toLowerCase() == \"w\";\r\nlet downCheck = keyDown.includes(\"ArrowDown\") || keyDown.toLowerCase() == \"s\";\r\nlet leftCheck = keyDown.includes(\"ArrowLeft\") || keyDown.toLowerCase() == \"a\";\r\nlet rightCheck = keyDown.includes(\"ArrowRight\") || keyDown.toLowerCase() == \"d\";\r\n\r\nconst offset = thisBot.getOffset();\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y;\r\n\r\nif(!tags.playerID){\r\n    links.playEdit.tags.currentPlayer ? tags.playerID = links.playEdit.tags.currentPlayer : null;\r\n}\r\n\r\nif (tags.playerTile && tags.mode == \"play\" && tags.playerID == configBot.id) {\r\n    masks.homeX ? null : setTagMask(thisBot, \"homeX\", tags.homeX, \"shared\");\r\n    masks.homeY ? null : setTagMask(thisBot, \"homeY\", tags.homeY, \"shared\");\r\n\r\n    if (upCheck) {\r\n        masks.homeY < yMax ? thisBot.move(\"up\") : null;\r\n        setTagMask(thisBot, \"homeRotationZ\", Math.PI, \"shared\");\r\n    }\r\n\r\n    if (downCheck) {\r\n        masks.homeY > yMin ? thisBot.move(\"down\") : null;\r\n        setTagMask(thisBot, \"homeRotationZ\", 0, \"shared\");\r\n    }\r\n\r\n    if (leftCheck) {\r\n        masks.homeX > xMin ? thisBot.move(\"left\") : null;\r\n        setTagMask(thisBot, \"homeRotationZ\", -Math.PI/2, \"shared\");\r\n    }\r\n\r\n    if (rightCheck) {\r\n        masks.homeX < xMax ? thisBot.move(\"right\") : null;\r\n        setTagMask(thisBot, \"homeRotationZ\", Math.PI/2, \"shared\");\r\n    }\r\n\r\n    shout(\"playerMoved\");\r\n}","playerSelector":"@let {\r\n    playerNumber,\r\n} = that;\r\n\r\nlet basePosition = {\r\n    x: -6,\r\n    y: 4\r\n}\r\n\r\nlet playerSelectorMods = {\r\n    space: \"shared\",\r\n    home: true,\r\n    homeX: basePosition.x,\r\n    homeY: basePosition.y - 2*(playerNumber-1),\r\n    basePosition: basePosition,\r\n    label: `Waiting on Player ${playerNumber}...`,\r\n    labelFontSize: 0.9,\r\n    color: \"grey\",\r\n    selectorNumber: playerNumber,\r\n    getOffset: tags.getOffset,\r\n    scaleX: 3,\r\n    scaleZ: 0.01,\r\n    system: \"playerSelectorButton.player\" + playerNumber,\r\n    resetTilesetPositions: `@ \r\n        const offset = thisBot.getOffset(); \r\n        tags.homeX = tags.basePosition.x + offset.x; \r\n        tags.homeY = tags.basePosition.x - (2*(tags.selectorNumber-1)) + offset.y;\r\n    `,\r\n    removePlayerSelector: `@ destroy(thisBot);`,\r\n    onClick: `@ \r\n        if(tags.linkedPlayer){\r\n            let playerBot = getBot(byID(tags.linkedPlayer));\r\n            setTagMask(playerBot, \"playerID\", null, \"shared\");\r\n            tags.label = \"Waiting on Player \" + tags.selectorNumber + \"...\";\r\n            tags.color = \"grey\";\r\n            tags.linkedPlayer = null;\r\n        }\r\n        else {\r\n            let playerBot = getBot(byTag(\"playerNumber\", tags.selectorNumber)); \r\n            setTagMask(playerBot, \"playerID\", configBot.id, \"shared\");\r\n            tags.linkedPlayer = playerBot.id;\r\n            tags.label = \"Player \" + tags.selectorNumber + \" Ready!\";\r\n            let playerColor = getTag(playerBot, \"labelFloatingBackgroundColor\");\r\n            tags.color = playerColor ? playerColor : \"green\";\r\n        }\r\n    `\r\n}\r\n\r\ncreate(playerSelectorMods);\r\n\r\ngetTag()","playerTouched":"@let tileProperties = getTag(that, \"tileProperties\");\r\n\r\nif(tileProperties){\r\n    if(tileProperties.harmful == true){\r\n        thisBot.hide();\r\n    }\r\n}","spawnPlayerBot":"@await os.sleep(50);\r\n\r\nif (tags.mode == \"play\") {\r\n\r\n    let spawnerBots = [];\r\n    let playerTile;\r\n\r\n    getBots(b => {\r\n        if(b.tags.system && b.tags.system == \"msPuzzleExplorer.playerSpawn\"){\r\n            playerTile = b;\r\n        }\r\n        else {\r\n            b.tags.playerSpawnerTile ? spawnerBots.push({ id: b.id, timeAdded: b.tags.timeAdded }) : null;\r\n        }\r\n    })\r\n\r\n    spawnerBots = spawnerBots.sort((a, b) => a.timeAdded - b.timeAdded);\r\n    let spawnerNumber = spawnerBots.findIndex(item => item.id === thisBot.id) + 1;\r\n    console.log(\"Spawner bots:\", spawnerBots, `BotID: ${bot.id}, Number: ${spawnerNumber}`,)\r\n\r\n    let extraModsProps = {\r\n        tempPlayerBotRemove: \"@ destroy(thisBot)\",\r\n        parentBot: thisBot.id,\r\n        // playerTouched: `@ destroy(thisBot)`,\r\n        onDestroy: `@ whisper(tags.parentBot, \"spawnPlayerBot\", { \"playerColor\": tags.labelFloatingBackgroundColor })`,\r\n        hide: `@ destroy(thisBot)`,\r\n        home: true,\r\n        playerNumber: spawnerNumber,\r\n        movementAngles: {\r\n            up: Math.PI,\r\n            down: 0,\r\n            left: -Math.PI/2,\r\n            right: Math.PI/2\r\n        },\r\n        directionKeys: {\r\n            up: \"w\",\r\n            down: \"s\",\r\n            left: \"a\",\r\n            right: \"d\"\r\n        },\r\n        controllerTouched: `@ \r\n            console.log(\"controllerTouched\",that);\r\n\r\n            if(!tags.playerID){\r\n                tags.playerID = links.playEdit.tags.currentPlayer;\r\n            }\r\n\r\n            if(that.user == tags.playerID){\r\n                thisBot.onKeyDown({ keys: [tags.directionKeys[that.direction]]})\r\n            }\r\n        `,\r\n        setCurrentPlayer: `@ console.log(\"setCurrentPlayer:\", that); tags.playerID = that;`\r\n    }\r\n\r\n    if(spawnerBots.length > 1){\r\n        extraModsProps.label = \"Player \" + spawnerNumber;\r\n        extraModsProps.labelPosition = \"floatingBillboard\";\r\n    }\r\n\r\n    if(that){\r\n        that.playerColor ? extraModsProps.labelFloatingBackgroundColor = that.playerColor : null;\r\n    }\r\n\r\n    shout(\"spawnTileCopy\", {\r\n        tile: playerTile,\r\n        position: { x: tags.homeX, y: tags.homeY, z: tags.homeZ ? tags.homeZ + 0.01 : 0.01 },\r\n        extraMods: extraModsProps\r\n    })\r\n\r\n    // thisBot.spawnPlayerSelector({ \"playerNumber\": spawnerNumber });\r\n    \r\n}","system":"msPuzzleExplorer._propertyHolder","teleporterTouched":"@if (links.pairedTile) {\r\n    let xPos = links.pairedTile.tags.homeX;\r\n    let yPos = links.pairedTile.tags.homeY;\r\n\r\n    shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"teleport\" });\r\n\r\n    await os.sleep(200);\r\n\r\n    setTagMask(that, \"homeX\", xPos, \"shared\");\r\n    setTagMask(that, \"homeY\", yPos, \"shared\");\r\n\r\n\r\n}","tilePushed":"@const playerCheck = that.tags.playerTile && that.tags.playerTile == true ? true : false;\r\n\r\nif(playerCheck){\r\n    const playerX = that.tags.homeX;\r\n    const playerY = that.tags.homeY;\r\n    const thisX = tags.homeX;\r\n    const thisY = tags.homeY;\r\n\r\n    const dirX = thisX - playerX;\r\n    const dirY = thisY - playerY;\r\n\r\n    if(dirX == 0 && dirY == 1){\r\n        thisBot.move(\"up\");\r\n    }\r\n    else if(dirX == 0 && dirY == -1){\r\n        thisBot.move(\"down\");\r\n    }\r\n    else if(dirX == 1 && dirY == 0){\r\n        thisBot.move(\"right\");\r\n    }\r\n    else if(dirX == -1 && dirY == 0){\r\n        thisBot.move(\"left\");\r\n    }\r\n}","winTileTouched":"@let playerTile = getTag(that, \"playerTile\");\r\n\r\nif (playerTile == true && tags.ignoreTouch == false) {\r\n    whisper(that, \"lock\");\r\n\r\n    let tempTileProperties = tags.tileProperties;\r\n    tempTileProperties.reached = true;\r\n    setTagMask(thisBot, \"tileProperties\", tempTileProperties, \"shared\");\r\n\r\n    let winTiles = {\r\n        reached: [],\r\n        remaining: []\r\n    };\r\n\r\n    getBots(b => {\r\n        let tileProperties = b.tags.tileProperties;\r\n        if (tileProperties) {\r\n            if (tileProperties.winTile == true && b.tags.tileCopy == true) {\r\n                tileProperties.reached == true ? winTiles.reached.push(b) : winTiles.remaining.push(b);\r\n            }\r\n        }\r\n    })\r\n\r\n    let remainingGoals = winTiles.remaining.length;\r\n\r\n    if (remainingGoals == 0) {\r\n        shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"levelComplete\" });\r\n        shout(\"doSharedAction\", { actionType: \"showMessage\", actionData: \"Level Complete!\" });\r\n        shout(\"levelComplete\");\r\n        shout(\"resetBoardCopies\");\r\n        shout(\"onBoardStateChange\", \"edit\");\r\n        shout(\"onBoardStateChange\", \"play\");\r\n        // await os.sleep(10);\r\n        // shout(\"setCurrentPlayer\", configBot.id);\r\n    }\r\n    else {\r\n        shout(\"doSharedAction\", { actionType: \"playSound\", actionData: \"goalReached\" });\r\n        shout(\"doSharedAction\", { actionType: \"showToast\", actionData: `Goal collected! Only ${remainingGoals} more to go!` });\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2"}},"8af8567c-b178-4cc2-8cd9-c9bd471d4667":{"id":"8af8567c-b178-4cc2-8cd9-c9bd471d4667","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","hiddenTiles":"true","homeX":-3,"homeY":-7,"homeZ":0,"labelColor":"#1A1A1A","labelFontSize":"0.7","onDragging":"let xCoord = Math.round(that.to.x);\r\nlet yCoord = Math.round(that.to.y);\r\n\r\nlet currX = tags.homeX;\r\nlet currY = tags.homeY;\r\n\r\nlet up = xCoord == currX && yCoord == currY+1;\r\nlet down = xCoord == currX && yCoord == currY-1;\r\nlet left = yCoord == currY && xCoord == currX-1;\r\nlet right = yCoord == currY && xCoord == currX+1;\r\n\r\n// console.log(`up: ${up}`)\r\n// console.log(`down: ${down}`)\r\n// console.log(`left: ${left}`)\r\n// console.log(`right: ${right}`)\r\n\r\nif(up){\r\n    thisBot.onKeyDown({ keys: [\"w\"] })\r\n}\r\nif(down){\r\n    thisBot.onKeyDown({ keys: [\"s\"] })\r\n}\r\nif(left){\r\n    thisBot.onKeyDown({ keys: [\"a\"] })\r\n}\r\nif(right){\r\n    thisBot.onKeyDown({ keys: [\"d\"] })\r\n}","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2","system":"msPuzzleExplorer.playerSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"player\",\r\n    \"passable\": false,\r\n    \"player\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -3,\r\n        \"y\": -7\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/af6b6f509defc2101d571a7a8d914ecd49e1e94172ec48994a8d9fea2d9d592f.png","form":"sprite","scaleZ":"0.01"}},"9158b2fc-a34a-40c6-9010-8c1d9d4d6b31":{"id":"9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","boardState":"@switch(that){\r\n    case \"play\":\r\n        tags.formAddress = \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/61a533116b53f5a8eeb1c3d0993f9e057e7aaf5da49f2d77a5d19b55d076da66.png\";\r\n        break;\r\n    case \"edit\":\r\n        tags.formAddress = \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/ace4af49eecc6a1dd3b87a9535b6609de21828770d4bb3a58ecf9cdeed8f1c9d.png\";\r\n        break;\r\n}","controller":"ðŸ”—8024cdf1-efb1-4990-b2fb-40daf5dc668a","editImage":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/ace4af49eecc6a1dd3b87a9535b6609de21828770d4bb3a58ecf9cdeed8f1c9d.png","home":"true","homeX":"0.5","homeY":"0.5","onBoardStateChange":"@if(that == \"play\"){\n    tags.formAddress = tags.playImage;\n}\nelse if(that == \"edit\"){\n    tags.formAddress = tags.editImage;\n}","onBotChanged":"@const positionUpdate = that.tags.includes(\"homeX\") || that.tags.includes(\"homeY\") ? true : false;\r\n\r\nif(positionUpdate){\r\n    links.controller.setPEBotPositions();\r\n}","playImage":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/61a533116b53f5a8eeb1c3d0993f9e057e7aaf5da49f2d77a5d19b55d076da66.png","pointable":"false","scaleX":"8","scaleY":"8","scaleZ":"0.00001","system":"msPuzzleExplorer._board","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/ace4af49eecc6a1dd3b87a9535b6609de21828770d4bb3a58ecf9cdeed8f1c9d.png"}},"95537beb-5e70-4bc9-b214-4d400930424e":{"id":"95537beb-5e70-4bc9-b214-4d400930424e","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"msPuzzleExplorer._dirButtonRight","scaleZ":"0.01","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.form = \"sprite\";\r\n    tags.formAddress = \"https://auth-aux-dev-filesbucket-682397690660.s3.amazonaws.com/msTriangle20b2/02a0f3d98f9e944c430fc760b47ace45093cd48a8863516c1fd0847a000dd6f7.png\";\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.form = \"cube\";\r\n    tags.formAddress = null;\r\n}","onClick":"@if (tags.form != \"sprite\") {\r\n    links.playEdit.onClick();\r\n}\r\nelse {\r\n    shout(\"controllerTouched\", {\r\n        user: configBot.id,\r\n        direction: \"right\",\r\n        button: thisBot.id\r\n    })\r\n}","homeZ":0,"draggable":"false","labelFontSize":"1","puzzleExplorer":"true","abVersion":"10.10","strokeColor":"black","abIDOrigin":"puzzleExplorer","homeY":"-6","setCurrentPlayer":"@// that == configBot.id ? masks.home = true : null","homeRotationZ":-1.5707963267948966,"onPointerEnter":"@tags.form == \"sprite\" ? tags.color = \"grey\" : null;","onPointerExit":"@tags.form == \"sprite\" ? tags.color = null : null;","onPointerDown":"@tags.form == \"sprite\" ? tags.color = \"#303030\" : null;","onPointerUp":"@thisBot.onPointerEnter();","onGridClick":"@tags.color = null;","homeX":"4","home":true,"controllerTouched":"@that == thisBot.id ? null : thisBot.onPointerExit();","form":"cube","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2"}},"9b0ffd55-5490-4f1e-95ab-639b73a97668":{"id":"9b0ffd55-5490-4f1e-95ab-639b73a97668","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"msPuzzleExplorer._dirButtonDown","scaleZ":"0.01","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.form = \"sprite\";\r\n    tags.formAddress = \"https://auth-aux-dev-filesbucket-682397690660.s3.amazonaws.com/msTriangle20b2/02a0f3d98f9e944c430fc760b47ace45093cd48a8863516c1fd0847a000dd6f7.png\";\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.form = \"cube\";\r\n    tags.formAddress = null;\r\n}","onClick":"@if (tags.form != \"sprite\") {\r\n    links.playEdit.onClick();\r\n}\r\nelse {\r\n    shout(\"controllerTouched\", {\r\n        user: configBot.id,\r\n        direction: \"down\",\r\n        button: thisBot.id\r\n    })\r\n}","homeZ":0,"draggable":"false","labelFontSize":"1","puzzleExplorer":"true","abVersion":"10.10","abIDOrigin":"puzzleExplorer","homeY":"-7","setCurrentPlayer":"@// that == configBot.id ? masks.home = true : null","homeRotationZ":3.141592653589793,"onPointerEnter":"@tags.form == \"sprite\" ? tags.color = \"grey\" : null;","onPointerExit":"@tags.form == \"sprite\" ? tags.color = null : null;","onPointerDown":"@tags.form == \"sprite\" ? tags.color = \"#303030\" : null;","onPointerUp":"@thisBot.onPointerEnter();","onGridClick":"@tags.color = null;","homeX":"3","home":true,"strokeColor":"black","controllerTouched":"@that.button == thisBot.id ? null : thisBot.onPointerExit();","form":"cube","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2"}},"a30ca871-92bf-4ac9-a4b0-2404f6004344":{"id":"a30ca871-92bf-4ac9-a4b0-2404f6004344","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeX":0,"homeY":-5,"homeZ":0,"labelColor":"#1A1A1A","labelFontSize":"0.75","pointable":"true","scaleZ":"0.01","system":"msPuzzleExplorer.pressurePlate","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"pressurePlate\",\r\n    \"passable\": true,\r\n    \"pressurePlate\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": 0,\r\n        \"y\": -5\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/3a07844936cbf9c7b7d2ee29928e17c612a2a020cbad894c5501388f7a5fcf77.png","form":"sprite"}},"ae431eed-a0ef-477c-815d-ebd2ee08878b":{"id":"ae431eed-a0ef-477c-815d-ebd2ee08878b","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.portalSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"portal\",\r\n    \"passable\": true,\r\n    \"teleporter\": true,\r\n    \"paired\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -1,\r\n        \"y\": -7\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/383cd58f34a7fa20f214295b23e218d03b16274bfcf53f139f9d38a809ae4d8b.png","form":"sprite","scaleZ":"0.01","homeY":-7,"homeX":-1,"homeZ":0.01}},"b3a0f5b7-5edb-4159-a5fa-edb88a772eae":{"id":"b3a0f5b7-5edb-4159-a5fa-edb88a772eae","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","system":"msPuzzleExplorer._dirButtonUp","scaleZ":"0.01","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.form = \"sprite\";\r\n    tags.formAddress = \"https://auth-aux-dev-filesbucket-682397690660.s3.amazonaws.com/msTriangle20b2/02a0f3d98f9e944c430fc760b47ace45093cd48a8863516c1fd0847a000dd6f7.png\";\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.form = \"cube\";\r\n    tags.formAddress = null;\r\n}","onClick":"@if (tags.form != \"sprite\") {\r\n    links.playEdit.onClick();\r\n}\r\nelse {\r\n    shout(\"controllerTouched\", {\r\n        user: configBot.id,\r\n        direction: \"up\",\r\n        button: thisBot.id\r\n    })\r\n}","homeZ":0,"draggable":"false","labelFontSize":"1","puzzleExplorer":"true","abVersion":"10.10","strokeColor":"black","abIDOrigin":"puzzleExplorer","homeX":"3","homeY":"-5","setCurrentPlayer":"@// that == configBot.id ? masks.home = true : null","onPointerEnter":"@tags.form == \"sprite\" ? tags.color = \"grey\" : null;","onPointerExit":"@tags.form == \"sprite\" ? tags.color = null : null;","onPointerDown":"@tags.form == \"sprite\" ? tags.color = \"#303030\" : null;","onPointerUp":"@thisBot.onPointerEnter();","onGridClick":"@tags.color = null;","home":true,"controllerTouched":"@that == thisBot.id ? null : thisBot.onPointerExit();","form":"cube","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2"}},"b8e83564-e8d3-4b6d-98e0-ce1f25066c20":{"id":"b8e83564-e8d3-4b6d-98e0-ce1f25066c20","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.8","system":"msPuzzleExplorer.enemyUpDownSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"enemyUpDown\",\r\n    \"passable\": true,\r\n    \"harmful\": true,\r\n    \"moveUpDown\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -3,\r\n        \"y\": -7\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/56077b9677a168207277c5d2e3e2770ce1a9eff92233a5a1f5dfb7a760ff5407.png","form":"sprite","scaleZ":"0.01","homeY":-7,"homeX":-3,"homeZ":0}},"bd4db66e-2298-41b5-a629-0205c1769acf":{"id":"bd4db66e-2298-41b5-a629-0205c1769acf","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"pieceCopies.spawnPointCopy","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"spawnPoint\",\r\n    \"passable\": true,\r\n    \"playerSpawnpoint\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -6,\r\n        \"y\": 4\r\n    },\r\n    \"maxCopies\": 1,\r\n    \"maxCopiesMessage\": \"There can only be 1 player at a time.\"\r\n}","puzzleExplorer":"true","abVersion":"10.10","scaleZ":"0.01","homeX":-3,"homeY":4,"formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeStartTile/6da7cbe043f4275f2965aa84c0b11d5d1bd9b0cb9104ef39b057dfe4c37ecc9e.png","form":"sprite","homeZ":0,"boardOffset":{"x":-3.5,"y":3.5},"spawnPointCopy":true,"copyType":"spawnPoint","tileCopy":true,"mode":"edit","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.mode = \"play\";\r\n    tags.gameStart ? thisBot.gameStart() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true, xPos: 0.5, yPos: -1.25, zoom: 18 }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners() : null;\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.mode = \"edit\";\r\n    tags.gameEnd ? thisBot.gameEnd() : null;\r\n    tags.setCameraVariables ? thisBot.setCameraVariables({ skipWait: true }) : null;\r\n    tags.hideTileSpawners ? thisBot.hideTileSpawners(false) : null;\r\n}","resetBoardCopies":"@ clearTagMasks(thisBot); masks.homeX = null; masks.homeY = null;","clearBoardCopies":"@ destroy(thisBot);","onDrag":"@if(tags.mode == \"play\"){ os.enableCustomDragging() }","onDrop":"@const fromX = Math.round(that.from.x * 100) / 100;\r\nconst fromY = Math.round(that.from.y * 100) / 100;\r\nconst toX = Math.round(that.to.x * 100) / 100;\r\nconst toY = Math.round(that.to.y * 100) / 100;\r\n\r\nconst offset = await thisBot.getOffset();\r\n\r\nconst xMin = -3 + offset.x;\r\nconst xMax = 4 + offset.x;\r\nconst yMin = -3 + offset.y;\r\nconst yMax = 4 + offset.y;\r\n\r\nconst coordCheck = (toX >= xMin && toX <= xMax) && (toY >= yMin && toY <= yMax);\r\n// const botCheck = !that.to.bot ? true : !that.to.bot.tags.tileProperties ? false : that.to.bot.tags.tileProperties.ground == true ? true : false;\r\nconst draggedBotCheck = that.dragBot.id == thisBot.id;\r\nconst playCheck = tags.mode == \"edit\";\r\n\r\nlet botCheck, vertOffset;\r\nif (!that.to.bot) { botCheck = true; }\r\nelse if (!that.to.bot.tags.tileProperties) { botCheck = false; }\r\nelse if (that.to.bot.tags.tileProperties.ground == true) { botCheck = true; vertOffset = that.to.bot.tags.homeZ + 0.01 ?? 0.01; }\r\nelse { botCheck = false; }\r\n\r\nif (draggedBotCheck) {\r\n    if (playCheck) {\r\n        if (coordCheck) {\r\n            if (botCheck) {\r\n                moveTileCopy(\"move\");\r\n            }\r\n            else {\r\n                moveTileCopy(\"stay\");\r\n            }\r\n        }\r\n        else if (tags.system == \"pieceCopies.goalCopy\" || tags.system == \"pieceCopies.spawnPointCopy\") {\r\n            moveTileCopy(\"stay\");\r\n        }\r\n        else {\r\n            destroy(thisBot);\r\n        }\r\n    }\r\n    else {\r\n        moveTileCopy(\"stay\");\r\n    }\r\n}\r\n\r\nfunction moveTileCopy(toFrom) {\r\n    let posX, posY;\r\n\r\n    if(toFrom == \"move\"){\r\n        posX = toX;\r\n        posY = toY;\r\n    }\r\n    else if (toFrom == \"stay\"){\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n    else {\r\n        posX = fromX;\r\n        posY = fromY;\r\n    }\r\n\r\n    tags.homeX = posX;\r\n    tags.homeY = posY;\r\n    tags.boardOffset = {\r\n        x: posX - links.gameBoard.tags.homeX,\r\n        y: posY - links.gameBoard.tags.homeY\r\n    }\r\n}","onClick":"@if (tags.mode == \"edit\") {\r\n    if (tags.homeRotationZ) {\r\n        if (tags.homeRotationZ < -4.6) {\r\n            tags.homeRotationZ = 0;\r\n        }\r\n        else {\r\n            tags.homeRotationZ -= Math.PI / 2;\r\n        }\r\n    }\r\n    else {\r\n        tags.homeRotationZ = -Math.PI / 2;\r\n    }\r\n}","gameBoard":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","getOffset":"@if(links.gameBoard){\r\n    return {\r\n        x: Math.round((links.gameBoard.tags.homeX - 0.5)*100)/100,\r\n        y: Math.round((links.gameBoard.tags.homeY - 0.5)*100)/100\r\n    }\r\n}\r\nelse {\r\n    console.error(\"Game board not found. Unable to find offset.\")\r\n}","resetBoardTilePositions":"@const xMask = tags.homeX;\r\nconst yMask = tags.homeY;\r\n\r\nthisBot.masks.homeX = null;\r\nthisBot.masks.homeY = null;\r\n\r\nconst xPos = tags.homeX;\r\nconst yPos = tags.homeY;\r\n\r\nconst xDiff = xMask - xPos;\r\nconst yDiff = yMask - yPos;\r\n\r\nconst offset = thisBot.getOffset();\r\nconst boardOffset = tags.boardOffset;\r\n\r\ntags.homeX = 0.5 + offset.x + boardOffset.x;\r\ntags.homeY = 0.5 + offset.y + boardOffset.y;\r\n\r\nsetTagMask(thisBot, \"homeX\", tags.homeX + xDiff, \"shared\");\r\nsetTagMask(thisBot, \"homeY\", tags.homeY + yDiff, \"shared\");","timeAdded":1759524745274.25,"countAsPlayer":true,"playerSpawnerTile":true,"spawnPlayerBot":"@await os.sleep(50);\r\n\r\nif (tags.mode == \"play\") {\r\n\r\n    let spawnerBots = [];\r\n    let playerTile;\r\n\r\n    getBots(b => {\r\n        if(b.tags.system && b.tags.system == \"msPuzzleExplorer.playerSpawn\"){\r\n            playerTile = b;\r\n        }\r\n        else {\r\n            b.tags.playerSpawnerTile ? spawnerBots.push({ id: b.id, timeAdded: b.tags.timeAdded }) : null;\r\n        }\r\n    })\r\n\r\n    spawnerBots = spawnerBots.sort((a, b) => a.timeAdded - b.timeAdded);\r\n    let spawnerNumber = spawnerBots.findIndex(item => item.id === thisBot.id) + 1;\r\n    console.log(\"Spawner bots:\", spawnerBots, `BotID: ${bot.id}, Number: ${spawnerNumber}`,)\r\n\r\n    let extraModsProps = {\r\n        tempPlayerBotRemove: \"@ destroy(thisBot)\",\r\n        parentBot: thisBot.id,\r\n        // playerTouched: `@ destroy(thisBot)`,\r\n        onDestroy: `@ whisper(tags.parentBot, \"spawnPlayerBot\", { \"playerColor\": tags.labelFloatingBackgroundColor })`,\r\n        hide: `@ destroy(thisBot)`,\r\n        home: true,\r\n        playerNumber: spawnerNumber,\r\n        movementAngles: {\r\n            up: Math.PI,\r\n            down: 0,\r\n            left: -Math.PI/2,\r\n            right: Math.PI/2\r\n        },\r\n        directionKeys: {\r\n            up: \"w\",\r\n            down: \"s\",\r\n            left: \"a\",\r\n            right: \"d\"\r\n        },\r\n        controllerTouched: `@ \r\n            console.log(\"controllerTouched\",that);\r\n\r\n            if(!tags.playerID){\r\n                tags.playerID = links.playEdit.tags.currentPlayer;\r\n            }\r\n\r\n            if(that.user == tags.playerID){\r\n                thisBot.onKeyDown({ keys: [tags.directionKeys[that.direction]]})\r\n            }\r\n        `,\r\n        setCurrentPlayer: `@ console.log(\"setCurrentPlayer:\", that); tags.playerID = that;`\r\n    }\r\n\r\n    if(spawnerBots.length > 1){\r\n        extraModsProps.label = \"Player \" + spawnerNumber;\r\n        extraModsProps.labelPosition = \"floatingBillboard\";\r\n    }\r\n\r\n    if(that){\r\n        that.playerColor ? extraModsProps.labelFloatingBackgroundColor = that.playerColor : null;\r\n    }\r\n\r\n    shout(\"spawnTileCopy\", {\r\n        tile: playerTile,\r\n        position: { x: tags.homeX, y: tags.homeY, z: tags.homeZ ? tags.homeZ + 0.01 : 0.01 },\r\n        extraMods: extraModsProps\r\n    })\r\n\r\n    // thisBot.spawnPlayerSelector({ \"playerNumber\": spawnerNumber });\r\n    \r\n}","removePlayerBot":"@ shout(\"tempPlayerBotRemove\");","spawnPlayerSelector":"@let {\r\n    playerNumber,\r\n} = that;\r\n\r\nlet basePosition = {\r\n    x: -6,\r\n    y: 4\r\n}\r\n\r\nlet playerSelectorMods = {\r\n    space: \"shared\",\r\n    home: true,\r\n    homeX: basePosition.x,\r\n    homeY: basePosition.y - 2*(playerNumber-1),\r\n    basePosition: basePosition,\r\n    label: `Waiting on Player ${playerNumber}...`,\r\n    labelFontSize: 0.9,\r\n    color: \"grey\",\r\n    selectorNumber: playerNumber,\r\n    getOffset: tags.getOffset,\r\n    scaleX: 3,\r\n    scaleZ: 0.01,\r\n    system: \"playerSelectorButton.player\" + playerNumber,\r\n    resetTilesetPositions: `@ \r\n        const offset = thisBot.getOffset(); \r\n        tags.homeX = tags.basePosition.x + offset.x; \r\n        tags.homeY = tags.basePosition.x - (2*(tags.selectorNumber-1)) + offset.y;\r\n    `,\r\n    removePlayerSelector: `@ destroy(thisBot);`,\r\n    onClick: `@ \r\n        if(tags.linkedPlayer){\r\n            let playerBot = getBot(byID(tags.linkedPlayer));\r\n            setTagMask(playerBot, \"playerID\", null, \"shared\");\r\n            tags.label = \"Waiting on Player \" + tags.selectorNumber + \"...\";\r\n            tags.color = \"grey\";\r\n            tags.linkedPlayer = null;\r\n        }\r\n        else {\r\n            let playerBot = getBot(byTag(\"playerNumber\", tags.selectorNumber)); \r\n            setTagMask(playerBot, \"playerID\", configBot.id, \"shared\");\r\n            tags.linkedPlayer = playerBot.id;\r\n            tags.label = \"Player \" + tags.selectorNumber + \" Ready!\";\r\n            let playerColor = getTag(playerBot, \"labelFloatingBackgroundColor\");\r\n            tags.color = playerColor ? playerColor : \"green\";\r\n        }\r\n    `\r\n}\r\n\r\ncreate(playerSelectorMods);\r\n\r\ngetTag()","gameStart":"@thisBot.spawnPlayerBot();\nsetTagMask(thisBot, \"home\", false, \"shared\");\n if(tags.animationIdle){ os.startFormAnimation(thisBot, tags.animationIdle, { loop: true }) };","gameEnd":"@thisBot.removePlayerBot();\nshout('removePlayerSelector');\n if(tags.animationIdle){ os.stopFormAnimation(thisBot) };"}},"d2c9082c-4c0a-4841-94c3-434207f08aed":{"id":"d2c9082c-4c0a-4841-94c3-434207f08aed","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","board":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","color":"#B5B5B5","draggable":"false","home":"false","homeX":-4,"homeY":-5,"homeZ":0,"label":"clear board","labelColor":"#1A1A1A","labelFontSize":"0.9","onClick":"@shout(\"onBoardStateChange\", \"edit\");\r\n\r\nawait os.sleep(50);\r\n\r\nshout(\"clearBoardCopies\");","playEdit":"ðŸ”—e35058c6-c90a-4a16-bbc6-59942faf6bd2","scaleZ":"0.01","system":"msPuzzleExplorer._clearBoard","puzzleExplorer":"true","abVersion":"10.10"}},"e35058c6-c90a-4a16-bbc6-59942faf6bd2":{"id":"e35058c6-c90a-4a16-bbc6-59942faf6bd2","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","board":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","draggable":"false","home":true,"homeZ":0,"labelFontSize":"0.9","onBoardStateChange":"@if(that == \"play\"){\r\n    tags.label = \"Edit\";\r\n    tags.labelOpacity = 0;\r\n    tags.form = \"mesh\";\r\n    tags.formSubtype = \"gltf\";\r\n    tags.formAddress = \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msPeKitIcon/e0d63fd42d9ae6bfe10fb06d557a157915071d91e0eaafab25dce173f14b3a24.bin\";\r\n    // tags.color = null;\r\n    tags.homeX = -2;\r\n    tags.homeY = -6.5;\r\n    tags.scaleZ = null;\r\n    tags.homeRotationX = -Math.PI/2;\r\n    tags.homeRotationZ = -Math.PI/2;\r\n\r\n    thisBot.createFiller();\r\n    tags.currentPlayer = configBot.id;\r\n}\r\nelse if(that == \"edit\"){\r\n    tags.label = \"Play\";\r\n    tags.labelOpacity = null;\r\n    tags.form = null;\r\n    tags.formSubtype = null;\r\n    tags.formAddress = null;\r\n    // tags.color = \"#E0E0E0\";\r\n    tags.homeX = 3;\r\n    tags.homeY = -6;\r\n    tags.scaleZ = 0.01;\r\n    tags.homeRotationX = null;\r\n    tags.homeRotationZ = null;\r\n\r\n    shout(\"resetBoardCopies\");\r\n}","onClick":"@// let gridImage = \"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/msUtilityFiles/961138f91bfe34c4e72836cd19b55b8eadac3925db83bd8e376b995e516958ca.png\";\r\n\r\nif(tags.label == \"Play\"){\r\n\r\n    const playerBots = [];\r\n    const winBots = [];\r\n\r\n    getBots(b => {\r\n        let playerTileCheck = b.tags.playerTile == true ? true : false;\r\n        let countAsPLayerCheck = b.tags.countAsPlayer == true ? true : false;\r\n        let winTileCheck = b.tags.winTile == true ? true : false;\r\n\r\n        if(playerTileCheck || countAsPLayerCheck){\r\n            playerBots.push(b);\r\n        }\r\n        if(winTileCheck){\r\n            winBots.push(b);\r\n        }\r\n    })\r\n\r\n    if(playerBots.length > 0 && winBots.length > 0){\r\n        let remotes = await os.remotes();\r\n\r\n        if(playerBots.length > remotes.length){\r\n            os.toast(\"Not enough players.\")\r\n        }\r\n        else if(winBots.length > playerBots.length){\r\n            os.toast(\"Too many goals. Max of 1 per player.\")\r\n        }\r\n        else {\r\n            shout(\"onBoardStateChange\", \"play\");\r\n            await os.sleep(100);\r\n            shout(\"setCurrentPlayer\", configBot.id);\r\n        }\r\n    }\r\n    else {\r\n        os.toast(\"At least 1 player and 1 goal needed.\");\r\n    }\r\n}\r\nelse if(tags.label == \"Edit\"){\r\n    shout(\"onBoardStateChange\", \"edit\");\r\n}","system":"msPuzzleExplorer._playEdit","puzzleExplorer":"true","abVersion":"10.10","createFiller":"@let fillerTags = {\r\n    space: \"shared\",\r\n    home: true,\r\n    homeX: 3,\r\n    homeY: -6,\r\n    scaleZ: 0.01,\r\n    onBoardStateChange: `@ that == \"edit\" ? destroy(thisBot) : null;`,\r\n    system: \"msPuzzleExplorer._dPadFiller\",\r\n    draggable: false\r\n}\r\n\r\ncreate(fillerTags);","currentPlayer":"e9e018bf-3344-4900-aa7e-59308f5936c4","onRemoteLeave":"@if(that == tags.currentPlayer){\r\n    tags.currentPlayer = null;\r\n}","onRemoteJoined":"@if(!tags.currentPlayer && tags.label == \"Edit\"){\r\n    tags.currentPlayer = that;\r\n}","label":"Play","homeX":3,"homeY":-6,"scaleZ":0.01}},"e3cafa1d-4afc-437a-ac41-3f56ff9848bc":{"id":"e3cafa1d-4afc-437a-ac41-3f56ff9848bc","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","color":"white","gameBoard":"ðŸ”—9158b2fc-a34a-40c6-9010-8c1d9d4d6b31","getOffset":"@if(links.gameBoard){\r\n    return {\r\n        x: Math.round((links.gameBoard.tags.homeX - 0.5)*100)/100,\r\n        y: Math.round((links.gameBoard.tags.homeY - 0.5)*100)/100\r\n    }\r\n}\r\nelse {\r\n    console.error(\"Game board not found. Unable to find offset.\")\r\n}","home":"false","homeX":1,"homeY":-11,"homeZ":0,"label":"+","onClick":"@let tileProperties = `ðŸ§¬{\r\n    \"tileType\": \"newTile\",\r\n    \"passable\": true,\r\n    \"lock\": false,\r\n    \"key\": false,\r\n    \"unlock\": false,\r\n    \"winTile\": false,\r\n    \"moveUpDown\": false,\r\n    \"moveLeftRight\": false,\r\n    \"harmful\": false,\r\n    \"playerSpawnpoint\": false,\r\n    \"paired\": false,\r\n    \"teleporter\": false,\r\n    \"collectable\": false,\r\n    \"pressurePlate\": false,\r\n    \"pressureDoor\": false,\r\n    \"pushable\": false,\r\n    \"spawnPosition\": {\r\n        \"x\": ${tags.homeX},\r\n        \"y\": ${tags.homeY}\r\n    }\r\n}`;\r\n\r\nlet offset = thisBot.getOffset();\r\n\r\nlet newPosMods = {\r\n    homeX: tags.homeX >= 3 + offset.x ? -3 + offset.x : tags.homeX + 2,\r\n    homeY: tags.homeX >= 3 + offset.x ? tags.homeY - 2 : tags.homeY\r\n}\r\n\r\ncreate(thisBot, newPosMods);\r\n\r\nawait os.sleep(50);\r\n\r\ntags.label = \"new tile\";\r\ntags.getOffset = null;\r\ntags.onClick = null;\r\ntags.gameBoard = null;\r\ntags.labelFontSize = 0.8;\r\ntags.tileProperties = tileProperties;","strokeColor":"#000000","system":"msPuzzleExplorer._addTileButton","puzzleExplorer":"true","abVersion":"10.10"}},"e9099258-d8dc-4db5-85b5-973a537ce825":{"id":"e9099258-d8dc-4db5-85b5-973a537ce825","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeY":-5,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.wallSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"wall\",\r\n    \"passable\": false,\r\n    \"spawnPosition\": {\r\n        \"x\": -3,\r\n        \"y\": -5\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/54ef8fe6110d87701620489d7214aa1c8aac376e53154fe7b004dfd7bdb80ddd.png","form":"sprite","scaleZ":"0.01","homeX":-3,"homeZ":0}},"efdfaf9a-3bac-4125-88b9-6212e4c1aa20":{"id":"efdfaf9a-3bac-4125-88b9-6212e4c1aa20","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"labelColor":"#1A1A1A","labelFontSize":"0.9","system":"msPuzzleExplorer.groundSpawn","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"ground\",\r\n    \"passable\": true,\r\n    \"ground\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -2,\r\n        \"y\": -5\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","scaleZ":"0.01","homeX":-2,"formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/e1297bd86f5fb39fbc732f29cefd5a4292dfec67eac24b194f298e7251561b05.png","form":"sprite","homeY":-5,"homeZ":0}},"f4e01d0c-1fe3-4eee-98ed-d019d47b548a":{"id":"f4e01d0c-1fe3-4eee-98ed-d019d47b548a","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"puzzleExplorer","home":true,"homeX":-1,"homeY":-5,"homeZ":0,"labelColor":"#1A1A1A","labelFontSize":"0.75","pointable":"true","system":"msPuzzleExplorer.pressureDoor","tileProperties":"ðŸ§¬{\r\n    \"tileType\": \"pressureDoor\",\r\n    \"passable\": false,\r\n    \"pressureDoor\": true,\r\n    \"spawnPosition\": {\r\n        \"x\": -1,\r\n        \"y\": -5\r\n    }\r\n}","puzzleExplorer":"true","abVersion":"10.10","formAddress":"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/8980607d-1ff6-4361-8d88-cf7e921f2be7/8052e55b928c549abe5591866128fd7a2e9e9b7157289eb821abf6c08099f7f2.png","form":"sprite","scaleZ":"0.01"}}}}