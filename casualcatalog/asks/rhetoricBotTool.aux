{"version":1,"state":{"4e896d2c-5ac3-4450-9e49-a8b1d1c32b07":{"id":"4e896d2c-5ac3-4450-9e49-a8b1d1c32b07","space":"shared","tags":{"creator":"34c3c210-5bf1-49cf-b151-ee2d07f0e673","abIDOrigin":"rhetoricBotTool","aiModel":"gpt-5-nano","audioChat":"false","clearBrain":"@// debug tool for resetting the rhetoric bot back to a starting state with the assistance of some helper bots\r\nlet brainBots = getBots(b=>{\r\n    if(b.tags.system == \"forceGraphBrain.brainstem\" || String(b.tags.system).includes(\"ms-forceGraph\") || b.tags.fgbNeuron == true || b.tags.system == \"ab.pattern.abXPBot\"){\r\n        return true;\r\n    }\r\n})\r\n\r\nconsole.log(\"brainBots\", brainBots)\r\n\r\ndestroy(brainBots)","clearLog":"@// debug tool for resetting the rhetoric bot back to a starting state with the assistance of some helper bots\r\nif (ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"hideConsole\");\r\n    ab.links.console.masks.open = null;\r\n}\r\n\r\nconst menuPortal = configBot.tags.menuPortal ?? \"menu\";\r\nmasks[menuPortal] = false;","clearQueues":"@// used to clear the audio and text queues when a user interupts the hume ai audio chat\r\nthisBot.masks.audioQueue && thisBot.masks.audioQueue.length > 0 ? thisBot.masks.audioQueue.length = 1 : null;\r\nthisBot.masks.textQueue && thisBot.masks.textQueue.length > 0 ? thisBot.masks.textQueue.length = 1 : null;\r\n\r\nos.cancelSound(thisBot.masks.activeSound);\r\n\r\nthisBot.masks.activeSound = null;","endAudioChat":"@// trigger when ending audio chat with hume ai\r\n\r\nconsole.log(\"audio chat end\");\r\nmasks.audioChat = false;\r\nshout(\"resetACLabel\");\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket) {\r\n    humeSocket.close(1000, 'User ended the chat');\r\n    delete thisBot.vars.humeSocket;\r\n}\r\n\r\ntry {\r\n    await os.endAudioRecording();\r\n} catch(e) {\r\n    console.warn(e);\r\n}","extractText":"@// used to extract the text from a given pdf file, before returning it as one big string\r\n\r\nconsole.log('loading pdfjs...');\r\nconst pdfjs = await import('https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/+esm');\r\nconsole.log('pdfjs:', pdfjs);\r\n\r\npdfjs.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.0.379/build/pdf.worker.mjs';\r\n\r\nconsole.log('loading tesseract...');\r\nconst tesseract = await import(\"https://cdn.jsdelivr.net/npm/tesseract.js@5.0.4/+esm\");\r\nconsole.log('tesseract:', tesseract);\r\n\r\nconst worker = await tesseract.createWorker('eng');\r\nconsole.log('worker:', worker);\r\n\r\nconst pdf = await pdfjs.getDocument({\r\n    data: that.data,\r\n    // disableFontFace: true,\r\n}).promise;\r\nconsole.log('pdf:', pdf);\r\n\r\nconst pageCount = pdf.numPages;\r\n\r\nconst canvas = new OffscreenCanvas(512, 512);\r\nconst context = canvas.getContext('2d');\r\n\r\n// let outputHtml = `<h1>${that.name} Text Content</h1>`;\r\n\r\nlet masterString = \"\";\r\nfor (let i = 1; i <= pageCount; i++) {\r\n    os.showHtml(`Parsing ${that.name} page #${i}...`);\r\n\r\n    const page = await pdf.getPage(i);\r\n    console.log(`page ${i}:`, page);\r\n\r\n    const scale = 2;\r\n    const viewport = page.getViewport({ scale: scale, });\r\n    canvas.width = viewport.width;\r\n    canvas.height = viewport.height;\r\n\r\n    const renderContext = {\r\n        canvasContext: context,\r\n        viewport: viewport\r\n    };\r\n\r\n    // Render the page to the offscreen canvas context.\r\n    await page.render(renderContext).promise;\r\n\r\n    const blob = await canvas.convertToBlob({ type: 'image/png' });\r\n\r\n    // os.download(blob, 'test.png', 'image/png');\r\n    const result = await worker.recognize(blob, undefined, 'text');\r\n    console.log('result:', result);\r\n\r\n    masterString += result.data.text;\r\n\r\n    // outputHtml += `<h2>Page ${i}</h2>`;\r\n    // outputHtml += `<p style=\"white-space: pre\">${result.data.text}</p>`;\r\n}\r\n\r\nos.hideHtml();\r\n// os.showHtml(outputHtml);\r\n\r\nreturn masterString;","form":"input","getActionResponse":"@// used to determine what rhetoric bot should do while in action mode\r\n\r\n// creates the prompt for the ai to determine what course of action to go with.\r\nlet actionPrompt = `Determine from the following message if a user wants any of the following options carried out: `;\r\nactionPrompt += ` PDF interpretation, 2D image generation, or other. User message: \"`;\r\nactionPrompt += that.message;\r\nactionPrompt += `\" Respond with a one word response corresponding to what they want:`\r\nactionPrompt += ` \"PDF\" for pdf interpretation,`;\r\nactionPrompt += ` \"IMG\" for 2D image generation,`;\r\nactionPrompt += ` or \"AB1\" for some other action.`\r\nactionPrompt += ` If a user wants you to make something for them, unless the mention making a picture or image, assume they don't want a 2D image.`\r\nactionPrompt += ` Anything other than a single word response that is \"PDF\", \"IMG\" or \"AB1\" is considered a failure.`\r\n\r\n// gets the action type from the ai model interpretting the user message\r\nlet actionType = await ai.chat(actionPrompt, {\r\n    preferredModel: tags.aiModel\r\n});\r\n\r\nconsole.log(\"action mode response: \", actionType);\r\n\r\nswitch (actionType) {\r\n    case \"PDF\":\r\n        thisBot.interpretPDF();\r\n        break;\r\n    case \"IMG\": // currently disabled from image generation until the ai.generateImage function is fixed.\r\n        thisBot.postMessage({ \"message\": \"Image generation is temporarily disabeled due to an issue. We hope to have the issue fixed soon.\", \"publicMessage\": false })\r\n        // thisBot.postMessage({ \"message\": \"Generating image...\", \"publicMessage\": false });\r\n        // const imageAddress = await ai.generateImage({\r\n        //     prompt: message,\r\n        // });\r\n        // const angle = Math.random() * 2 * Math.PI;\r\n        // const radius = 5;\r\n\r\n        // create({\r\n        //     space: \"shared\",\r\n        //     home: true,\r\n        //     homeX: (radius * Math.cos(angle)) + tags.homeX,\r\n        //     homeY: (radius * Math.sin(angle)) + tags.homeY,\r\n        //     scaleZ: 0.01,\r\n        //     scaleX: 3,\r\n        //     scaleY: 3,\r\n        //     formAddress: imageAddress\r\n        // })\r\n        break;\r\n    case \"AB1\":\r\n        let askBot = getBot(byTag(\"system\", \"ab.action.ask\"))\r\n        askBot.abCoreMenuAction({ message: that.message, menu: \"core\" });\r\n        break;\r\n}","getPDFNeurons":"@// used to turn the extracted text from a pdf file into FGB neurons to be a part of RB's memory\r\nlet topicPrompt = `You are an AI agent learning and adding topics to a force graph representation of your brain.`;\r\ntopicPrompt += `Here is the text of a pdf called ${that.name} given by a user: ${that.text}.`;\r\ntopicPrompt += ` Only Give me ONLY an array of objects to add to your knowledge pool based on the text of that pdf, with each object in the array matching the format of:`;\r\ntopicPrompt += ` [ { \"topic\": \"example_1\", \"linkedTopics\": [], \"stemConnected\": true, \"details\": \"details_string1\" }, { \"topic\": \"example_2\", \"linkedTopics\": [\"example_1\"], \"stemConnected\": false, \"details\": \"details_string2\" } ],`;\r\ntopicPrompt += ` where stemConnected is whether the topic extracted from the message should be connected to the core of your knowledge or not, and details is a string with details of the topic from the provided information.`;\r\ntopicPrompt += ` There should be at least one object with the name of the pdf, and all of the other objects in the array should be linked to that pdf name object.`;\r\ntopicPrompt += ` All topics should have at least one connection.`;\r\ntopicPrompt += ` Giving anything other than a javascript array of objects as described above is considered a failure.`;\r\n\r\nconsole.log(\"topic gathering prompt:\", topicPrompt);\r\n\r\nlet topicResponse = await ai.chat(topicPrompt, {\r\n    preferredModel: tags.aiModel\r\n})\r\n\r\nconsole.log(\"raw topicResponse\", topicResponse);\r\n\r\nreturn JSON.parse(topicResponse);","getResponse":"@// gets the ai chat response to a user's message in the chat\r\nlet responsePrompt = `You are an AI agent that responds to prompts only using information related to the following subjects and details: `;\r\nresponsePrompt += JSON.stringify(await links.brainLink.retrieveInformation());\r\nresponsePrompt += `. Respond to the following message from ${that.user}: \"${that.message}\".`;\r\n// responsePrompt += ``;\r\n\r\nlet responseResponse = await ai.chat(responsePrompt, {\r\n    preferredModel: tags.aiModel\r\n});\r\n\r\nconsole.log(\"raw responseResponse\", responseResponse);\r\n\r\nreturn responseResponse;","getSubjects":"@// takes a given user message and uses it to determine what information RB should add to itself\r\nlet topicPrompt = `You are an AI agent learning and adding topics to a force graph representation of your brain. Here are the subjects and their accompanying details you know right now: `;\r\ntopicPrompt += JSON.stringify(await links.brainLink.retrieveInformation());\r\ntopicPrompt += ` And here is a message sent by ${that.user} in a chat you're in: \"${that.message}\".`;\r\ntopicPrompt += ` Only Give me ONLY an array of objects to add to your knowledge pool based on their message, with each object in the array matching the format of:`;\r\ntopicPrompt += ` [ { \"topic\": \"example_1\", \"linkedTopics\": [], \"stemConnected\": true, \"details\": \"example details 1\" }, { \"topic\": \"example_2\", \"linkedTopics\": [\"example_1\"], \"stemConnected\": false, \"details\": \"example details 2\" } ],`;\r\ntopicPrompt += ` where stemConnected is whether the topic extracted from the message should be connected to the core of your knowledge or not, and details are strings of accopanying details for that topic found within the message.`;\r\ntopicPrompt += ` All topics should have at least one connection, either to other topics or to your information core.`;\r\ntopicPrompt += ` Giving anything other than a javascript array of objects as described above is considered a failure.`;\r\n\r\nconsole.log(\"topic gathering prompt:\", topicPrompt);\r\n\r\nlet topicResponse = await ai.chat(topicPrompt, {\r\n    preferredModel: tags.aiModel\r\n})\r\n\r\nconsole.log(\"raw topicResponse\", topicResponse);\r\n\r\nreturn JSON.parse(topicResponse);","getUpdatedDetails":"@// used to get any information a neuron should be updated with from user messages\r\nlet detailsPrompt = `You are an AI agent with a force graph representation of your brain. Here are the subjects and their accompanying details you know right now: `;\r\ndetailsPrompt += JSON.stringify(await links.brainLink.retrieveInformation());\r\ndetailsPrompt += ` And here is a message sent by ${that.user} in a chat you're in: \"${that.message}\".`;\r\ndetailsPrompt += ` Only Give me ONLY an array of objects to update your knowledge pool based on their message, with each object in the array matching the format of:`;\r\ndetailsPrompt += ` [ { \"topic\": \"example_1\", \"details\": \"example details 1\" }, { \"topic\": \"example_2\", \"details\": \"example details 2\" } ],`;\r\ndetailsPrompt += ` where \"topic\" is an existing topic you know, and \"details\" are the updated details of that topic, based on new information obtained from the user's message`;\r\ndetailsPrompt += ` You are allowed to return an empty array if there are not any new details to add to a topic. Details provided in each object should be noticeably updated with new information.`\r\ndetailsPrompt += `Returning anything other than an object array as described above is considered a failure.`;\r\n\r\nconsole.log(\"updating details prompt:\", detailsPrompt);\r\n\r\nlet detailsResponse = await ai.chat(detailsPrompt, {\r\n    preferredModel: tags.aiModel\r\n})\r\n\r\nconsole.log(\"raw detailsResponse\", detailsResponse);\r\n\r\nreturn JSON.parse(detailsResponse);","home":true,"importFGB":"@// used to import the force graph brain pattern\r\nlet eggParameters = {\r\n    brainDimension: \"home\",\r\n    exampleNeurons: false,\r\n    customNeurons: [],\r\n    debugMode: false,\r\n    hatcher: thisBot.id,\r\n    altBrain: thisBot.id,\r\n    neuronCopyHolder: thisBot.id,\r\n    fgSettings: {\r\n        \"gravity\": false,\r\n        \"linkDistance\": 3,\r\n        \"dimensions\": 3\r\n    }\r\n}\r\n\r\nlet hatchValues = {\r\n    abID: \"msForceGraphBrain\",\r\n    recordKey: \"6db28ddc-1835-4fb4-8ed3-5ccf26c02217\",\r\n    autoHatch: true,\r\n    eggParameters: eggParameters\r\n}\r\n\r\n// ab.links.search.hatch(hatchValues);\r\nlet dim = configBot.tags.gridPortal ?? \"home\";\r\nlet dimX = tags[dim + \"X\"] ? tags[dim + \"X\"] : tags.homeX ? tags.homeX : 0;\r\nlet dimY = tags[dim + \"Y\"] ? tags[dim + \"Y\"] : tags.homeY ? tags.homeY : 0;\r\n\r\nab.links.search.onLookupAskID({\r\n    askID: \"fgBrain\",\r\n    eggParameters: {\r\n        toolboxBot: tags.toolbox ?? \"\",\r\n        gridInformation: {\r\n            dimension: dim,\r\n            position: {\r\n                x: dimX,\r\n                y: dimY\r\n            }\r\n        },\r\n        ...eggParameters\r\n    },\r\n})","interpretPDF":"@// used to run the whole process of turning a pdf file into a knowledge inside of rb's brain\r\nthisBot.postMessage({ \"message\": \"Please submit the PDF.\", \"publicMessage\": false });\r\n\r\nawait os.sleep(3000);\r\n\r\nconst files = await os.showUploadFiles();\r\nconsole.log('files:', files);\r\n\r\nlet pdfFile = null;\r\n\r\nfor (let file of files) {\r\n    if (file.mimeType === 'application/pdf') {\r\n        pdfFile = file;\r\n        break;\r\n    }\r\n}\r\n\r\nif (!pdfFile) {\r\n    thisBot.postMessage({ \"message\": \"I'm sorry, that file wasn't a PDF.\", \"publicMessage\": false });\r\n    return;\r\n}\r\n\r\nconsole.log('pdfFile:', pdfFile);\r\n\r\nlet pdfString = await thisBot.extractText(pdfFile);\r\nconsole.log(\"pdf string\", pdfString);\r\n\r\nthisBot.rbThinking(true);\r\n\r\nlet pdfNeurons = await thisBot.getPDFNeurons({ name: pdfFile.name, text: pdfString});\r\n\r\nconsole.log(\"pdfNeurons\", pdfNeurons);\r\n\r\nlinks.brainLink.createFGBNeurons({ neuronMods: pdfNeurons, neuronsColor: \"white\" });\r\n\r\nthisBot.postMessage({ \"message\": \"Memory updated with PDF information.\", \"publicMessage\": true });\r\n\r\nthisBot.rbThinking(false);","linkBrain":"@// used to link rb up to their specific force graph brain\r\nconst brainLink = getLink(that);\r\ntags.brainLink = brainLink;\r\nthisBot.openABConsole();\r\nthisBot.setRBMenuState(\"chatInput\");\r\n\r\nconst brainOnClick = `@\r\n    configBot.tags.gridPortal = \"home\";\r\n`;\r\nsetTag(links.brainLink, \"onClick\", brainOnClick);","name":"chat bot 4e89","onABArtifactReconstitute":"@// currently unused, waiting for the artifact system to be ready\r\n\r\nconst { abArtifactName, abArtifactData } = that;\r\n\r\nif (abArtifactName !== tags.abArtifactName) {\r\n    // This reconstitute shout is not for us.\r\n    return;\r\n}\r\n\r\nif(abArtifactData.neuronCopy){\r\n    let startTime = Date.now();\r\n    let brainPresent = false;\r\n\r\n    while(brainPresent == false){\r\n        if(links.brainLink){\r\n            if(links.brainLink.tags.createFGBNeurons){\r\n                brainPresent = true;\r\n            }\r\n            else {\r\n                await os.sleep(200);\r\n            }\r\n        }\r\n        else {\r\n            await os.sleep(200);\r\n        }\r\n\r\n        if((Date.now() - startTime) > 5000){\r\n            break;\r\n        }\r\n    }\r\n\r\n    if(brainPresent){\r\n        links.brainLink.createFGBNeurons({ neuronMods: that.abArtifactData.neuronCopy, neuronsColor: \"white\" });\r\n    }\r\n    else {\r\n        console.error(\"FGB not found within time limit.\")\r\n    }\r\n}\r\n\r\n// links.brainLink.createFGBNeurons({ neuronMods: that.abArtifactData.neuronCopy });","onABCollectArtifactShards":"@// currently unused, waiting for the artifact system to be ready\r\n\r\nreturn {\r\n    neuronCopy: tags.neuronCopy\r\n};","onABConsoleLogMessageBotAdded":"@// used to interpret and handle a user inputting into the chat via a text or audio message and having RB respond accordingly\r\n\r\nconst messageBot = that.consoleLogMessageBot;\r\nconst botSpace = getTag(messageBot, \"space\");\r\nconst rbIgnoreMessage = getTag(messageBot, \"rbIgnoreMessage\");\r\nconst rbProcessMessage = getTag(messageBot, \"rbProcessMessage\");\r\nconst messageOrigin = getTag(messageBot, \"messageOrigin\");\r\nconst audioInput = getTag(messageBot, \"audioInput\");\r\n\r\nconst user = getTag(messageBot, \"name\");\r\nconst message = getTag(messageBot, \"message\");\r\nconst time = getTag(messageBot, \"timestamp\") ?? 0;\r\nconst timeNow = os.isCollaborative() ? os.agreedUponTime : os.localTime;\r\nconst timeDiff = Math.abs(timeNow - time);\r\nconst mode = tags.currentMode;\r\n\r\nconst ignoredMessage = rbProcessMessage != true || user == tags.name || message === \"Memory updated.\" || audioInput && tags.audioChat != true;\r\nconst selfMessage = user == tags.name;\r\nconst recentMessage = timeDiff < 1000;\r\n\r\n// console.log(\"currentTime:\", timeNow);\r\n// console.log(\"messageTime:\", time);\r\n// console.log(\"timeDiff:\", timeDiff);\r\n\r\n// console.log(\"ignoredMessage: \", ignoredMessage);\r\n// console.log(\"selfMessage: \", selfMessage);\r\n// console.log(\"recentMessage: \", recentMessage);\r\n\r\n// console.log(\"message bot\", that.consoleLogMessageBot);\r\n\r\nif (ignoredMessage) {\r\n    console.log(\"Message to ignore: \", messageBot);\r\n}\r\nelse if (selfMessage) {\r\n    console.log(\"RB Message:\", messageBot);\r\n    thisBot.rbThinking(false);\r\n}\r\nelse if (recentMessage) {\r\n    console.log(\"Non-casual.bot or self message detected:\", messageBot);\r\n    // console.log(\"message sender:\", user);\r\n\r\n    thisBot.rbThinking(true);\r\n\r\n\r\n    console.log(\"configBot id comparison: \", messageOrigin == configBot.id);\r\n\r\n    // console.log(\"current mode: \", mode);\r\n\r\n    if (mode == \"learning\" && (botSpace == \"tempLocal\" || (botSpace == \"shared\" && configBot.id === messageOrigin))) {\r\n        let pdfResponse = await ai.chat(`Determine from this message if a user wants you to read or interpret a pdf for them: \"${message}\". If yes, respond with only the word 'YES' exactly. If not, respond only with the word 'NO' exactly. Responding with anything other than YES or NO is considered a failure.`, {\r\n            preferredModel: tags.aiModel\r\n        })\r\n\r\n        console.log(\"pdf response: \", pdfResponse);\r\n\r\n        if (pdfResponse.toUpperCase() == \"YES\") {\r\n            await thisBot.interpretPDF();\r\n        }\r\n        else {\r\n            let subjectResponse = await thisBot.getSubjects({ user: user, message: message });\r\n            console.log(\"topicResponse\", subjectResponse);\r\n            links.brainLink.createFGBNeurons({ neuronMods: subjectResponse, neuronsColor: \"white\" });\r\n\r\n            let detailsResponse = await thisBot.getUpdatedDetails({ user: user, message: message });\r\n            links.brainLink.updateNeurons(detailsResponse);\r\n\r\n            thisBot.postMessage({ \"message\": \"Memory updated.\", \"publicMessage\": true });\r\n            thisBot.rbThinking(false);\r\n\r\n            const humeSocket = thisBot.vars.humeSocket;\r\n            // console.log(\"Hume Websocket: \", humeSocket);\r\n\r\n            if (audioInput && messageOrigin == configBot.id && humeSocket) {\r\n                await os.sleep(100);\r\n\r\n                const systemSettings = JSON.stringify(links.brainLink.retrieveInformation());\r\n                console.log(\"allowed_topics:\", systemSettings)\r\n\r\n                humeSocket.send(JSON.stringify({\r\n                    \"type\": \"session_settings\",\r\n                    \"variables\": {\r\n                        \"allowed_topics\": systemSettings,\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n    else if (mode == \"whisper\" && botSpace == \"tempLocal\") {\r\n        let responseResponse = await thisBot.getResponse({ user: user, message: message });\r\n        // console.log(\"responseResponse\", responseResponse);\r\n        thisBot.postMessage({ \"message\": responseResponse, \"publicMessage\": false });\r\n    }\r\n    else if (mode == \"shout\" && botSpace == \"shared\" && messageOrigin == configBot.id) {\r\n        let responseResponse = await thisBot.getResponse({ user: user, message: message });\r\n        // console.log(\"responseResponse\", responseResponse);\r\n        thisBot.postMessage({ \"message\": responseResponse, \"publicMessage\": true });\r\n    }\r\n    else if (mode == \"action\") {\r\n        await thisBot.getActionResponse({ message: message });\r\n        // console.log(\"action mode started\")\r\n        // let actionPrompt = `Determine from the following message if a user wants you to interpret a pdf or generate an image for them: `;\r\n        // actionPrompt += message;\r\n        // actionPrompt += ` If yes respond with \"PDF\" for pdf interpreting or \"IMG\" for image generation and nothing else. If not, respond with the single word \"AB1\" and nothing else.`;\r\n        // actionPrompt += ` Anything other than a single word response that is \"PDF\", \"IMG\" or \"AB1\" is considered a failure.`\r\n        // let actionType = await ai.chat(actionPrompt, {\r\n        //     preferredModel: tags.aiModel\r\n        // });\r\n        // console.log(\"action mode response: \", actionType)\r\n\r\n        // switch (actionType) {\r\n        //     case \"PDF\":\r\n        //         thisBot.interpretPDF();\r\n        //         break;\r\n        //     case \"IMG\":\r\n        //         thisBot.postMessage({\"message\": \"Image generation is temporarily disabeled due to an issue. We hope to have the issue fixed soon.\", \"publicMessage\": false})\r\n        //         // thisBot.postMessage({ \"message\": \"Generating image...\", \"publicMessage\": false });\r\n        //         // const imageAddress = await ai.generateImage({\r\n        //         //     prompt: message,\r\n        //         // });\r\n        //         // const angle = Math.random() * 2 * Math.PI;\r\n        //         // const radius = 5;\r\n\r\n        //         // create({\r\n        //         //     space: \"shared\",\r\n        //         //     home: true,\r\n        //         //     homeX: (radius * Math.cos(angle)) + tags.homeX,\r\n        //         //     homeY: (radius * Math.sin(angle)) + tags.homeY,\r\n        //         //     scaleZ: 0.01,\r\n        //         //     scaleX: 3,\r\n        //         //     scaleY: 3,\r\n        //         //     formAddress: imageAddress\r\n        //         // })\r\n        //         break;\r\n        //     case \"AB1\":\r\n        //         let askBot = getBot(byTag(\"system\", \"ab.action.ask\"))\r\n        //         askBot.abCoreMenuAction({ message: message, menu: \"core\" });\r\n        //         break;\r\n        // }\r\n    }\r\n\r\n    thisBot.rbThinking(false);\r\n}\r\nelse {\r\n    console.log(\"Message failed all other tests: \", messageBot)\r\n}\r\n\r\n","onAudioChunk":"@console.log(\"audio chunk recieved\")\r\n\r\nmasks.audioChat == \"loading\" ? masks.audioChat = true : null;\r\nshout(\"resetACLabel\");\r\n\r\nconst humeSocket = thisBot.vars.humeSocket;\r\n\r\nif(humeSocket && masks.audioChat == true) {\r\n    humeSocket.send(JSON.stringify({\r\n        data: await blobToBase64(that),\r\n        type: \"audio_input\"\r\n    }));\r\n}\r\n\r\nasync function blobToBase64(blob) {\r\n  // Read the Blob as an ArrayBuffer\r\n  const arrayBuffer = await blob.arrayBuffer();\r\n  \r\n  // Convert the ArrayBuffer to a Base64 string\r\n  const base64String = bytes.toBase64String(new Uint8Array(arrayBuffer), 'audio/wav');\r\n  \r\n  return base64String;\r\n}","onBotChanged":"@if(that.tags.includes(\"fgSettings\") && masks.fgSettingsUpdated != true){\r\n    let fgSettings = tags.fgSettings;\r\n    tags.fgSettings = null;\r\n    await os.sleep(1000);\r\n    tags.fgSettings = fgSettings;\r\n    setTagMask(thisBot, \"fgSettingsUpdated\", true, \"shared\");\r\n}","onClick":"@configBot.masks.menuPortal = null;\r\nthisBot.setRBMenuState(\"mainMenu\");\r\n\r\nif(tags.hideMemory == false && !configBot.tags.mapPortal){\r\n    links.brainLink.toggleNeurons(\"show\");\r\n    thisBot.updateFGSettings();\r\n}","onEggHatch":"@tags.name = \"chat bot \" + String(thisBot.id).substring(0, 4);\r\ntags.label = \"cb \" + String(thisBot.id).substring(0, 4);\r\n\r\nif (that.eggParameters) {\r\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n    tags.fgFX = dimensionX;\r\n    tags.fgFY = dimensionY;\r\n    tags.fgFZ = 0;\r\n}\r\n\r\nawait os.sleep(500);\r\n\r\nconfigBot.tags.menuPortal = \"rbMenu\";\r\n\r\nif (links.brainLink == null) {\r\n    thisBot.importFGB();\r\n    masks.abMenu = null;\r\n}\r\nelse {\r\n    thisBot.openABConsole();\r\n}\r\n\r\nif (!getBot(byTag(\"system\", \"tools.chatBot.chatBot\"))) {\r\n    const dim = configBot.tags.gridPortal;\r\n    const dimX = tags[dim + \"X\"];\r\n    const dimY = tags[dim + \"Y\"];\r\n\r\n    ab.links.search.onLookupAskID({\r\n        askID: \"chatBotTool\",\r\n        eggParameters: {\r\n            toolboxBot: tags.toolbox ?? \"\",\r\n            gridInformation: {\r\n                dimension: dim ?? \"home\",\r\n                position: {\r\n                    x: dimX ? dimX + 2 : 2,\r\n                    y: dimY ?? 0\r\n                }\r\n            },\r\n        },\r\n    })\r\n}\r\n\r\n// ab.links.search.onLookupAskID({askID: \"chatBotTool\"})","onGridClick":"@// configBot.tags.menuPortal = \"rbChatMenu\";\r\n\r\n// if(links.chatInput == null){\r\n//     thisBot.createChatInput();\r\n// }\r\n\r\n// thisBot.setRBMenuState(\"chatInput\");\r\nshout(\"resetRBMenu\");\r\nthisBot.openABConsole();\r\n\r\n// console.log(\"grid click test\");\r\n\r\ntags.hideMemory == false ? links.brainLink.toggleNeurons(\"hide\") : null;","onInstJoined":"@console.log(\"inst joined\")\r\nthisBot.openABConsole();","onKeyDown":"@if(that.keys.includes(\"p\")){\r\n    console.log(\"configID\", configBot.id)\r\n}","onRemoteData":"@if(that.name == \"stopThinking\"){\r\n    shout(\"rbThinkingReset\");\r\n}","onSubmit":"@if (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n\r\nlet username = \"user\";\r\n\r\nif (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n    username = authBot.tags.name;\r\n} else if (ab.links.console.masks.preferredName) {\r\n    username = ab.links.console.masks.preferredName;\r\n} else {\r\n    username = await os.showInput(\"\", {\r\n        title: \"What would you like me to call you?\"\r\n    });\r\n    ab.links.console.masks.preferredName = username;\r\n}\r\n\r\nmasks.menuItemText = \"\";\r\n\r\n\r\nab.log({message: that.text, name: username, space: \"shared\", rbIgnoreMessage: that.rbIgnoreMessage, messageOrigin: configBot.id, rbProcessMessage: true});","onSubmitPrivate":"@if (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n\r\nlet username = \"user\";\r\n\r\nif (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n    username = authBot.tags.name;\r\n} else if (ab.links.console.masks.preferredName) {\r\n    username = ab.links.console.masks.preferredName;\r\n} else {\r\n    username = await os.showInput(\"\", {\r\n        title: \"What would you like me to call you?\"\r\n    });\r\n    ab.links.console.masks.preferredName = username;\r\n}\r\n\r\nmasks.menuItemText = \"\";\r\n\r\nab.links.input.onChat({ message: that.text, rbIgnoreMessage: that.rbIgnoreMessage, messageOrigin: configBot.id, rbProcessMessage: true });\r\nab.log({ message: that.text, name: username, space: \"tempLocal\", rbIgnoreMessage: that.rbIgnoreMessage, messageOrigin: configBot.id, rbProcessMessage: true });","openABConsole":"@if (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n\r\nconst menuPortal = configBot.tags.menuPortal ?? \"rbInput\";\r\n\r\nif (!configBot.tags.menuPortal)\r\n{\r\n    configBot.tags.menuPortal = menuPortal;\r\n}\r\n\r\nconfigBot.tags.menuPortal = \"rbChatMenu\";","playQueuedAudio":"@console.log(\"playQueuedAudio triggered\", thisBot.vars.playingQueue)\r\n\r\nif (thisBot.vars.playingQueue)\r\n{\r\n    return;\r\n}\r\n\r\nthisBot.vars.playingQueue = true;\r\n\r\nwhile (thisBot.masks.audioQueue.length > 0)\r\n{\r\n    const activeAudio = thisBot.masks.audioQueue[0];\r\n    const activeText = thisBot.masks.textQueue[0];\r\n\r\n    thisBot.masks.audioQueue.splice(0, 1);\r\n    thisBot.masks.textQueue.splice(0,1);\r\n    if(thisBot.vars.playHumeAudio == true){\r\n        let soundId = os.playSound(activeAudio);\r\n        thisBot.masks.activeSound = soundId;\r\n        ab.log({ message: activeText, name: tags.name, space: \"shared\", rbIgnoreMessage: true, rbProcessMessage: true, messageOrigin: configBot.id });\r\n        \r\n        await os.sleep((getDuration(activeAudio) * 1000));\r\n        \r\n        thisBot.masks.activeSound = null;\r\n    }\r\n\r\n    // os.playSound(activeAudio);\r\n    // thisBot.masks.audioQueue.splice(0, 1);\r\n    // await os.sleep((getDuration(activeAudio) * 1000) + 500);\r\n\r\n    console.log(\"AUDIO QUEUE: \", thisBot.masks.audioQueue);\r\n}\r\n\r\nthisBot.vars.playingQueue = null;\r\n\r\nfunction base64ToArrayBuffer(base64) {\r\n    const binaryString = self.atob(base64.split(',')[1]);\r\n    const bytes = Uint8Array.from(binaryString, char => char.charCodeAt(0));\r\n    return bytes.buffer;\r\n}\r\n\r\nfunction getWavDuration(arrayBuffer) {\r\n    const view = new DataView(arrayBuffer);\r\n\r\n    // Check the \"RIFF\" identifier\r\n    if (view.getUint32(0, false) !== 0x52494646) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Check the \"WAVE\" identifier\r\n    if (view.getUint32(8, false) !== 0x57415645) {\r\n        throw new Error(\"Invalid WAV file\");\r\n    }\r\n\r\n    // Get the byte rate from the fmt subchunk\r\n    const byteRate = view.getUint32(28, true);\r\n\r\n    // Get the total number of bytes in the data subchunk\r\n    const dataChunkSize = view.getUint32(40, true);\r\n\r\n    // Calculate duration\r\n    const duration = dataChunkSize / byteRate;\r\n\r\n    return duration;\r\n}\r\n\r\nfunction getDuration(base64) {\r\n    var arrBuffer = base64ToArrayBuffer(base64);\r\n    return getWavDuration(arrBuffer);\r\n}\r\n\r\n","postMessage":"@if (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n\r\nlet username = tags.name;\r\n\r\nmasks.menuItemText = \"\";\r\n\r\nif (that.publicMessage == true) {\r\n    ab.log({message: that.message, name: username, space: \"shared\", rbProcessMessage: true, messageOrigin: configBot.id});\r\n} else {\r\n    ab.links.input.onChat({message: that.message});\r\n    ab.log({message: that.message, name: username, space: \"tempLocal\", rbProcessMessage: true, messageOrigin: configBot.id});\r\n}","queueAudio":"@// Required Parameters\r\nconst base64Audio = that;\r\n\r\n// Optional Parameters\r\n\r\nconst mimeType = \"audio/wav\"; // Adjust MIME type as needed\r\nconst dataURL = `data:${mimeType};base64,${base64Audio}`;\r\n\r\n// os.playSound(dataURL);\r\n\r\n// const audioObject = { audio: dataURL, timestamp: os.isCollaborative() ? os.agreedUponTime : os.localTime }\r\n\r\nthisBot.masks.audioQueue = thisBot.masks.audioQueue ? [...thisBot.masks.audioQueue].concat(dataURL) : [dataURL];\r\n\r\nthisBot.playQueuedAudio();\r\n\r\n// console.log(\"audio queue:\",thisBot.masks.audioQueue)","queueText":"@// Required Parameters\r\nconst text = that;\r\n\r\nthisBot.masks.textQueue = thisBot.masks.textQueue ? [...thisBot.masks.textQueue].concat(text) : [text];","rbThinking":"@shout(\"rbThinkingReset\");\r\nconfigBot.tags.menuPortal = \"rbMenu\";\r\n\r\nif (that == true) {\r\n    let thinkingMods = {\r\n        space: \"tempLocal\",\r\n        rbMenu: true,\r\n        rbMenuBot: true,\r\n        rbThinkingBot: true,\r\n        pairedRB: getLink(thisBot),\r\n        rbMenuSortOrder: 0,\r\n        rbThinkingReset: `@ destroy(thisBot)`,\r\n        color: \"#50E2F2\",\r\n        trackNum: 0,\r\n        labelAlignment: \"center\",\r\n        onCreate: `@\r\n                if(tags.styleModApplied == false){\r\n                let existingStyle = tags.menuItemStyle;\r\n                console.log(\"existingStyle\", existingStyle);\r\n                existingStyle.width = \"300px\";\r\n                existingStyle[\"align-self\"] = \"center\"\r\n                tags.menuItemStyle = existingStyle;\r\n                tags.styleModApplied = true;\r\n            }\r\n\r\n            if (tags.trackNum == 2)\r\n            {\r\n                tags.trackNum = 0;\r\n            }\r\n            else\r\n            {\r\n                tags.trackNum++;\r\n            }\r\n\r\n            tags.label = tags[\"label\"+tags.trackNum];\r\n            tags.formAddress = tags[\"form\"+tags.trackNum];\r\n\r\n            setTimeout(() => whisper(thisBot, \"onCreate\"), 500);`,\r\n        label0: thisBot.tags.name + ` is thinking.`,\r\n        label1: thisBot.tags.name + ` is thinking..`,\r\n        label2: thisBot.tags.name + ` is thinking...`,\r\n        form0: \"hourglass_bottom\",\r\n        form1: \"hourglass_top\",\r\n        form2: \"hourglass_bottom\",\r\n        loading: true,\r\n        styleModApplied: false,\r\n        system: \"rbMenuBot.thinking\",\r\n    };\r\n\r\n    if (!ab.links.menu) {\r\n        // Load abInterface skill if ab.links.menu is not available.\r\n        await ab.abAdapt('abInterface');\r\n    }\r\n\r\n    await ab.links.menu.abCreateMenuButton(thinkingMods);\r\n}\r\nelse if(that == false){\r\n    let remotes = await os.remotes();\r\n    sendRemoteData(remotes, \"stopThinking\");\r\n}","resetRB":"@whisper(thisBot, \"clearBrain\");\r\nwhisper(thisBot, \"clearLog\");\r\ntags.brainLink = null;\r\nshout(\"resetRBMenu\");\r\ntags.neuronCopy = null;\r\ntags.forceGraph = null;\r\ntags.fgSettings = null;\r\ntags.homeX = 0;\r\ntags.homeY = 0;\r\ntags.homeZ = 0;","setRBMenuState":"@if (!ab.links.menu) {\r\n    // Load abInterface skill if ab.links.menu is not available.\r\n    await ab.abAdapt('abInterface');\r\n}\r\n\r\nshout(\"resetRBMenu\");\r\n\r\nconst state = typeof that == \"string\" ? that : undefined;\r\nconst baseMenuMods = {\r\n    space: \"tempLocal\",\r\n    rbMenu: true,\r\n    rbMenuBot: true,\r\n    color: \"white\",\r\n    pairedRB: getLink(thisBot),\r\n    resetRBMenu: `@ destroy(thisBot)`,\r\n}\r\nconst menuItems = [];\r\n\r\nswitch (state) {\r\n    // case \"chatInput\":\r\n    //     let inputMods = {\r\n    //         form: \"input\",\r\n    //         formAddress: \"edit\",\r\n    //         label: \"Chat with everyone!\",\r\n    //         system: \"rbMenuBot.input\",\r\n    //         rbMenuSortOrder: 1,\r\n    //         onSubmit: tags.onSubmit\r\n    //     };\r\n    //     menuItems.push({ ...baseMenuMods, ...inputMods });\r\n    //     break;\r\n    case \"mainMenu\":\r\n        let modeDisplay = tags.currentMode == \"learning\" ? \"learn\" :\r\n            tags.currentMode == \"whisper\" ? \"direct message\" :\r\n                tags.currentMode == \"shout\" ? \"chat with everyone\" :\r\n                    tags.currentMode == \"sleep\" ? \"sleep\" : \"unknown\"\r\n        let rbModeMods = {\r\n            formAddress: \"arrow_right\",\r\n            label: `cb mode: ${modeDisplay}`,\r\n            // resetLabel: `@ \r\n            //     let mode\r\n            //     switch(getTag(links.pairedRB, \"currentMode\")){\r\n            //         case \"learning\":\r\n            //             mode = \"learn\";\r\n            //             break;\r\n            //         case \"whisper\":\r\n            //             mode = \"direct message\";\r\n            //             break;\r\n            //         case \"shout\":\r\n            //             mode = \"chat with everyone\";\r\n            //             break;\r\n            //         case \"action\":\r\n            //             mode = \"action\";\r\n            //             break;\r\n            //         default:\r\n            //             mode = \"sleep\";\r\n            //             break;\r\n            //     }\r\n            //     tags.label = \"cb mode: \" + mode\r\n            // `,\r\n            system: \"rbMenuBot.rbMode\",\r\n            rbMenuSortOrder: 1,\r\n            dropdownSortOrder: 1,\r\n            dropdownOptions: [\r\n                {\r\n                    label: \"sleep\",\r\n                    mode: \"sleep\",\r\n                    pairedRB: getLink(thisBot),\r\n                    system: \"rbMenuBot.sleepMode\",\r\n                    color: \"white\",\r\n                    onClick: `@ \r\n                        setTag(links.pairedRB, \"currentMode\", \"sleep\"); \r\n                        links.pairedRB.setRBMenuState(\"mainMenu\");\r\n                        links.pairedRB.updateVar({ varName: \"playHumeAudio\", varValue: false });\r\n                    `\r\n                },\r\n                {\r\n                    label: \"learn\",\r\n                    mode: \"learning\",\r\n                    pairedRB: getLink(thisBot),\r\n                    system: \"rbMenuBot.learningMode\",\r\n                    color: \"white\",\r\n                    onClick: `@ \r\n                        setTag(links.pairedRB, \"currentMode\", \"learning\"); \r\n                        links.pairedRB.setRBMenuState(\"mainMenu\");\r\n                    `\r\n                },\r\n                {\r\n                    label: \"direct message\",\r\n                    mode: \"whisper\",\r\n                    pairedRB: getLink(thisBot),\r\n                    system: \"rbMenuBot.whisperMode\",\r\n                    color: \"white\",\r\n                    onClick: `@ \r\n                        setTag(links.pairedRB, \"currentMode\", \"whisper\"); \r\n                        links.pairedRB.setRBMenuState(\"mainMenu\");\r\n                    `\r\n                },\r\n                {\r\n                    label: \"chat with everyone\",\r\n                    mode: \"shout\",\r\n                    pairedRB: getLink(thisBot),\r\n                    system: \"rbMenuBot.shoutMode\",\r\n                    color: \"white\",\r\n                    onClick: `@ \r\n                        setTag(links.pairedRB, \"currentMode\", \"shout\"); \r\n                        links.pairedRB.setRBMenuState(\"mainMenu\");\r\n                    `\r\n                }\r\n            ],\r\n        };\r\n        rbModeMods.dropdownOptions = rbModeMods.dropdownOptions.filter(option => option.mode != tags.currentMode);\r\n\r\n        let aiModelMods = {\r\n            formAddress: \"arrow_right\",\r\n            label: `model: ${tags.aiModel}`,\r\n            resetLabel: `@ tags.label = \"model: \" + getTag(links.pairedRB, \"aiModel\")`,\r\n            system: \"rbMenuBot.aiMenu\",\r\n            rbMenuSortOrder: 2,\r\n            dropdownSortOrder: 2,\r\n            dropdownOptions: [],\r\n        };\r\n        const modelArray = tags.aiModelOptions ?? [\r\n            \"gpt-5\",\r\n            \"gpt-5-nano\",\r\n            \"gpt-4.1\",\r\n            \"gpt-4o\",\r\n            \"gemini-2.5-pro\",\r\n            \"gemini-2.5-flash-light\",\r\n            \"claude-opus-4-1\",\r\n            \"claude-sonnet-4-0\"\r\n        ];\r\n        for (let i = 0; i < modelArray.length; i++) {\r\n            let aiModelSubMods = {\r\n                label: tags.aiModel == modelArray[i] ? `${modelArray[i]} (current)` : modelArray[i],\r\n                model: modelArray[i],\r\n                system: `rbMenuBot.aiModel${i}`,\r\n                onClick: `@ \r\n                    setTag(links.pairedRB, \"aiModel\", \"${modelArray[i]}\"); \r\n                    links.pairedRB.setRBMenuState(\"mainMenu\");\r\n                `\r\n            }\r\n            tags.aiModel == modelArray[i] ? null : aiModelMods.dropdownOptions.push({ ...baseMenuMods, ...aiModelSubMods });\r\n        };\r\n\r\n        let audioChatMods = {\r\n            formAddress: tags.audioChat == true ? \"check_box\" : \"check_box_outline_blank\",\r\n            label: `voice: ${tags.audioChat == true ? \"on\" : tags.audioChat == \"loading\" ? \"loading...\" : \"off\"}`,\r\n            resetACLabel: `@\r\n                let pairedOnOff = getTag(links.pairedRB, \"audioChat\");\r\n                let onOff = pairedOnOff == true ? \"on\" : pairedOnOff == \"loading\" ? \"loading...\" : \"off\"; \r\n                tags.label = \"voice: \" + onOff;\r\n                tags.formAddress = pairedOnOff == true ? \"check_box\" : \"check_box_outline_blank\";\r\n            `,\r\n            system: \"rbMenuBot.audioChat\",\r\n            rbMenuSortOrder: 3,\r\n            audioChat: tags.audioChat,\r\n            onClick: `@ \r\n                let speakingBots = getBots(byTag(\"audioChat\", true), byTag(\"rhetoricBotTool\", true));\r\n                console.log(\"speaking bots check:\", speakingBots, links.pairedRB)\r\n                if(speakingBots.length == 0 || (speakingBots.length == 1 && speakingBots[0].id == links.pairedRB.id)){\r\n                    let pairedOnOff = getTag(links.pairedRB, \"audioChat\");\r\n                    let onOffState = pairedOnOff == true ? true : pairedOnOff == \"loading\" ? \"loading\" : false;\r\n\r\n                    if(onOffState == true){\r\n                        links.pairedRB.endAudioChat();\r\n                    }\r\n                    else if(onOffState == false){\r\n                        links.pairedRB.startAudioChat();\r\n                    }\r\n                }\r\n                else {\r\n                    os.toast(\"Only one chat bot can speak at a time.\");\r\n                }\r\n            `,\r\n        };\r\n\r\n        let showMemoryMods = {\r\n            formAddress: tags.hideMemory ? \"check_box_outline_blank\" : \"check_box\",\r\n            label: \"show memory\",\r\n            system: \"rbMenuBot.showMemory\",\r\n            rbMenuSortOrder: 4,\r\n            onClick: `@ \r\n                if(configBot.tags.mapPortal){\r\n                    os.toast(\"Memory disabled while in the map portal.\");\r\n                }\r\n                else {\r\n                    tags.formAddress = links.pairedRB.tags.hideMemory ? \"check_box\" : \"check_box_outline_blank\"; \r\n                    setTag(links.pairedRB, \"hideMemory\", !links.pairedRB.tags.hideMemory);\r\n                    links.pairedRB.links.brainLink.toggleNeurons();\r\n                }\r\n            `\r\n        };\r\n\r\n        let askRBMods = {\r\n            form: \"input\",\r\n            label: `direct message cb ${String(thisBot.id).substring(0, 4)}`,\r\n            system: \"rbMenuBot.privateInput\",\r\n            rbMenuSortOrder: 5,\r\n            onSubmit: tags.onSubmitPrivate\r\n        };\r\n\r\n        menuItems.push({ ...baseMenuMods, ...rbModeMods });\r\n        menuItems.push({ ...baseMenuMods, ...aiModelMods });\r\n        menuItems.push({ ...baseMenuMods, ...audioChatMods });\r\n        menuItems.push({ ...baseMenuMods, ...showMemoryMods });\r\n        menuItems.push({ ...baseMenuMods, ...askRBMods });\r\n        break;\r\n    default:\r\n        // let defaultInputMods = {\r\n        //     form: \"input\",\r\n        //     formAddress: \"edit\",\r\n        //     label: \"Chat with everyone!\",\r\n        //     system: \"rbMenuBot.input\",\r\n        //     rbMenuSortOrder: 1,\r\n        //     onSubmit: tags.onSubmit\r\n        // };\r\n        // menuItems.push({ ...baseMenuMods, ...defaultInputMods });\r\n        console.log(\"Rhetoric Bot menu state not supported.\")\r\n        break;\r\n}\r\n\r\n// console.log(\"menuItems\", menuItems);\r\n\r\nfor (const item of menuItems) {\r\n    if (item.dropdownOptions) {\r\n        ab.links.menu.abCreateMenuDropdown(item);\r\n    }\r\n    else {\r\n        ab.links.menu.abCreateMenuButton(item);\r\n    }\r\n\r\n}\r\n\r\nconfigBot.tags.menuPortal == \"rbMenu\" ? null : configBot.tags.menuPortal = \"rbMenu\";","startAudioChat":"@// trigger when starting audio chat with hume\r\n\r\nconsole.log(\"audio chat start\");\r\nmasks.audioChat = \"loading\";\r\nshout(\"resetACLabel\");\r\n\r\nconst endpoint = \"wss://api.hume.ai/v0/evi/chat\";\r\nconst accessToken = (await ai.hume.getAccessToken()).accessToken;\r\nconst configID = \"e04b02d5-cb78-4292-aba4-a912d8926ddd\";\r\n\r\nconst url = new URL(endpoint);\r\nurl.searchParams.set(\"access_token\", accessToken);\r\nurl.searchParams.set(\"config_id\", configID);\r\n\r\nawait os.beginAudioRecording({\r\n    stream: true,\r\n    mimeType: 'audio/wav'\r\n});\r\n\r\nconst humeSocket = new WebSocket(url.toString());\r\nthisBot.vars.humeSocket = humeSocket;\r\nthisBot.vars.playingQueue = false;\r\n\r\nconst session_settings = {\r\n    \"type\": \"session_settings\",\r\n    \"variables\": {\r\n        \"name\": tags.name,\r\n        \"allowed_topics\": JSON.stringify(links.brainLink.retrieveInformation()),\r\n    }\r\n};\r\n\r\nhumeSocket.addEventListener('open', (event) => {\r\n    console.warn(\"Hume Socket opened: \", event);\r\n    // shout(\"onHumeWebSocketOpened\", event);\r\n    humeSocket.send(JSON.stringify(session_settings));\r\n\r\n    thisBot.clearQueues();\r\n\r\n    if ([\"learning\", \"whisper\", \"shout\"].includes(tags.currentMode)) {\r\n        thisBot.vars.playHumeAudio = true;\r\n    }\r\n});\r\n\r\nhumeSocket.addEventListener('close', (event) => {\r\n    console.warn(\"Hume Socket closed: \", event);\r\n    thisBot.endAudioChat();\r\n    // shout(\"onHumeChatEnded\", event);\r\n});\r\n\r\nhumeSocket.addEventListener('message', async (event) => {\r\n    const data = JSON.parse(event.data);\r\n\r\n    console.log(\"blueb\", data);\r\n\r\n    if (data.type == \"audio_output\") {\r\n        if ([\"learning\", \"whisper\", \"shout\"].includes(tags.currentMode)) {\r\n            thisBot.queueAudio(data.data);\r\n        }\r\n    }\r\n    else if (data.type == \"assistant_message\") {\r\n        if ([\"learning\", \"whisper\", \"shout\"].includes(tags.currentMode) && thisBot.vars.playHumeAudio == true) {\r\n            const message = data.message.content;\r\n            thisBot.queueText(message);\r\n            // ab.log({ message: message, name: tags.name, space: \"shared\", rbIgnoreMessage: true });\r\n        }\r\n    }\r\n    else if (data.type == \"error\") {\r\n        console.warn('error: ', data.message);\r\n    }\r\n    else if (data.type == \"user_message\") {\r\n        let username = \"user\";\r\n\r\n        if (authBot && authBot.tags.name && authBot.tags.name != \"\") {\r\n            username = authBot.tags.name;\r\n        } else if (ab.links.console.masks.preferredName) {\r\n            username = ab.links.console.masks.preferredName;\r\n        } else {\r\n            username = await os.showInput(\"\", {\r\n                title: \"What would you like me to call you?\"\r\n            });\r\n            ab.links.console.masks.preferredName = username;\r\n        }\r\n\r\n        const message = data.message.content;\r\n\r\n        ab.log({\r\n            message: message,\r\n            name: username,\r\n            space: \"shared\",\r\n            rbIgnoreMessage: tags.currentMode != \"learning\",\r\n            audioInput: true,\r\n            messageOrigin: configBot.id,\r\n            rbProcessMessage: tags.currentMode == \"learning\"\r\n        });\r\n\r\n        // thisBot.clearQueues();\r\n\r\n        if([\"learning\", \"whisper\", \"shout\"].includes(tags.currentMode)){\r\n            thisBot.vars.playHumeAudio = true;\r\n        }\r\n    }\r\n    else if (data.type == \"tool_call\") {\r\n        console.log(\"Tool called: \", data.name, data);\r\n        if(data.name == \"read_pdf\"){\r\n            thisBot.interpretPDF();\r\n        }\r\n    }\r\n    else if (data.type == \"user_interruption\") {\r\n        thisBot.clearQueues();\r\n\r\n        if ([\"learning\", \"whisper\", \"shout\"].includes(tags.currentMode)) {\r\n            thisBot.vars.playHumeAudio = true;\r\n        }\r\n    }\r\n    else {\r\n        console.log(\"unexpected message:\", data.type, data);\r\n    }\r\n});","startRB":"@thisBot.onEggHatch();","system":"msRhetoricBot.rhetoricBot","toggleRBSubmenu":"@const submenu = that.submenu;\r\nconst submenuBot = that.submenuBot;\r\n\r\n\r\nconst baseMods = {\r\n    space: \"tempLocal\",\r\n    rbMenu: true,\r\n    rbMenuBot: true,\r\n    rbSubmenu: submenu,\r\n    color: \"white\",\r\n    pairedRB: getLink(thisBot),\r\n    menuHeader: getLink(submenuBot),\r\n    resetRBMenu: `@ destroy(thisBot)`,\r\n    resetSubmenu: `@ destroy(thisBot)`,\r\n    labelAlignment: \"left\"\r\n};\r\n\r\nconst buttonStyles = {\r\n    topButton: {\r\n        \"border-radius\": \"8px 8px 0px 0px\",\r\n        \"margin-top\": \"8px\",\r\n        \"border-width\": \"2px\",\r\n        \"border-color\": \"#000\",\r\n        \"border-top-style\": \"solid\",\r\n        \"border-left-style\": \"solid\",\r\n        \"border-right-style\": \"solid\",\r\n        \"box-shadow\": \"3px 4px #000\",\r\n        \"min-height\": \"44px\"\r\n    },\r\n    middleButton: {\r\n        \"border-radius\": \"0\",\r\n        \"margin-top\": \"0px\",\r\n        \"border-width\": \"2px\",\r\n        \"border-color\": \"#000\",\r\n        \"border-top-style\": \"solid\",\r\n        \"border-left-style\": \"solid\",\r\n        \"border-right-style\": \"solid\",\r\n        \"box-shadow\": \"3px 4px #000\",\r\n        \"min-height\": \"44px\"\r\n    },\r\n    bottomButton: {\r\n        \"border-radius\": \"0 0 8px 8px\",\r\n        \"margin-top\": \"0px\",\r\n        \"border-width\": \"2px\",\r\n        \"border-color\": \"#000\",\r\n        \"border-top-style\": \"solid\",\r\n        \"border-left-style\": \"solid\",\r\n        \"border-right-style\": \"solid\",\r\n        \"box-shadow\": \"3px 4px #000\",\r\n        \"min-height\": \"44px\"\r\n    }\r\n}\r\n\r\nlet submenuBots = getBots(byTag(\"rbSubmenu\", submenu));\r\nlet botsToMake = [];\r\n\r\nif (submenuBots.length > 0) {\r\n    whisper(submenuBots, \"resetSubmenu\");\r\n    clearTagMasks(submenuBot);\r\n    whisper(submenuBot, \"resetLabel\");\r\n}\r\nelse if (submenu == \"aiModel\") {\r\n    const modelArray = tags.aiModelOptions ?? [\r\n        \"gpt-5\",\r\n        \"gpt-5-nano\",\r\n        \"gpt-4.1\",\r\n        \"gpt-4o\",\r\n        \"gemini-2.5-pro\",\r\n        \"gemini-2.5-flash-light\",\r\n        \"claude-opus-4-1\",\r\n        \"claude-sonnet-4-0\"\r\n    ];\r\n\r\n\r\n    for (let i = 0; i < modelArray.length; i++) {\r\n\r\n        const aiModelMods = {\r\n            label: tags.aiModel == modelArray[i] ? `${modelArray[i]} (current)` : modelArray[i],\r\n            model: modelArray[i],\r\n            system: `rbMenuBot.aiModel${getTag(submenuBot, \"rbMenuSortOrder\") + (0.1 * i)}`,\r\n            rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + (0.1 * i),\r\n            onClick: `@ setTag(links.pairedRB, \"aiModel\", \"${modelArray[i]}\"); links.pairedRB.toggleRBSubmenu({\"submenu\": \"aiModel\", submenuBot: links.menuHeader});`\r\n        }\r\n\r\n        tags.aiModel == modelArray[i] ? null : botsToMake.push({ ...baseMods, ...aiModelMods });\r\n    };\r\n\r\n    setTagMask(submenuBot, \"formAddress\", \"arrow_drop_down\", \"tempLocal\");\r\n    setTagMask(submenuBot, \"menuItemStyle\", buttonStyles.topButton, \"tempLocal\");\r\n}\r\nelse if (submenu == \"rbMode\") {\r\n    let sleepMods = {\r\n        label: tags.currentMode == \"sleep\" ? \"sleep (current)\" : \"sleep\",\r\n        formAddress: \"pause\",\r\n        system: \"rbMenuBot.sleepMode\",\r\n        rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + 0.1,\r\n        onClick: `@ \r\n            setTag(links.pairedRB, \"currentMode\", \"sleep\"); \r\n            links.pairedRB.toggleRBSubmenu({\"submenu\": \"rbMode\", submenuBot: links.menuHeader});\r\n            links.pairedRB.updateVar({ varName: \"playHumeAudio\", varValue: false });\r\n        `\r\n    };\r\n    let learningMods = {\r\n        label: tags.currentMode == \"learning\" ? \"learn (current)\" : \"learn\",\r\n        formAddress: \"school\",\r\n        system: \"rbMenuBot.learningMode\",\r\n        rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + 0.2,\r\n        onClick: `@ \r\n            setTag(links.pairedRB, \"currentMode\", \"learning\"); \r\n            links.pairedRB.toggleRBSubmenu({\"submenu\": \"rbMode\", submenuBot: links.menuHeader});\r\n            links.pairedRB.updateVar({ varName: \"playHumeAudio\", varValue: false });\r\n        `\r\n    };\r\n    let whisperMods = {\r\n        label: tags.currentMode == \"whisper\" ? \"Whisper Mode (current)\" : \"Whisper Mode\",\r\n        formAddress: \"question_answer\",\r\n        system: \"rbMenuBot.whisperMode\",\r\n        rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + 0.3,\r\n        onClick: `@ \r\n            setTag(links.pairedRB, \"currentMode\", \"whisper\"); \r\n            links.pairedRB.toggleRBSubmenu({\"submenu\": \"rbMode\", submenuBot: links.menuHeader});\r\n        `\r\n    };\r\n    let shoutMods = {\r\n        label: tags.currentMode == \"shout\" ? \"Shout Mode (current)\" : \"Shout Mode\",\r\n        formAddress: \"menu_book\",\r\n        system: \"rbMenuBot.shoutMode\",\r\n        rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + 0.4,\r\n        onClick: `@ \r\n            setTag(links.pairedRB, \"currentMode\", \"shout\"); \r\n            links.pairedRB.toggleRBSubmenu({\"submenu\": \"rbMode\", submenuBot: links.menuHeader});\r\n        `\r\n    };\r\n    let actionMods = {\r\n        label: tags.currentMode == \"action\" ? \"Action Mode (current)\" : \"Action Mode WIP\",\r\n        formAddress: \"hardware\",\r\n        system: \"rbMenuBot.actionMode\",\r\n        rbMenuSortOrder: getTag(submenuBot, \"rbMenuSortOrder\") + 0.5,\r\n        onClick: `@\r\n            setTag(links.pairedRB, \"currentMode\", \"action\");\r\n            links.pairedRB.toggleRBSubmenu({\"submenu\": \"rbMode\", submenuBot: links.menuHeader});\r\n        `\r\n    };\r\n\r\n    tags.currentMode == \"sleep\" ? null : botsToMake.push({ ...baseMods, ...sleepMods });\r\n    tags.currentMode == \"learning\" ? null : botsToMake.push({ ...baseMods, ...learningMods });\r\n    tags.currentMode == \"whisper\" ? null : botsToMake.push({ ...baseMods, ...whisperMods });\r\n    tags.currentMode == \"shout\" ? null : botsToMake.push({ ...baseMods, ...shoutMods });\r\n    tags.currentMode == \"action\" ? null : botsToMake.push({ ...baseMods, ...actionMods });\r\n\r\n    setTagMask(submenuBot, \"formAddress\", \"arrow_drop_down\", \"tempLocal\");\r\n    setTagMask(submenuBot, \"menuItemStyle\", buttonStyles.topButton, \"tempLocal\");\r\n}\r\n\r\nif (botsToMake.length > 0) {\r\n    for (let i = 0; i < botsToMake.length; i++) {\r\n        if (i == botsToMake.length - 1) {\r\n            create(botsToMake[i], { \"menuItemStyle\": buttonStyles.bottomButton })\r\n        }\r\n        else {\r\n            create(botsToMake[i], { \"menuItemStyle\": buttonStyles.middleButton })\r\n        }\r\n    }\r\n}","updateVar":"@const {\r\n    varName,\r\n    varValue\r\n} = that;\r\n\r\nthisBot.vars[varName] = varValue;","rhetoricBotTool":"true","abVersion":"10.10","onDrag":"@os.enableCustomDragging();","onDragging":"@tags.homeX = that.to.x;\r\ntags.homeY = that.to.y;\r\ntags.fgFX = that.to.x;\r\ntags.fgFY = that.to.y;\r\ntags.fgFZ = 0;","fgFZ":0,"homeZ":0,"strokeColor":"black","hideMemory":false,"label":"cb 4e89","onPortalChanged":"@if(that.portal == \"mapPortal\"){\r\n    if(that.dimension){\r\n        tags.hideMemory = true;\r\n    }\r\n}","rbVersionNumber":"0.5.5","onAnyBotsAdded":"@// let menuBots = getBots(byTag(\"rbMenuBot\"), true);\r\nlet updateSettings = false;\r\n\r\nfor(const bot of that.bots){\r\n    bot.tags.fgbNeuron == true ? updateSettings = true : null;\r\n}\r\n\r\n// updateSettings == true ? thisBot.updateFGSettings() : null;\r\n\r\nif(updateSettings == true){\r\n    thisBot.updateFGSettings();\r\n    await os.sleep(100);\r\n    thisBot.updateFGSettings();\r\n}","updateFGSettings":"@tags.fgSettings = {\"gravity\":false,\"linkDistance\":3,\"dimensions\":3};","homeX":5,"homeY":0,"fgFX":5,"fgFY":0,"neuronCopy":[{"topic":"lathe","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: lathe; appears as a standalone term in Michael's message."},{"topic":"reach","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: reach; appears as a standalone term in Michael's message."},{"topic":"testing","linkedTopics":["apple","tree"],"stemConnected":true,"details":"topic extracted from message: testing; related to processes and experimentation; appears alongside 'apple' and 'tree' in Michael's message."},{"topic":"mars","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: mars; appears in Michael's message."},{"topic":"tasting","linkedTopics":["sweets","apple","testing"],"stemConnected":true,"details":"topic extracted from message: tasting; appears as a standalone term in Michael's message."},{"topic":"tease","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: tease; appears as a standalone term in Michael's message."},{"topic":"racing","linkedTopics":["cars"],"stemConnected":true,"details":"topic extracted from message: racing; appears in Michael's message."},{"topic":"cars","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: cars; related to transportation and automotive technology; appears in Michael's message."},{"topic":"moon","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: moon; appears in Michael's message."},{"topic":"leap","linkedTopics":[],"stemConnected":true,"details":"leap"},{"topic":"sweets","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: sweets; appears as a standalone term in Michael's message."},{"topic":"wisp","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: wisp; appears as a standalone term in Michael's message."},{"topic":"apple","linkedTopics":["tree","testing"],"stemConnected":false,"details":"topic extracted from message: apple; related to fruit and its source (tree); appears together with 'testing' and 'tree' in Michael's message."},{"topic":"cow","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: cow; appears in Michael's message."},{"topic":"tree","linkedTopics":["apple","testing"],"stemConnected":true,"details":"topic extracted from message: tree; related to the organism that bears apples; appears alongside 'testing' and 'apple' in Michael's message."},{"topic":"pluto","linkedTopics":["mars","moon"],"stemConnected":true,"details":"topic extracted from message: pluto; appears in Michael's message."},{"topic":"hollowing","linkedTopics":[],"stemConnected":true,"details":"topic extracted from message: hollowing; appears as a standalone term in Michael's message."}],"currentMode":"whisper","brainLink":"0b5877c1-b12e-4ad0-9745-76f82aac0651","forceGraph":"fgb0b5877c1-b12e-4ad0-9745-76f82aac0651","fgSettings":{"gravity":false,"linkDistance":3,"dimensions":3}}}}}