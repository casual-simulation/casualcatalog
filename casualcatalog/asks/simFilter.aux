{"version":1,"state":{"eaf7ddc2-c4f0-447e-aa15-dadd5e5b5b38":{"id":"eaf7ddc2-c4f0-447e-aa15-dadd5e5b5b38","space":"shared","tags":{"abArtifactName":"simFilter","abIDOrigin":"simFilter","collectBots":"@const THREE = thisBot.vars.three;\r\nconst GLTFLoader = thisBot.vars.gltfLoader;\r\n\r\nconst scene = that;\r\n\r\nconst dimension = ab.links.remember.tags.abActiveDimension;\r\nlet botCollection = getBots(byTag(dimension, true), not(byTag(\"filterIgnore\", true)), not(byTag(\"space\", \"tempLocal\")));\r\nfor (let bot of botCollection) {\r\n    if (!getBotPosition(bot, dimension)) {\r\n        continue;\r\n    }\r\n\r\n    const objectFromBot = new THREE.Group();\r\n    const defaultScale = bot.tags.scale ?? 1;\r\n\r\n    if (bot.tags.form == 'mesh' && bot.tags.formSubtype == 'gltf' && bot.tags.formAddress) {\r\n        const loader = new GLTFLoader();\r\n        \r\n        const gltf = await loader.loadAsync(bot.tags.formAddress);\r\n        const mesh = gltf.scene;\r\n        \r\n        //SCALING\r\n        const scaleX = bot.tags.scaleX ?? bot.tags.scale ?? 1;\r\n        const scaleY = bot.tags.scaleY ?? bot.tags.scale ?? 1;\r\n        const scaleZ = bot.tags.scaleZ ?? bot.tags.scale ?? 1;\r\n\r\n        const bbox = new THREE.Box3().setFromObject(mesh);\r\n        const size = new THREE.Vector3();\r\n        bbox.getSize(size);\r\n\r\n        const targetSize = new THREE.Vector3(scaleX, scaleZ, scaleY);\r\n\r\n        const scaleFactorX = targetSize.x / size.x;\r\n        const scaleFactorY = targetSize.y / size.y;\r\n        const scaleFactorZ = targetSize.z / size.z;\r\n\r\n        const uniformScale = Math.min(scaleFactorX, scaleFactorY, scaleFactorZ);\r\n\r\n        objectFromBot.scale.set(uniformScale, uniformScale, uniformScale);\r\n\r\n        objectFromBot.add( mesh );\r\n        const botPosition = getBotPosition(bot, dimension);\r\n        const botRotation = getBotRotation(bot, dimension);\r\n\r\n        objectFromBot.position.set(botPosition.x, (scaleZ / 2) + (botPosition.z ?? 0), -botPosition.y);\r\n        objectFromBot.setRotationFromQuaternion(new THREE.Quaternion(botRotation._q.x, botRotation._q.z, botRotation._q.y, botRotation._q.w));\r\n        mesh.name = bot.id;\r\n\r\n        scene.add(objectFromBot);\r\n        continue;\r\n    }\r\n\r\n    let geometry;\r\n    if (bot.tags.form == 'sphere') {\r\n        geometry = new THREE.SphereGeometry((bot.tags.scaleX ?? defaultScale) / 2, 32, 16 );\r\n    } else {\r\n        geometry = new THREE.BoxGeometry( bot.tags.scaleX ?? defaultScale, bot.tags.scaleZ ?? defaultScale, bot.tags.scaleY ?? defaultScale);\r\n    }\r\n\r\n    const material = new THREE.MeshStandardMaterial({color: bot.tags.color && bot.tags.color !== \"clear\" ? bot.tags.color : 0xFFFFFF});\r\n    const mesh = new THREE.Mesh( geometry, material );\r\n    const botPosition = getBotPosition(bot, dimension);\r\n    const botRotation = getBotRotation(bot, dimension);\r\n    objectFromBot.add(mesh);\r\n    objectFromBot.position.set(botPosition.x, ((bot.tags.scaleZ ?? defaultScale) / 2) + (botPosition.z ?? 0), -botPosition.y);\r\n    objectFromBot.setRotationFromQuaternion(new THREE.Quaternion(botRotation._q.x, botRotation._q.z, botRotation._q.y, botRotation._q.w));\r\n    mesh.name = bot.id;\r\n\r\n    scene.add(objectFromBot);\r\n}","cursor":"pointer","loadImports":"@import * as THREE from 'https://esm.sh/three@0.162.0';\r\nimport { GLTFLoader } from 'https://esm.sh/three@0.162.0/addons/loaders/GLTFLoader.js';\r\n\r\nimport { OrbitControls } from \"https://esm.sh/three@0.162.0/examples/jsm/controls/OrbitControls.js\";\r\nimport { EffectComposer } from 'https://esm.sh/three@0.162.0/addons/postprocessing/EffectComposer.js';\r\nimport { RenderPass } from 'https://esm.sh/three@0.162.0/addons/postprocessing/RenderPass.js';\r\nimport { ShaderPass } from 'https://esm.sh/three@0.162.0/addons/postprocessing/ShaderPass.js';\r\n\r\nimport { RGBShiftShader } from 'https://esm.sh/three@0.162.0/addons/shaders/RGBShiftShader.js';\r\nimport { DotScreenShader } from 'https://esm.sh/three@0.162.0/addons/shaders/DotScreenShader.js';\r\nimport { OutputPass } from 'https://esm.sh/three@0.162.0/addons/postprocessing/OutputPass.js';\r\n\r\nimport { UnrealBloomPass } from 'https://esm.sh/three@0.162.0/addons/postprocessing/UnrealBloomPass.js';\r\n\r\nimport { RenderPixelatedPass } from 'https://esm.sh/three@0.162.0/addons/postprocessing/RenderPixelatedPass.js';\r\n\r\nthisBot.vars.three = THREE;\r\nthisBot.vars.orbitControls = OrbitControls;\r\nthisBot.vars.effectComposer = EffectComposer;\r\nthisBot.vars.renderPass = RenderPass;\r\nthisBot.vars.shaderPass = ShaderPass;\r\nthisBot.vars.gltfLoader = GLTFLoader;\r\n\r\nthisBot.vars.rgbShiftShader = RGBShiftShader;\r\nthisBot.vars.dotScreenShader = DotScreenShader;\r\nthisBot.vars.outputPass = OutputPass;\r\nthisBot.vars.unrealBloomPass = UnrealBloomPass;\r\nthisBot.vars.pixelPass = RenderPixelatedPass;","modifyIframe":"@await os.registerApp('modifyIFrameContainer', thisBot);\r\n\r\nconst css = `\r\n.vm-iframe-container iframe:first-child {\r\n    display: block !important;\r\n    z-index: 2;\r\n    pointer-events: auto !important;\r\n}\r\n`\r\n\r\nos.compileApp(\r\n    'modifyIFrameContainer',\r\n    <div>\r\n        <style>{css}</style>\r\n    </div>\r\n);","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n        label: tags.label,\r\n        dimensionData: {\r\n            dimension: ab.links.remember.tags.abActiveDimension,\r\n            [ab.links.remember.tags.abActiveDimension]: tags[ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension + 'X']: tags[ab.links.remember.tags.abActiveDimension + 'X'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Y']: tags[ab.links.remember.tags.abActiveDimension + 'Y'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: tags[ab.links.remember.tags.abActiveDimension + 'Z'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationX']: tags[ab.links.remember.tags.abActiveDimension + 'RotationX'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationY']: tags[ab.links.remember.tags.abActiveDimension + 'RotationY'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationZ']: tags[ab.links.remember.tags.abActiveDimension + 'RotationZ'],\r\n        },\r\n        color: tags.color,\r\n        labelFloatingBackgroundColor: tags.labelFloatingBackgroundColor,\r\n        labelColor: tags.labelColor,\r\n        simID: tags.simID,\r\n        filterType: tags.filterType\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'simFilter'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\nif (data.config) {\r\n    data = data.config;\r\n}\r\n\r\ntags.label = data.label ?? 'filter';\r\ntags.color = data.color ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD';\r\ntags.labelFloatingBackgroundColor = data.labelFloatingBackgroundColor ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD'; \r\ntags.labelColor = data.labelColor ?? 'white';\r\ntags.simID = data.simID ?? uuid();\r\ntags.filterType = data.filterType ?? 'dots';\r\n\r\ntags.activeFilter = false;\r\n\r\n//Place bot correctly\r\nif (data.dimensionData) {\r\n    for (const tagName in data.dimensionData) {\r\n        tags[tagName] = data.dimensionData[tagName];\r\n    }\r\n}\r\n\r\n//If new action\r\nif (data.eggParameters) {\r\n    const dimension = data.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = data.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = data.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags.dimension = dimension;\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n\r\n    thisBot.onClick();\r\n}\r\n\r\nif (!thisBot.vars.three) {\r\n    await thisBot.loadImports();\r\n}","onABOpenMenu":"@if (that.menuType != 'abBotMenu' || ab.links.remember.links.abBotFocus != thisBot) {\r\n    return;\r\n}\r\n\r\nconst menuOptions = {\r\n    abMenuRefresh: `@destroy(thisBot);`,\r\n    abMenu: true,\r\n    filter: getLink(thisBot)\r\n}\r\n\r\nconst actionMenuButton = {\r\n    ...menuOptions,\r\n    formAddress: 'menu',\r\n    label: 'show action menu',\r\n    abMenuSortOrder: -1,\r\n    onClick: `@\r\n        links.filter.showActionMenu();\r\n        shout('abMenuRefresh');\r\n    `\r\n}\r\n\r\n//ab.links.menu.abCreateMenuButton(actionMenuButton);\r\n\r\nreturn;","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;\r\n\r\ndelete data.tags.label;\r\ndelete data.tags.labelColor;\r\ndelete data.tags.labelFloatingBackgroundColor;\r\ndelete data.tags.color;\r\ndelete data.tags[data.tags.dimension + \"X\"];\r\ndelete data.tags[data.tags.dimension + \"Y\"];\r\ndelete data.tags[data.tags.dimension + \"Z\"];\r\ndelete data.tags[data.tags.dimension + \"RotationX\"];\r\ndelete data.tags[data.tags.dimension + \"RotationY\"];\r\ndelete data.tags[data.tags.dimension + \"RotationZ\"];\r\ndelete data.tags[data.tags.dimension];\r\ndelete data.tags.dimension;\r\ndelete data.tags.simID;\r\ndelete data.tags.activeFilter;\r\ndelete data.tags.filterType;","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;\r\n\r\nthisBot.updateBillboardLabel();","onBotChanged":null,"onClick":"@if (that) {\r\n    if (that.modality == 'mouse' && that.buttonId == 'right') {\r\n        return;\r\n    }\r\n}\r\n\r\nif (!thisBot.vars.three) {\r\n    configBot.tags.menuPortal = \"simFilterLoading\";\r\n    const loadingBar = ab.links.menu.abCreateMenuBusyIndicator({\r\n        label: \"preparing\",\r\n        simFilterLoading: true\r\n    });\r\n    await thisBot.loadImports();\r\n\r\n    destroy(loadingBar);\r\n}\r\n\r\nshout('abMenuRefresh');\r\nshout(\"clearSimFilterMenu\");\r\n\r\nconfigBot.tags.menuPortal = 'simFilter_menu';\r\n\r\nconst menuOptions = {\r\n    simFilter_menu: true,\r\n    clearSimFilterMenu: `@destroy(thisBot);`,\r\n    abMenuRefresh: \"@ destroy(thisBot);\",\r\n    filter: getLink(thisBot)\r\n}\r\n\r\nconst filterTypeButton = {\r\n    ...menuOptions,\r\n    label: 'filter type: ' + tags.filterType ?? '',\r\n    dropdownSortOrder: -1,\r\n    simFilter_menuSortOrder: -1\r\n}\r\n\r\nfilterTypeButton.dropdownOptions = [];\r\nconst filterOptions = [{label: 'dots', id: 'dots'}, {label: 'pixels', id: 'pixels'}, {label: 'bloom', id: 'bloom'}];\r\nfor (let i = 0; i < filterOptions.length; ++i) {\r\n    const tempDropdownItem = {\r\n        ...menuOptions,\r\n        label: filterOptions[i].label,\r\n        filterTypeID: filterOptions[i].id,\r\n        onClick: `@\r\n            links.filter.tags.filterType = tags.filterTypeID;\r\n            links.filter.tags.label = tags.label + \" filter\";\r\n            links.filter.onClick();\r\n            links.filter.updateBillboardLabel();\r\n        `\r\n    }\r\n    filterTypeButton.dropdownOptions.push(tempDropdownItem);\r\n}\r\n\r\nconst activateButton = {\r\n    ...menuOptions,\r\n    label: tags.activeFilter ? \"deactivate\" : \"activate\",\r\n    simFilter_menuSortOrder: 2,\r\n    onClick: `@\r\n        if (links.filter.tags.activeFilter == true) {\r\n            links.filter.closeFilterApp();\r\n        } else {\r\n            links.filter.activateFilter();\r\n        }\r\n        \r\n        shout(\"clearSimFilterMenu\");\r\n    `\r\n}\r\n\r\nab.links.menu.abCreateMenuDropdown(filterTypeButton);\r\nab.links.menu.abCreateMenuButton(activateButton);","onGridClick":"@shout(\"clearSimFilterMenu\");","onInstStreaming":"@if (!thisBot.vars.three) {\r\n    thisBot.loadImports();\r\n}","onRemoteData":"@if (that.name == \"onActionCompleted\") {\r\n}\r\n\r\nelse if (that.name == \"onStartMenu\") { \r\n}","resetIframe":"@os.unregisterApp('modifyIFrameContainer')","strokeColor":"white","system":"sim_toolbox.tools.simFilter","updateBillboardLabel":null,"utilFunctions":null,"simFilter":"true","filterIgnore":"true","filterApp":"@const THREE = thisBot.vars.three;\r\nconst OrbitControls = thisBot.vars.orbitControls;\r\n\r\nconst EffectComposer = thisBot.vars.effectComposer;\r\nconst RenderPass = thisBot.vars.renderPass;\r\nconst ShaderPass = thisBot.vars.shaderPass;\r\n\r\nconst RGBShiftShader = thisBot.vars.rgbShiftShader;\r\n\r\nconst UnrealBloomPass = thisBot.vars.unrealBloomPass;\r\nconst params = {\r\n\t\t\t\tthreshold: 0,\r\n\t\t\t\tstrength: .8,\r\n\t\t\t\tradius: 0.2,\r\n\t\t\t\texposure: 1\r\n\t\t\t};\r\n\r\nconst DotScreenShader = thisBot.vars.dotScreenShader;\r\nconst OutputPass = thisBot.vars.outputPass;\r\n\r\nconst RenderPixelatedPass = thisBot.vars.pixelPass;\r\n\r\nconst { useState, useCallback, useEffect, useRef } = os.appHooks;\r\n\r\nconst width = gridPortalBot.tags.pixelWidth;\r\nconst height = gridPortalBot.tags.pixelHeight;\r\n\r\nconst App = () => {\r\n    \r\n    const scene = new THREE.Scene();\r\n    scene.background = new THREE.Color('rgb(0, 4, 10)');\r\n    const camera = new THREE.OrthographicCamera( width / - 60, width / 60, height / 60, height / - 60, 1, 10000 );\r\n    // const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\r\n\r\n    const renderer = new THREE.WebGLRenderer({antialias: true});\r\n    renderer.setSize(width, height);\r\n    \r\n    thisBot.vars.canvas = renderer.domElement;\r\n    document.body.style.overflow = 'hidden';\r\n    renderer.domElement.style.position = 'fixed';\r\n    renderer.domElement.style.top = '0';\r\n    renderer.domElement.style.left = '0';\r\n\r\n    document.body.appendChild(renderer.domElement);\r\n\r\n    //position camera\r\n    const camPos = os.getCameraPosition('grid');\r\n    if (camPos) {\r\n        camera.position.set(camPos.x, camPos.z, -camPos.y);\r\n    }\r\n    const camRot = os.getFocusPoint('grid');\r\n    if (camRot) {\r\n        camera.lookAt(camRot);\r\n    }    \r\n\r\n    let plight = new THREE.PointLight(0xffffff, .6, 100);\r\n    plight.position.set(1, 3, 1);\r\n    plight.castShadow = true;\r\n    plight.shadow.radius = 3;\r\n    scene.add(plight);\r\n\r\n    const ambientLight = new THREE.AmbientLight(0xffffff, 3);\r\n    ambientLight.name = \"ambientLight\";\r\n    scene.add(ambientLight);\r\n\r\n    const light = new THREE.HemisphereLight(0x0000ff, 0xff0000, 3);\r\n    scene.add(light);\r\n\r\n    const controls = new OrbitControls(camera, renderer.domElement);\r\n    controls.maxPolarAngle = Math.PI/3; \r\n    controls.mouseButtons = {\r\n        LEFT: THREE.MOUSE.PAN,\r\n        MIDDLE: THREE.MOUSE.DOLLY,\r\n        RIGHT: THREE.MOUSE.ROTATE\r\n    }\r\n\r\n    thisBot.collectBots(scene);\r\n\r\n    const composer = new EffectComposer( renderer );\r\n    composer.addPass( new RenderPass( scene, camera ) );\r\n\r\n    if (tags.filterType == 'dots') {\r\n        const effect1 = new ShaderPass( DotScreenShader );\r\n        effect1.uniforms[ 'scale' ].value = 4;\r\n        composer.addPass( effect1 );\r\n\r\n        const effect2 = new ShaderPass( RGBShiftShader );\r\n        effect2.uniforms[ 'amount' ].value = 0.0015;\r\n        composer.addPass( effect2 );\r\n    } else if (tags.filterType == 'bloom') {\r\n        const bloomPass = new UnrealBloomPass( new THREE.Vector2( width, height ), 1.5, 0.4, 0.85 );\r\n        bloomPass.threshold = params.threshold;\r\n        bloomPass.strength = params.strength;\r\n        bloomPass.radius = params.radius;\r\n        composer.addPass(bloomPass);\r\n    } else if (tags.filterType == 'pixels') {\r\n        const renderPixelatedPass = new RenderPixelatedPass( 4, scene, camera );\r\n\t\tcomposer.addPass( renderPixelatedPass );\r\n    }\r\n\r\n    const effect3 = new OutputPass();\r\n    composer.addPass( effect3 );\r\n\r\n    const raycaster = new THREE.Raycaster();\r\n    const mouse = new THREE.Vector2();\r\n\r\n    //onClick events\r\n    document.addEventListener('click', (event) => {\r\n        mouse.x = (event.clientX / width) * 2 - 1;\r\n        mouse.y = -(event.clientY / height) * 2 + 1;\r\n\r\n        raycaster.setFromCamera(mouse, camera);\r\n\r\n        const intersects = raycaster.intersectObjects(scene.children);\r\n\r\n        if (intersects.length > 0) {\r\n            const clickedObject = intersects[0].object;\r\n            getBot(byID(clickedObject.name))?.onClick();\r\n        } else {\r\n            shout(\"onGridClick\");\r\n        }\r\n    });\r\n    \r\n    const animate = function () {\r\n        if (tags.activeFilter == true) {\r\n            requestAnimationFrame.call(window, animate);\r\n            controls.update();\r\n            composer.render();\r\n        }\r\n    };\r\n    animate();\r\n\r\n    const onCloseClick = useCallback(() => {\r\n        thisBot.closeFilterApp();\r\n    }, [])\r\n    \r\n    return (\r\n        <div id='app'>\r\n        <button \r\n            onClick={onCloseClick}\r\n            style= {{\r\n                position: 'fixed',\r\n                top: 0,\r\n                right: 0,\r\n                padding: '6px 16px',\r\n                margin: '10px',\r\n            }}\r\n        >Close</button>\r\n        </div>\r\n    );\r\n}\r\n\r\nreturn App;","activateFilter":"@tags.activeFilter = true;\r\nawait os.registerApp(tags.simID, thisBot);\r\nconst App = thisBot.filterApp();\r\nawait os.compileApp(tags.simID, <App/>);\r\n\r\nconst app = document.getElementById(\"app\");\r\n\r\ndocument.body.replaceChildren(app);\r\n\r\nthisBot.modifyIframe();","closeFilterApp":"@tags.activeFilter = false;\r\nawait os.unregisterApp(tags.simID);\r\ndocument.getElementById(\"app\")?.remove();\r\nthisBot.resetIframe();\r\n","bbLabel":null,"bbLabelFloatingBackgroundColor":null,"bbLabelColor":null,"labelPosition":"floatingBillboard","labelWordWrapMode":"breakWords","labelFontSize":"1","labelSize":"2"}}}}