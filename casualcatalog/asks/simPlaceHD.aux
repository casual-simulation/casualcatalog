{"version":1,"state":{"a5c8fc26-480b-4447-8ec4-45aa17087704":{"id":"a5c8fc26-480b-4447-8ec4-45aa17087704","space":"shared","tags":{"system":"sim_toolbox.tools.simPlaceHD","createSkybox":"@let prompt = that.prompt ?? that;\r\nlet target = that.target;\r\nlet dimension = that.dimension;\r\nconst usingImage = that.usingImage;\r\n\r\nif (!prompt) {\r\n    os.toast(\"You must provide a description.\");\r\n    return;\r\n}\r\n\r\ntags.placePrompt = JSON.stringify(prompt);\r\n\r\ntags.skyboxGenerating = true;\r\n\r\nlet skyboxName;\r\nif (!target) {\r\n    if (usingImage) {\r\n        skyboxName = await thisBot.summarizeImage(prompt);\r\n        if (skyboxName) {\r\n            skyboxName = skyboxName.name;\r\n        }\r\n    } else {\r\n        skyboxName = await thisBot.generateName(prompt); \r\n    }\r\n\r\n    if (skyboxName) {\r\n        tags.label = skyboxName;\r\n        target = skyboxName;\r\n        dimension = skyboxName;\r\n        dimension = dimension.replace(/[^a-zA-Z0-9]/g, '');\r\n        dimension = dimension.toLowerCase();\r\n        tags.chosenDimension = dimension;\r\n    } else {\r\n        os.toast(\"error generating name for sim place.\");\r\n        destroy(loadingBar);\r\n        tags.skyboxGenerating = false;\r\n        return;\r\n    }\r\n} else {\r\n    tags.label = target;\r\n\r\n    if (!dimension) {\r\n        dimension = target;\r\n        dimension = dimension.replace(/[^a-zA-Z0-9]/g, '');\r\n        dimension = dimension.toLowerCase();\r\n    }\r\n    \r\n    tags.chosenDimension = dimension;\r\n}\r\n\r\nconfigBot.tags.menuPortal = \"storyPlaceLoading\";\r\nlet loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Creating skybox\",\r\n    storyPlaceLoading: true\r\n});\r\n\r\n// if (tags.useCache) {\r\n//     destroy(loadingBar);\r\n//     loadingBar = ab.links.menu.abCreateMenuBusyIndicator({\r\n//         label: \"Choosing placeholder skybox\",\r\n//         storyPlaceLoading: true\r\n//     });\r\n\r\n//     response = await ai.chat({\r\n//         role: 'user',\r\n//         content: [\r\n//             {\r\n//                 text: `return ONLY the name of a skybox from the following list that most closely matches this description: ${prompt}.\r\n//                     skybox list: [\"clear_blue_sky\", \"starry_night_sky\", \"city_street\", \"underground_cave\", \"business_lobby\", \"medical_exam_room\", \"underwater\", \"factory_warehouse\", \"server_room\", \"office_space\"]\r\n//                     RESPONSE EXAMPLE: clear_blue_sky\r\n//                 `\r\n//             }\r\n//         ]\r\n//     }, \r\n//     {\r\n//         preferredModel: abPersonality.tags.abPreferredAIModel\r\n//     });\r\n\r\n//     console.log(\"[simPlace]: chosen cached skybox (\" + response.content + \")\");\r\n\r\n//     if (response.content) {\r\n//         tags.color = null;\r\n//         tags.formAddress = tags.cachedSkyboxes[response.content]\r\n//     }\r\n    \r\n//     tags.skyboxGenerating = false;\r\n//     setTagMask(thisBot, \"activeSkybox\", true, \"shared\");\r\n    \r\n// }\r\n\r\nconst skybox = create({\r\n    form: 'mesh',\r\n    formSubtype: 'splat',\r\n    formAddress: null,\r\n    pointable: false,\r\n    focusable: false,\r\n    scaleMode: 'absolute',\r\n    meshPositioningMode: 'absolute',\r\n    anchorPoint: 'center',\r\n    scale: 5,\r\n    [dimension + 'X']: 0,\r\n    [dimension + 'Y']: 0,\r\n    [dimension + 'Z']: 4,\r\n    [dimension]: true,\r\n    system: 'sim_toolbox.genBots.splatSkybox',\r\n    abIgnore: true\r\n});\r\n\r\ntags.skybox = getLink(skybox);\r\n\r\nthisBot.makeMiniSkybox();\r\n\r\ndestroy(loadingBar);\r\nlet skyboxImage;\r\ntry {\r\n    if (usingImage) {\r\n        skyboxImage = await thisBot.generateFromImage({name: target, image: prompt});\r\n    } else {\r\n       skyboxImage = await thisBot.generateWorld({name: target, prompt: prompt}); \r\n    }\r\n} catch (e) {\r\n    tags.color = 'red';\r\n    tags.skyboxGenerating = false;\r\n\r\n    os.toast(\"skybox generation failed\", e);\r\n    tags.error = e;\r\n    return;\r\n}\r\n\r\nif (skyboxImage && links.skybox && links.miniSkybox) {\r\n    links.skybox.tags.formAddress = skyboxImage;\r\n    links.miniSkybox.tags.formAddress = skyboxImage;\r\n    links.miniSkybox.tags.color = null;\r\n    tags.formAddress = skyboxImage;\r\n    tags.color = \"clear\";\r\n    tags.form = \"mesh\";\r\n    tags.strokeColor = null;\r\n\r\n    const doors = getBots(byTag(\"simDoor\", true), byTag(\"destination\", tags.simID));\r\n    for (let i = 0; i < doors.length; ++i) {\r\n        doors[i].tags.formAddress = skyboxImage;\r\n    }\r\n} else {\r\n    os.toast(\"Failed to set splat formAddress\");\r\n}\r\n\r\ntags.skyboxGenerating = false;\r\nsetTagMask(thisBot, \"activeSkybox\", true, \"shared\");\r\n\r\nshout(\"onStorySceneChange\", target);\r\n\r\nshout(\"onSimPlaceSkyboxLoaded\", thisBot);","artifact":"ðŸ”—78e41503-c933-4f8a-817a-ba97bf8d5d27","onClick":"@if (that) {\r\n    if (that.modality == 'mouse' && that.buttonId == 'right') {\r\n        return;\r\n    }\r\n}\r\n\r\nconst doorBot = getBot(\"choosingDoor\", true);\r\n\r\nif (doorBot) {\r\n    if (doorBot == thisBot) {\r\n        tags.choosingDoor = false;\r\n    } else {\r\n        doorBot.addDoor(thisBot);\r\n        thisBot.addDoor(doorBot);\r\n        tags.color = tags.prevColor;\r\n        tags.prevColor = null;\r\n        return;\r\n    }\r\n}\r\n\r\nif (tags.skyboxGenerating == true) {\r\n    os.toast(\"skybox generating...\");\r\n    return;\r\n}\r\n\r\nif (tags.formAddress) {\r\n    shout(\"activateStoryPlaceSkybox\", tags.formAddress);\r\n} else {\r\n    shout('abMenuRefresh');\r\n    shout(\"clearSimPlaceMenu\");\r\n\r\n    configBot.tags.menuPortal = 'simPlace_menu';\r\n\r\n    const menuOptions = {\r\n        simPlace_menu: true,\r\n        clearSimPlacenMenu: `@destroy(thisBot);`,\r\n        abMenuRefresh: \"@ destroy(thisBot);\",\r\n        place: getLink(thisBot)\r\n    }\r\n\r\n    const manualButton = {\r\n        ...menuOptions,\r\n        label: 'manually input skybox information',\r\n        formAddress: 'edit',\r\n        simPlace_menuSortOrder: 2,\r\n        // onClick: `@\r\n        //     links.place.createSkybox();\r\n        //     shout(\"clearSimPlaceMenu\");\r\n        // `,\r\n        onSubmit: `@ \r\n            links.place.createSkybox(that.text);\r\n            shout(\"clearSimPlaceMenu\");\r\n        `\r\n    }\r\n\r\n    const cameraButton = {\r\n        ...menuOptions,\r\n        label: 'use camera to create skybox',\r\n        formAddress: 'photo_camera',\r\n        simPlace_menuSortOrder: 3,\r\n        onClick: `@\r\n            links.place.parseImage();\r\n            shout(\"clearSimPlaceMenu\");\r\n        `\r\n    }\r\n\r\n    const resButton = {\r\n        ...menuOptions,\r\n        label: 'set resolution: ' + tags.resolution,\r\n        simPlace_menuSortOrder: 1,\r\n        dropdownSortOrder: 1,\r\n        dropdownOptions: [\r\n            {\r\n                ...menuOptions,\r\n                label: '100k',\r\n                onClick: `@\r\n                    links.place.tags.resolution = '100k';\r\n                    links.place.onClick();\r\n                `\r\n            },\r\n            {\r\n                ...menuOptions,\r\n                label: '500k',\r\n                onClick: `@\r\n                    links.place.tags.resolution = '500k';\r\n                    links.place.onClick();\r\n                `\r\n            },\r\n            {\r\n                ...menuOptions,\r\n                label: 'full_res',\r\n                onClick: `@\r\n                    links.place.tags.resolution = 'full_res';\r\n                    links.place.onClick();\r\n                `\r\n            }\r\n        ]\r\n    }\r\n\r\n    ab.links.menu.abCreateMenuDropdown(resButton);\r\n    ab.links.menu.abCreateMenuInput(manualButton);\r\n    ab.links.menu.abCreateMenuButton(cameraButton);\r\n}","form":"sphere","abVersion":"10.10","abIDOrigin":"simPlaceHD","onSkyboxToggleInitialized":"@if (that && that.tags.abArtifactInstanceID && that.tags.abArtifactInstanceID == tags.artifactInstanceID) {\r\n    setTagMask(that, configBot.tags.gridPortal, false, \"shared\");\r\n}","activateStoryPlaceSkybox":"@if (tags.formAddress && that == tags.formAddress) {\r\n    const currentDim = ab.links.remember.tags.abActiveDimension;\r\n    const currentPortal = configBot.tags.mapPortal ? \"map\" : configBot.tags.gridPortal == \"blueprint\" ? \"blueprint\" :\"grid\";\r\n\r\n    configBot.tags.gridPortal = tags.chosenDimension;\r\n\r\n    if (currentPortal == 'map') {\r\n        configBot.tags.mapPortal = null;\r\n        setTagMask(ab.links.remember, \"mapZoomPosition\", {x: tags[currentDim + 'X'], y: tags[currentDim + 'Y']});\r\n        configBot.tags.miniMapPortal = currentDim;\r\n    }\r\n\r\n    setTagMask(thisBot, 'activeSkybox', true, 'shared');\r\n    shout(\"onStorySceneChange\", tags.label);\r\n\r\n} else {\r\n    setTagMask(thisBot, 'activeSkybox', false, 'shared');\r\n}","scale":"2.5","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n        label: tags.label,\r\n        dimensionData: {\r\n            dimension: ab.links.remember.tags.abActiveDimension,\r\n            [ab.links.remember.tags.abActiveDimension]: tags[ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension + 'X']: tags[ab.links.remember.tags.abActiveDimension + 'X'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Y']: tags[ab.links.remember.tags.abActiveDimension + 'Y'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: tags[ab.links.remember.tags.abActiveDimension + 'Z'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationX']: tags[ab.links.remember.tags.abActiveDimension + 'RotationX'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationY']: tags[ab.links.remember.tags.abActiveDimension + 'RotationY'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationZ']: tags[ab.links.remember.tags.abActiveDimension + 'RotationZ'],\r\n        },\r\n        simID: tags.simID,\r\n        color: tags.color,\r\n        doors: tags.doors,\r\n        labelFloatingBackgroundColor: tags.labelFloatingBackgroundColor,\r\n        labelColor: tags.labelColor,\r\n        placePrompt: tags.placePrompt,\r\n        formAddress: tags.formAddress,\r\n        chosenDimension: tags.chosenDimension      \r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'simPlaceHD'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\nif (data.config) {\r\n    data = data.config;\r\n}\r\n\r\ntags.label = data.label ?? 'sim place';\r\ntags.color = data.color ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD';\r\ntags.labelFloatingBackgroundColor = data.labelFloatingBackgroundColor ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD'; \r\ntags.labelColor = data.labelColor ?? 'white';\r\ntags.placePrompt = data.placePrompt;\r\ntags.formAddress = data.formAddress;\r\ntags.chosenDimension = data.chosenDimension;\r\ntags.simID = data.simID ?? uuid();\r\ntags.doors = data.doors ?? [];\r\ntags.form = \"sphere\";\r\ntags.resolution = '500k';\r\n\r\ntags.skyboxGenerating = false;\r\n\r\nif (tags.formAddress) {\r\n    tags.color = null;\r\n}\r\n\r\n//Handle lineTo\r\nif (tags.lineTo) {\r\n    tags.lineTo = null;\r\n}\r\nshout(\"onPlaceReconstituted\", thisBot);\r\n\r\n//clear possible extra data\r\nif (tags.choosingDoor) {\r\n    tags.choosingDoor = null;\r\n}\r\n\r\n//Place bot correctly\r\nif (data.dimensionData) {\r\n    for (const tagName in data.dimensionData) {\r\n        tags[tagName] = data.dimensionData[tagName];\r\n    }\r\n}\r\n\r\nif (tags.formAddress) {\r\n    const skybox = create({\r\n        form: 'skybox',\r\n        formAddress: tags.formAddress,\r\n        pointable: false,\r\n        scale: 200,\r\n        [tags.chosenDimension + 'X']: 0,\r\n        [tags.chosenDimension + 'Y']: 0,\r\n        [tags.chosenDimension]: true,\r\n        anchorPoint: 'center',\r\n        [tags.chosenDimension + \"RotationX\"]: 1.5708,\r\n        system: 'story_toolbox.genBots.skybox',\r\n        abIgnore: true\r\n    });\r\n\r\n    tags.skybox = getLink(skybox);\r\n    tags.form = \"mesh\";\r\n\r\n    thisBot.makeMiniSkybox();\r\n\r\n} else if (tags.placePrompt && tags.label && tags.chosenDimension) {\r\n    thisBot.createSkybox({\"prompt\": tags.placePrompt, \"target\": tags.label, 'dimension': tags.chosenDimension});\r\n}\r\n\r\n//If new action\r\nif (data.eggParameters) {\r\n    const dimension = data.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = data.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = data.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags.dimension = dimension;\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;   \r\n\r\n    if (data.eggParameters && data.eggParameters.storyParameters) {\r\n        thisBot.createSkybox({\"prompt\": data.eggParameters.storyParameters.prompt, \"target\": data.eggParameters.storyParameters.target});\r\n    } else {\r\n        thisBot.onClick();\r\n    }\r\n}","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;\r\n\r\ndelete data.tags.label;\r\ndelete data.tags.labelColor;\r\ndelete data.tags.labelFloatingBackgroundColor;\r\ndelete data.tags.color;\r\ndelete data.tags[data.tags.dimension + \"X\"];\r\ndelete data.tags[data.tags.dimension + \"Y\"];\r\ndelete data.tags[data.tags.dimension + \"Z\"];\r\ndelete data.tags[data.tags.dimension + \"RotationX\"];\r\ndelete data.tags[data.tags.dimension + \"RotationY\"];\r\ndelete data.tags[data.tags.dimension + \"RotationZ\"];\r\ndelete data.tags[data.tags.dimension];\r\ndelete data.tags.dimension;\r\ndelete data.tags.placePrompt;\r\ndelete data.tags.formAddress;\r\ndelete data.tags.skybox;\r\ndelete data.tags.simID;\r\ndelete data.tags.skyboxGenerating;\r\ndelete data.tags.chosenDimension;\r\ndelete data.tags.doors;\r\ndelete data.tags.miniSkybox;\r\ndelete data.tags.lowRes;\r\ndelete data.tags.medRes;\r\ndelete data.tags.highRes;","abArtifactName":"simPlaceHD","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","cursor":"pointer","addDoor":"@if (!tags.doors) {\r\n    tags.doors = [];\r\n}\r\n\r\nif (!tags.lineTo) {\r\n    tags.lineTo = [];\r\n}\r\n\r\nconst simID = that?.tags?.simID;\r\n\r\nif (simID) {\r\n    if (!tags.doors.includes(simID)) {\r\n        tags.doors.push(simID);\r\n        tags.lineTo.push(that?.id);\r\n    }\r\n\r\n    const simDoor = getBot(byTag(\"destination\", that.tags.simID), byTag(tags.chosenDimension, true));\r\n    if (simDoor) {\r\n        os.toast(\"simDoor already exists\");\r\n        return;\r\n    }\r\n\r\n    const xVal = Math.round(Math.random() * 15);\r\n    const yVal = Math.round(Math.random() * 15);\r\n\r\n    const abArtifactShard = {\r\n        data: {\r\n            config: {\r\n                label: that.tags.label,\r\n                destination: that.tags.simID,\r\n                dimensionData: {\r\n                    dimension: tags.chosenDimension,\r\n                    [tags.chosenDimension]: true,\r\n                    [tags.chosenDimension + 'X']: xVal,\r\n                    [tags.chosenDimension + 'Y']: yVal\r\n                }\r\n            }\r\n        },\r\n        dependencies: [\r\n            {\r\n                askID: 'simDoor'\r\n            }\r\n        ]\r\n    };\r\n    ab.links.artifact.abCreateArtifactPromiseBot({\r\n        abArtifactName: 'simDoor',\r\n        abArtifactInstanceID: uuid(),\r\n        abArtifactShard,\r\n    });\r\n}\r\n\r\ntags.choosingDoor = false;","onPointerEnter":"@const doorBot = getBot(\"choosingDoor\", true);\r\n\r\nif (doorBot) {\r\n    tags.prevColor = tags.color;\r\n    tags.color = '#fcba03';\r\n}","onPointerExit":"@const doorBot = getBot(\"choosingDoor\", true);\r\n\r\nif (doorBot) {\r\n    tags.color = tags.prevColor;\r\n    tags.prevColor = null;\r\n}","onPlaceReconstituted":"@if (tags.doors && tags.doors.length != 0 && tags.doors.includes(that?.tags?.simID)) {\r\n    if (!tags.lineTo) {\r\n        tags.lineTo = [];\r\n    }\r\n\r\n    if (!tags.lineTo.includes(that.id)) {\r\n        tags.lineTo.push(that.id);\r\n    }\r\n}","onPortalChanged":"@if (that.portal == 'gridPortal') {\r\n    if (that.dimension == tags.chosenDimension) {\r\n        thisBot.enterWorldView();\r\n    } else if (that.dimension == 'home' || that.dimension == 'blueprint') {\r\n        thisBot.exitWorldView();\r\n    }\r\n}","menuButton":"ðŸ”—47b347fb-30b0-4fbe-ba32-fe5e0ce5f712","choosingDoor":false,"doorRemoved":"@if (tags.doors && tags.doors.includes(that)) {\r\n    const tempDoors = [...tags.doors];\r\n    tempDoors.splice(tempDoors.indexOf(that), 1);\r\n    tags.doors = tempDoors;\r\n\r\n    const removedID = getID(getBot(\"simID\", that));\r\n    const tempLines = [...tags.lineTo];\r\n    tempLines.splice(tempLines.indexOf(removedID), 1);\r\n    tags.lineTo = tempLines;\r\n\r\n    const destinationBot = getBot(\"simID\", that);\r\n    const doorBot = getBot(byTag(\"destination\", destinationBot.tags.simID), byTag(tags.chosenDimension, true));\r\n    destroy(doorBot);\r\n}","simPlace":"true","onABOpenMenu":"@if (that.menuType != 'abBotMenu' || ab.links.remember.links.abBotFocus != thisBot) {\r\n    return;\r\n}\r\n\r\nconst menuOptions = {\r\n    abMenuRefresh: `@destroy(thisBot);`,\r\n    abMenu: true,\r\n    place: getLink(thisBot)\r\n}\r\n\r\nconst createDoorButton = {\r\n    ...menuOptions,\r\n    formAddress: 'sensor_door',\r\n    label: 'create door',\r\n    abMenuSortOrder: -1,\r\n    onClick: `@\r\n        links.place.tags.choosingDoor = true;\r\n        shout('abMenuRefresh');\r\n    `\r\n}\r\n\r\nconst clearDoorsButton = {\r\n    ...menuOptions,\r\n    formAddress: 'replay',\r\n    label: 'remove all doors',\r\n    onClick: `@\r\n        links.place.tags.doors = null;\r\n        links.place.tags.lineTo = null;\r\n        const doors = getBots(byTag(\"simDoor\", true), byTag(links.place.tags.chosenDimension, true));\r\n        destroy(doors);\r\n        shout(\"doorRemoved\", links.place.tags.simID);\r\n        shout('abMenuRefresh');\r\n    `\r\n}\r\n\r\nab.links.menu.abCreateMenuButton(createDoorButton);\r\nab.links.menu.abCreateMenuButton(clearDoorsButton);","parseImage":"@const photo = await os.capturePhoto();\r\nif (!photo) {\r\n    return;\r\n}\r\n\r\nawait thisBot.createSkybox({prompt: photo, usingImage: true});","labelPosition":"floatingBillboard","labelWordWrapMode":"breakWords","labelFontSize":"1","labelSize":"2","anchorPoint":"center","makeMiniSkybox":"@const miniSkybox = await create({\r\n    form: 'mesh',\r\n    formSubtype: 'splat',\r\n    formAddress: tags.lowRes,\r\n    pointable: false,\r\n    color: tags.formAddress ? null: tags.color,\r\n    scale: 1.1,\r\n    [tags.dimension]: true,\r\n    anchorPoint: 'center',\r\n    [tags.dimension + \"RotationX\"]: 1.5708,\r\n    abIgnore: true,\r\n    transformer: getID(thisBot),\r\n    onAnyBotDrop: `@if (that.bot == thisBot) {  \r\n        tags[tags.dimension + \"RotationX\"] = 1.5708;\r\n    }`\r\n});\r\n\r\nif (links && links.miniSkybox) {\r\n    destroy(miniSkybox);\r\n}\r\ntags.miniSkybox = getLink(miniSkybox);","cachedSkyboxes":"ðŸ§¬{\r\n    \r\n}","useCache":"false","enterWorldView":"@tags.savedPortalColor = gridPortalBot.tags.portalColor || '#263238';\r\ntags.savedSurfaceScale = gridPortalBot.tags.portalSurfaceScale;\r\n\r\nlinks.shell.cmdABSleep();\r\n\r\ngridPortalBot.tags.portalColor = '#000000';\r\n// gridPortalBot.tags.portalSurfaceScale = 0;\r\n\r\nconst inXR = configBot.tags.arEnabled || configBot.tags.vrEnabled;\r\nif (!inXR) {\r\n   os.enablePointOfView({ x: 0, y: 0, z: 0 }); \r\n}\r\n","exitWorldView":"@const inXR = configBot.tags.arEnabled || configBot.tags.vrEnabled;\r\nif (!inXR) {\r\n   os.disablePointOfView(); \r\n}\r\n\r\nlinks.shell.cmdABWake();\r\n\r\ngridPortalBot.tags.portalColor = tags.savedPortalColor || '#263238';\r\n// gridPortalBot.tags.portalSurfaceScale = tags.savedSurfaceScale || 2;","onGridClick":"@shout(\"clearSimPlaceMenu\");","generateWorld":"@if (tags.isGenerating) {\r\n    os.toast(\"Generation already in progress...\");\r\n    return;\r\n}\r\n\r\nconst prompt = that.prompt;\r\nif (!prompt) return;\r\n\r\ntags.isGenerating = true;\r\n\r\nconfigBot.tags.menuPortal = \"storyPlaceLoading\";\r\nlet loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Sending to World Labs Marble API\",\r\n    storyPlaceLoading: true\r\n});\r\n\r\ntry {\r\n    const model = tags.model || \"Marble 0.1-mini\";\r\n    const genResponse = await web.post(\r\n        \"https://api.worldlabs.ai/marble/v1/worlds:generate\",\r\n        {\r\n            display_name: that.name,\r\n            model: model,\r\n            world_prompt: {\r\n                type: \"text\",\r\n                text_prompt: prompt\r\n            }\r\n        },\r\n        {\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"WLT-Api-Key\": tags.apiKey\r\n            }\r\n        }\r\n    );\r\n\r\n    if (!genResponse || !genResponse.data || !genResponse.data.operation_id) {\r\n        os.toast(\"Failed to start generation. Check API key.\");\r\n\r\n        destroy(loadingBar);\r\n\r\n        tags.isGenerating = false;\r\n        return;\r\n    }\r\n\r\n    const operationId = genResponse.data.operation_id;\r\n\r\n    destroy(loadingBar);\r\n    configBot.tags.menuPortal = \"storyPlaceLoading\";\r\n    loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n        label: \"World generation started! Polling for completion\",\r\n        storyPlaceLoading: true\r\n    });\r\n\r\n    let done = false;\r\n    let attempts = 0;\r\n    const maxAttempts = 120;\r\n    let worldData = null;\r\n\r\n    while (!done && attempts < maxAttempts) {\r\n        await os.sleep(5000);\r\n        attempts++;\r\n\r\n        const pollResponse = await web.get(\r\n            \"https://api.worldlabs.ai/marble/v1/operations/\" + operationId,\r\n            {\r\n                headers: {\r\n                    \"WLT-Api-Key\": tags.apiKey\r\n                }\r\n            }\r\n        );\r\n\r\n        if (pollResponse && pollResponse.data) {\r\n            const op = pollResponse.data;\r\n            if (op.done === true) {\r\n                done = true;\r\n                if (op.error) {\r\n                    os.toast(\"Generation failed: \" + (op.error.message || \"Unknown error\"));\r\n                } else {\r\n                    worldData = op.response;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!done) {\r\n        os.toast(\"Generation timed out after \" + maxAttempts + \" polls.\");\r\n        tags.isGenerating = false;\r\n\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    if (!worldData) {\r\n        tags.isGenerating = false;\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    const resolution = tags.resolution || \"100k\";\r\n    let spzUrl = null;\r\n\r\n    if (worldData.assets && worldData.assets.splats && worldData.assets.splats.spz_urls) {\r\n        spzUrl = worldData.assets.splats.spz_urls[resolution]\r\n              || worldData.assets.splats.spz_urls[\"100k\"]\r\n              || worldData.assets.splats.spz_urls[\"500k\"]\r\n              || worldData.assets.splats.spz_urls[\"full_res\"];\r\n    }\r\n\r\n    tags.lowRes = worldData.assets.splats.spz_urls[\"100k\"];\r\n    tags.medRes = worldData.assets.splats.spz_urls[\"500k\"];\r\n    tags.highRes = worldData.assets.splats.spz_urls[\"full_res\"];\r\n\r\n    if (!spzUrl) {\r\n        os.toast(\"No splat URL found in response.\");\r\n        tags.isGenerating = false;\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    return spzUrl;\r\n\r\n} catch (err) {\r\n    os.toast(\"Error: \" + (err.message || err));\r\n    destroy(loadingBar);\r\n} finally {\r\n    tags.isGenerating = false;\r\n    destroy(loadingBar);\r\n}\r\n","apiKey":"L8ZJL6sPvsKLPQzZcPcmWepw96wAHnTH","model":"Marble 0.1-mini","resolution":"500k","shell":"ðŸ”—f8602878-c2ef-48bd-85a0-8d6351eb4120","savedPortalColor":"#263238","generateFromImage":"@if (tags.isGenerating) {\r\n    os.toast(\"Generation already in progress...\");\r\n    return;\r\n}\r\n\r\nconst prompt = that.image;\r\nif (!prompt) return;\r\n\r\ntags.isGenerating = true;\r\n\r\nconfigBot.tags.menuPortal = \"storyPlaceLoading\";\r\nlet loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Sending to World Labs Marble API\",\r\n    storyPlaceLoading: true\r\n});\r\n\r\nconst base = bytes.toBase64String(new Uint8Array(await prompt.data.arrayBuffer()));\r\n\r\ntry {\r\n    const model = tags.model || \"Marble 0.1-mini\";\r\n    const genResponse = await web.post(\r\n        \"https://api.worldlabs.ai/marble/v1/worlds:generate\",\r\n        {\r\n            display_name: that.name,\r\n            model: model,\r\n            world_prompt: {\r\n                type: \"image\",\r\n                image_prompt: {\r\n                    data_base64: base,\r\n                    source: \"data_base64\"\r\n                }\r\n            }\r\n        },\r\n        {\r\n            headers: {\r\n                \"Content-Type\": \"application/json\",\r\n                \"WLT-Api-Key\": tags.apiKey\r\n            }\r\n        }\r\n    );\r\n\r\n    if (!genResponse || !genResponse.data || !genResponse.data.operation_id) {\r\n        os.toast(\"Failed to start generation. Check API key.\");\r\n\r\n        destroy(loadingBar);\r\n\r\n        tags.isGenerating = false;\r\n        return;\r\n    }\r\n\r\n    const operationId = genResponse.data.operation_id;\r\n\r\n    destroy(loadingBar);\r\n    configBot.tags.menuPortal = \"storyPlaceLoading\";\r\n    loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n        label: \"World generation started! Polling for completion\",\r\n        storyPlaceLoading: true\r\n    });\r\n\r\n    let done = false;\r\n    let attempts = 0;\r\n    const maxAttempts = 120;\r\n    let worldData = null;\r\n\r\n    while (!done && attempts < maxAttempts) {\r\n        await os.sleep(5000);\r\n        attempts++;\r\n\r\n        const pollResponse = await web.get(\r\n            \"https://api.worldlabs.ai/marble/v1/operations/\" + operationId,\r\n            {\r\n                headers: {\r\n                    \"WLT-Api-Key\": tags.apiKey\r\n                }\r\n            }\r\n        );\r\n\r\n        if (pollResponse && pollResponse.data) {\r\n            const op = pollResponse.data;\r\n            if (op.done === true) {\r\n                done = true;\r\n                if (op.error) {\r\n                    os.toast(\"Generation failed: \" + (op.error.message || \"Unknown error\"));\r\n                } else {\r\n                    worldData = op.response;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    if (!done) {\r\n        os.toast(\"Generation timed out after \" + maxAttempts + \" polls.\");\r\n        tags.isGenerating = false;\r\n\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    if (!worldData) {\r\n        tags.isGenerating = false;\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    const resolution = tags.resolution || \"100k\";\r\n    let spzUrl = null;\r\n\r\n    if (worldData.assets && worldData.assets.splats && worldData.assets.splats.spz_urls) {\r\n        spzUrl = worldData.assets.splats.spz_urls[resolution]\r\n              || worldData.assets.splats.spz_urls[\"100k\"]\r\n              || worldData.assets.splats.spz_urls[\"500k\"]\r\n              || worldData.assets.splats.spz_urls[\"full_res\"];\r\n    }\r\n\r\n    tags.lowRes = worldData.assets.splats.spz_urls[\"100k\"];\r\n    tags.medRes = worldData.assets.splats.spz_urls[\"500k\"];\r\n    tags.highRes = worldData.assets.splats.spz_urls[\"full_res\"];\r\n\r\n    if (!spzUrl) {\r\n        os.toast(\"No splat URL found in response.\");\r\n        tags.isGenerating = false;\r\n        destroy(loadingBar);\r\n        return;\r\n    }\r\n\r\n    return spzUrl;\r\n\r\n} catch (err) {\r\n    os.toast(\"Error: \" + (err.message || err));\r\n    destroy(loadingBar);\r\n} finally {\r\n    tags.isGenerating = false;\r\n    destroy(loadingBar);\r\n}\r\n","generateName":"@configBot.tags.menuPortal = \"storyPlaceLoading\";\r\nlet loadingBar = await ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Naming sim place\",\r\n    storyPlaceLoading: true\r\n});\r\n\r\nconst response = await ai.chat({\r\n    role: 'user',\r\n    content: [\r\n        {\r\n            text: `return ONLY a short label (3 words maximum) for a skybox that will be generated with this description: ${that}.\r\n                RESPONSE EXAMPLE: \"Field of Daisies\"\r\n            `\r\n        }\r\n    ]\r\n}, \r\n{\r\n    preferredModel: abPersonality.tags.abPreferredAIModel\r\n});\r\n\r\ndestroy(loadingBar);\r\n\r\nif (response.content) {\r\n    return response.content;\r\n}\r\nelse {\r\n    os.toast(\"error generating name for sim place.\");\r\n    destroy(loadingBar);\r\n    return;\r\n}","summarizeImage":"@configBot.tags.menuPortal = \"simPlaceLoading\";\r\nconst loadingBar = ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Summarizing image\",\r\n    simPlaceLoading: true\r\n});\r\n\r\nconst response = await ai.chat({\r\n    role: 'user',\r\n    content: [\r\n        {\r\n            text: `Please generate 2 items and return them in JSON.\r\n\r\n            1. A \"name\" for the captured image, following these rules:\r\n                a. Do not exceed 3 words.\r\n                b. The name must be representative of what is in the image.\r\n                c. Do not use any special characters or asteriks.\r\n            2. a detailed \"description\" of what is in the captured image, following these rules:\r\n                a. Do not use any special characters or asteriks.\r\n                b. Make a it a clear concise prompt.\r\n                c. Please limit it to 150 words or less.\r\n            \r\n            Not following the above rules could hurt or break the experience.\r\n\r\n            RESPONSE FORMAT EXAMPLE: \r\n                {\r\n                    \"name\": \"My Image Name\",\r\n                    \"description\": \"This is where the image description goes\"\r\n                }\r\n            `\r\n        },\r\n        {\r\n            base64: bytes.toBase64String(new Uint8Array(await that.data.arrayBuffer())),\r\n            mimeType: that.data.type,\r\n        }\r\n    ]\r\n}, \r\n{\r\n    preferredModel: ab.links.personality.tags.abPreferredAIModel\r\n});\r\n\r\ndestroy(loadingBar);\r\n\r\nlet promptResponse = response.content?.replaceAll('`', '');\r\npromptResponse = promptResponse.replaceAll('\\n', '');\r\nif (promptResponse.indexOf('json') == 0) {\r\n    promptResponse = promptResponse.replace('json', '');\r\n}\r\n\r\ntry {\r\n  promptResponse = JSON.parse(promptResponse);  \r\n} catch (e) {\r\n    console.log(\"Error: \", e);\r\n}\r\n\r\nconsole.log(\"PROMPT: \"+promptResponse);\r\n\r\nif (promptResponse?.description && promptResponse?.name) {\r\n    return promptResponse;\r\n} else {\r\n    os.toast(\"Invalid AI response\");\r\n    return;\r\n}","isGenerating":false,"error":"error check 2[object Object]"}}}}