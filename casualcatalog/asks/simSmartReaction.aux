{"version":1,"state":{"bf1c8d1b-4146-4baa-8d67-6c7fb9b6ffe2":{"id":"bf1c8d1b-4146-4baa-8d67-6c7fb9b6ffe2","space":"shared","tags":{"system":"sim_toolbox.tools.simSmartReaction","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n        label: tags.label,\r\n        dimensionData: {\r\n            dimension: ab.links.remember.tags.abActiveDimension,\r\n            [ab.links.remember.tags.abActiveDimension]: tags[ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension + 'X']: tags[ab.links.remember.tags.abActiveDimension + 'X'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Y']: tags[ab.links.remember.tags.abActiveDimension + 'Y'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: tags[ab.links.remember.tags.abActiveDimension + 'Z'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationX']: tags[ab.links.remember.tags.abActiveDimension + 'RotationX'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationY']: tags[ab.links.remember.tags.abActiveDimension + 'RotationY'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationZ']: tags[ab.links.remember.tags.abActiveDimension + 'RotationZ'],\r\n        },\r\n        color: tags.color,\r\n        labelFloatingBackgroundColor: tags.labelFloatingBackgroundColor,\r\n        labelColor: tags.labelColor,\r\n        simID: tags.simID,\r\n        actionStory: tags.actionStory,\r\n        actionTriggers: tags.actionTriggers,\r\n        roleTags: tags.roleTags,\r\n        orderMatters: tags.orderMatters,\r\n        sequentialMatters: tags.sequentialMatters,\r\n        checkQueue: tags.checkQueue,\r\n        manualFunction: tags.manualFunction\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'simSmartReaction'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABArtifactReconstitute":"@let data = that.data;\r\nif (data.config) {\r\n    data = data.config;\r\n}\r\ntags.label = data.label ?? 'smart reaction';\r\ntags.color = data.color ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD';\r\ntags.labelFloatingBackgroundColor = data.labelFloatingBackgroundColor ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD'; \r\ntags.labelColor = data.labelColor ?? 'white';\r\ntags.simID = data.simID ?? uuid();\r\ntags.actionTriggers = data.actionTriggers;\r\ntags.actionStory = data.actionStory;\r\ntags.roleTags = data.roleTags ?? [];\r\ntags.orderMatters = data.orderMatters ?? false;\r\ntags.sequentialMatters = data.sequentialMatters ?? false;\r\ntags.checkQueue = data.checkQueue ?? false; \r\ntags.manualFunction = data.manualFunction;\r\n\r\n//Handle lineTo\r\nif (tags.lineTo) {\r\n    tags.lineTo = null;\r\n}\r\nshout(\"onActionReconstituted\", thisBot);\r\n\r\n//clear possible extra data\r\nif (tags.choosingTrigger) {\r\n    tags.choosingTrigger = null;\r\n}\r\n\r\n//Place bot correctly\r\nif (data.dimensionData) {\r\n    for (const tagName in data.dimensionData) {\r\n        tags[tagName] = data.dimensionData[tagName];\r\n    }\r\n}\r\n\r\n//If new action\r\nif (data.eggParameters) {\r\n    const dimension = data.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = data.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = data.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags.dimension = dimension;\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n\r\n    thisBot.onClick();\r\n}\r\n\r\nif (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;\r\n\r\ndelete data.tags.label;\r\ndelete data.tags.labelColor;\r\ndelete data.tags.labelFloatingBackgroundColor;\r\ndelete data.tags.color;\r\ndelete data.tags[data.tags.dimension + \"X\"];\r\ndelete data.tags[data.tags.dimension + \"Y\"];\r\ndelete data.tags[data.tags.dimension + \"Z\"];\r\ndelete data.tags[data.tags.dimension + \"RotationX\"];\r\ndelete data.tags[data.tags.dimension + \"RotationY\"];\r\ndelete data.tags[data.tags.dimension + \"RotationZ\"];\r\ndelete data.tags[data.tags.dimension];\r\ndelete data.tags.dimension;\r\ndelete data.tags.simID;\r\ndelete data.tags.actionTriggers;\r\ndelete data.tags.choosingTrigger;\r\ndelete data.tags.lineTo;\r\ndelete data.tags.actionStory;\r\ndelete data.tags.roleTags;\r\ndelete data.tags.orderMatters;\r\ndelete data.tags.sequentialMatters;\r\ndelete data.tags.checkQueue;\r\ndelete data.tags.manualFunction;","onClick":"@if (that) {\r\n    if (that.modality == 'mouse' && that.buttonId == 'right') {\r\n        return;\r\n    }\r\n}\r\n\r\nconst triggerBot = getBot(\"choosingTrigger\", true);\r\nconst completionTriggerBot = getBot(\"choosingCompletionTrigger\", true);\r\n\r\nif (triggerBot) {\r\n    if (triggerBot == thisBot) {\r\n        tags.choosingTrigger = false;\r\n        tags.choosingTriggerFilter = false;\r\n    } else {\r\n        if (triggerBot.tags.choosingTriggerFilter == true) {\r\n            triggerBot.addTriggerFilter(thisBot);\r\n        } else {\r\n            triggerBot.addTrigger(thisBot);\r\n        }\r\n        tags.color = tags.prevColor;\r\n        tags.prevColor = null;\r\n        return;\r\n    }\r\n}\r\n\r\nif (completionTriggerBot) {\r\n    completionTriggerBot.addCompletionTrigger(thisBot);\r\n    tags.color = tags.prevColor;\r\n    tags.prevColor = null;\r\n    return;\r\n}\r\n\r\n// os.toast('hello, world!');\r\nshout('abMenuRefresh');\r\nshout(\"clearSimActionMenu\");\r\n\r\nconfigBot.tags.menuPortal = 'simAction_menu';\r\n\r\nconst menuOptions = {\r\n    simAction_menu: true,\r\n    clearSimActionMenu: `@destroy(thisBot);`,\r\n    abMenuRefresh: \"@ destroy(thisBot);\",\r\n    reaction: getLink(thisBot)\r\n}\r\n\r\nconst labelButton = {\r\n    ...menuOptions,\r\n    label: 'label: ' + tags.label,\r\n    simAction_menuSortOrder: 1,\r\n    onClick: `@\r\n        const response = await os.showInput(links.reaction.tags.label, {\r\n            autoSelect: true,\r\n            title: 'label this action'\r\n        });\r\n        links.reaction.tags.label = response;\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nif (!tags.roleTags) {\r\n    tags.roleTags = [];\r\n}\r\nlet tagString = \"\";\r\nfor (let i = 0; i < tags.roleTags.length; ++i) {\r\n    tagString += i == 0 ? tags.roleTags[i] : (', ' + tags.roleTags[i]);\r\n}\r\n\r\nconst addRoleTagButton = {\r\n    ...menuOptions,\r\n    label: 'add role tag: ' + tagString,\r\n    formAddress: 'add',\r\n    simAction_menuSortOrder: 7,\r\n    onClick: `@\r\n        const response = await os.showInput('', {\r\n            autoSelect: true,\r\n            title: 'add a role/prop'\r\n        });\r\n\r\n        links.reaction.tags.roleTags.push(response);\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nconst storyButton = {\r\n    ...menuOptions,\r\n    label: 'story',\r\n    simAction_menuSortOrder: 4,\r\n    onClick: `@\r\n        const response = await os.showInput(links.reaction.tags.actionStory, {\r\n            autoSelect: true,\r\n            title: 'Provide a story for this action',\r\n        });\r\n        links.reaction.tags.actionStory = response;\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nconst triggerButton = {\r\n    ...menuOptions,\r\n    label: 'add a trigger',\r\n    formAddress: 'add',\r\n    simAction_menuSortOrder: 5,\r\n    onClick: `@\r\n        links.reaction.tags.choosingTrigger = true;\r\n        shout(\"clearSimActionMenu\");\r\n    `\r\n}\r\n\r\nconst orderMattersButton = {\r\n    ...menuOptions,\r\n    label: 'order matters',\r\n    formAddress: tags.orderMatters ? 'check_box' : 'check_box_outline_blank',\r\n    simAction_menuSortOrder: 7,\r\n    onClick: `@\r\n        links.reaction.tags.orderMatters = !links.reaction.tags.orderMatters;\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nconst sequentialButton = {\r\n     ...menuOptions,\r\n    label: 'sequential',\r\n    formAddress: tags.sequentialMatters ? 'check_box' : 'check_box_outline_blank',\r\n    simAction_menuSortOrder: 7,\r\n    onClick: `@\r\n        links.reaction.tags.sequentialMatters = !links.reaction.tags.sequentialMatters;\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nconst actionQueueorLogButton = {\r\n     ...menuOptions,\r\n    label: 'check queue or log: ' + (tags.checkQueue ? 'queue' : 'log'),\r\n    formAddress: 'compare_arrows',\r\n    simAction_menuSortOrder: 7,\r\n    onClick: `@\r\n        links.reaction.tags.checkQueue = !links.reaction.tags.checkQueue;\r\n        links.reaction.onClick();\r\n    `\r\n}\r\n\r\nconst manualButton = {\r\n    ...menuOptions,\r\n    label: 'set manual function',\r\n    formAddress: 'add',\r\n    simAction_menuSortOrder: 7,\r\n    onClick: `@\r\n        configBot.tags.tagPortal = getID(links.reaction) + \".manualFunction\"\r\n    `\r\n}\r\n\r\nab.links.menu.abCreateMenuButton(labelButton);\r\nab.links.menu.abCreateMenuButton(storyButton);\r\nab.links.menu.abCreateMenuButton(triggerButton);\r\nab.links.menu.abCreateMenuButton(addRoleTagButton);\r\nab.links.menu.abCreateMenuButton(orderMattersButton);\r\nab.links.menu.abCreateMenuButton(sequentialButton);\r\nab.links.menu.abCreateMenuButton(actionQueueorLogButton);\r\nab.links.menu.abCreateMenuButton(manualButton);\r\n","abArtifactName":"simSmartReaction","abIDOrigin":"simSmartReaction","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;","onPointerEnter":"@const triggerBot = getBot(\"choosingTrigger\", true);\r\nconst completionTriggerBot = getBot(\"choosingCompletionTrigger\", true);\r\n\r\nif (triggerBot || completionTriggerBot) {\r\n    tags.prevColor = tags.color;\r\n    tags.color = '#fcba03';\r\n}","onPointerExit":"@const triggerBot = getBot(\"choosingTrigger\", true);\r\nconst completionTriggerBot = getBot(\"choosingCompletionTrigger\", true);\r\n\r\nif (triggerBot || completionTriggerBot) {\r\n    tags.color = tags.prevColor;\r\n    tags.prevColor = null;\r\n}","onGridClick":"@shout(\"clearSimActionMenu\");\r\n//shout(\"clearActionMenu\");\r\n\r\nif (tags.choosingTrigger) {\r\n    tags.choosingTrigger = false;\r\n}\r\n\r\nif (tags.choosingTriggerFilter) {\r\n    tags.choosingTriggerFilter = false;\r\n}","strokeColor":"white","simAction":"true","onActionCompleted":"@if (!authBot) {\n    await os.requestAuthBotInBackground();\n}\nif (!authBot) {\n    os.toast(\"user not logged in.\");\n    return;\n}\nconst simXPBot = getBot(byTag(\"xp\", true), byTag(\"xpType\", \"sim\"), byTag(\"simUser\", authBot.id));\nconst actionQueue = [...simXPBot.tags.queuedActions];\nactionQueue.push({\n    id: that.tags.simID,\n    origin: 'unknown'\n})\nconst actionLog = [...simXPBot.tags.completedActions];\nactionLog.push(that.tags.simID);\n\nif (tags.manualFunction && thisBot.raw.manualFunction != '@') {\n    try {\n        const result = thisBot.manualFunction;\n        if (result == true) {\n            if (configBot.tags.staticInst) {\n                shout(\"onRemoteData\", {\n                    name: \"onActionCompleted\",\n                    that: tags.simID,\n                    remoteId: getID(configBot)\n                });\n            } else {\n                const remotes = await os.remotes();\n                await sendRemoteData(remotes, \"onActionCompleted\", tags.simID);\n            }\n            \n            if (tags.actionStory) {\n                ab.log({message: tags.actionStory, space: \"shared\", name: \"sim\"});\n            } else {\n                ab.log({message: \"completed: \" + tags.label, space: \"shared\", name: \"sim\"});\n            }\n        } \n        return;\n    } catch {\n        console.log(\"manual function failed to return a usable result\", tags.simID);\n    }\n}\n\nif (tags.actionTriggers && tags.actionTriggers.length != 0 && tags.actionTriggers.includes(that?.tags?.simID)) {\n    let requirementsMet = true;\n    let foundIndexCheck = [];\n    for (let i = 0; i < tags.actionTriggers.length; ++i) {\n        let foundAction = false;\n        \n        if (tags.checkQueue) {\n            \n            foundAction = actionQueue.find(action => action.id == tags.actionTriggers[i]);\n            if (foundAction) {\n                foundIndexCheck.push(actionQueue.findIndex(action => action.id == tags.actionTriggers[i]));\n            }\n            console.log(actionQueue, foundAction, tags.actionTriggers[i]);\n            \n        } else {\n            foundAction = actionLog.includes(tags.actionTriggers[i]);\n            if (foundAction) {\n                foundIndexCheck.push(actionLog.indexOf(tags.actionTriggers[i]));\n            }\n        }\n        \n        if (!foundAction) {\n            requirementsMet = false;\n            break;\n        }\n\n        if (tags.orderMatters) {\n            for (let j = 0; j < foundIndexCheck.length; ++j) {\n                if (j == 0) {\n                    continue;\n                }\n\n                if (foundIndexCheck[j] < foundIndexCheck[j - 1]) {\n                    requirementsMet = false;\n                    break;\n                }\n            }\n        }\n\n        if (tags.sequentialMatters) {\n            for (let j = 0; j < foundIndexCheck.length; ++j) {\n                if (j == 0) {\n                    continue;\n                }\n\n                if (foundIndexCheck[j] < foundIndexCheck[j - 1]) {\n                    requirementsMet = false;\n                    break;\n                } else {\n                    if (foundIndexCheck[j] - foundIndexCheck[j - 1] > 1) {\n                        requirementsMet = false;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    \n    if (requirementsMet) {\n        if (configBot.tags.staticInst) {\n            shout(\"onRemoteData\", {\n                name: \"onActionCompleted\",\n                that: tags.simID,\n                remoteId: getID(configBot)\n            });\n        } else {\n            \n            const remotes = await os.remotes();\n            await sendRemoteData(remotes, \"onActionCompleted\", tags.simID);\n        }\n        \n        if (tags.actionStory) {\n            ab.log({message: tags.actionStory, space: \"shared\", name: \"sim\"});\n        } else {\n            ab.log({message: \"completed: \" + tags.label, space: \"shared\", name: \"sim\"});\n        }\n    } \n}","onActionReconstituted":"@if ((tags.actionTriggers && tags.actionTriggers.length != 0 && tags.actionTriggers.includes(that?.tags?.simID)) || (tags.actionTriggerFilter && tags.actionTriggerFilter.length != 0 && tags.actionTriggerFilter.includes(that?.tags?.simID))) {\r\n    if (!tags.lineTo) {\r\n        tags.lineTo = [];\r\n    }\r\n\r\n    if (!tags.lineTo.includes(that.id)) {\r\n        tags.lineTo.push(that.id);\r\n    }\r\n}\r\n\r\nif (that == thisBot) {\r\n    thisBot.resetLineTo();\r\n}","cursor":"pointer","onRemoteData":"@if (that.name == \"onActionCompleted\" && that.remoteId == getID(configBot)) {\r\n    thisBot.onActionCompleted(getBot(\"simID\", that.that));\r\n}\r\n\r\nelse if (that.name == \"onActionAddedToQueue\" && that.remoteId == getID(configBot)) {\r\n    thisBot.onActionCompleted(getBot(\"simID\", that.that));\r\n}","scale":".5","onABOpenMenu":"@if (that.menuType != 'abBotMenu' || ab.links.remember.links.abBotFocus != thisBot) {\r\n    return;\r\n}\r\n\r\nconst menuOptions = {\r\n    abMenuRefresh: `@destroy(thisBot);`,\r\n    abMenu: true,\r\n    action: getLink(thisBot)\r\n}\r\n\r\nconst actionMenuButton = {\r\n    ...menuOptions,\r\n    formAddress: 'science',\r\n    label: 'react',\r\n    abMenuSortOrder: -1,\r\n    onClick: `@\r\n        links.action.react();\r\n        shout('abMenuRefresh');\r\n    `\r\n}\r\n\r\nconst resetRoleTagsButton = {\r\n    ...menuOptions,\r\n    formAddress: 'replay',\r\n    label: 'reset role tags',\r\n    onClick: `@\r\n        links.action.tags.roleTags = [];\r\n        shout('abMenuRefresh');\r\n        shout(\"clearSimActionMenu\");\r\n\r\n        links.action.onClick();\r\n    `\r\n}\r\n\r\nconst resetTriggersButton = {\r\n    ...menuOptions,\r\n    formAddress: 'replay',\r\n    label: 'reset triggers',\r\n    onClick: `@\r\n        links.action.tags.actionTriggers = null;\r\n        links.action.tags.lineTo = null;\r\n        shout('abMenuRefresh');\r\n    `\r\n}\r\n\r\nab.links.menu.abCreateMenuButton(actionMenuButton);\r\nab.links.menu.abCreateMenuButton(resetRoleTagsButton);\r\nab.links.menu.abCreateMenuButton(resetTriggersButton);\r\n","labelSize":"2","labelPosition":"floatingBillboard","labelWordWrapMode":"breakWords","addTrigger":"@if (!tags.actionTriggers) {\r\n    tags.actionTriggers = [];\r\n}\r\n\r\nif (!tags.lineTo) {\r\n    tags.lineTo = [];\r\n}\r\n\r\nconst simID = that?.tags?.simID;\r\n\r\nif (simID) {\r\n    if (!tags.actionTriggers.includes(simID)) {\r\n        tags.actionTriggers.push(simID);\r\n        tags.lineTo.push(that?.id);\r\n    }\r\n}\r\n\r\ntags.choosingTrigger = false;","labelFontSize":"1","resetLineTo":"@const triggers = tags.actionTriggers ?? [];\r\nconst triggerFilter = tags.actionTriggerFilter ?? [];\r\n\r\nconst newLineTo = [];\r\n\r\nfor (let i = 0; i < triggers.length; ++i) {\r\n    const tempTriggerBot = getBot(\"simID\", triggers[i]);\r\n    if (tempTriggerBot) {\r\n        newLineTo.push(tempTriggerBot.id);\r\n    }\r\n}\r\n\r\ntags.lineTo = newLineTo;","simSmartReaction":"true"}}}}