{"version":1,"state":{"976ddd8a-da9a-46d8-a652-70c46fd0b457":{"id":"976ddd8a-da9a-46d8-a652-70c46fd0b457","space":"shared","tags":{"NoteEditor.css":":root {\n    --background: #f8f9fa;\n    --on-background: #212529;\n    --note-shadow: 5px 5px 10px rgba(0, 0, 0, 0.2);\n}\n\n/* Dark mode support */\n@media (prefers-color-scheme: dark) {\n    :root {\n        --background: #212529;\n        --on-background: #f8f9fa;\n        --note-shadow: 5px 5px 10px rgba(0, 0, 0, 0.6);\n    }\n}\n\n.note-editor {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  left: 0;\n  right: 0;\n  pointer-events: none;\n}\n\n.note-editor > * {\n  pointer-events: all;\n}\n\n.note-edit-modal {\n    position: absolute;\n    top: 50dvh;\n    left: 50vw;\n    transform: translate(-50%, -50%);\n    z-index: 1;\n    background-color: var(--background);\n    color: var(--on-background);\n    padding: 24px;\n    border-radius: 16px;\n    box-shadow: rgba(255, 255, 255, 0.1) 0px 1px 1px 0px inset, rgba(50, 50, 93, 0.25) 0px 50px 100px -20px, rgba(0, 0, 0, 0.3) 0px 30px 60px -30px;\n    min-width: min(95vw, 324px);\n}\n\n.note-edit-note {\n    width: 100%;\n    border: none;\n    outline: none;\n    padding: 12px 24px;\n    font-size: 16px;\n    margin: 4px 0px 1px 0px;\n    position: relative;\n    box-shadow: var(--note-shadow);\n    min-height: 256px;\n    min-width: 256px;\n}\n\n.note-edit-bg {\n    position: absolute;\n    z-index: 0;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    background-color: rgba(0, 0, 0, 0.25);\n    backdrop-filter: blur(4px);\n    -webkit-backdrop-filter: blur(4px);\n}\n\n.color-picker-container {\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    gap: 4px;\n    flex-wrap: wrap;\n    margin-bottom: 8px;\n}\n\n.sticky-color-btn {\n    height: 24px;\n    width: 24px;\n    outline: none;\n    border: none;\n    cursor: pointer;\n}\n\n.arrow-color-section {\n    width: 80%;\n    left: 50%;\n    outline: none;\n    padding: 12px 24px;\n    margin: -4px 0px 0px 0px;\n    position: relative;\n    box-shadow: var(--note-shadow);\n    transform: translate(-50%, 20%);\n    min-height: 10px;\n    min-width: 56px;\n    border: 2px solid #333;\n}\n\n.arrow-color-picker{\n    width: 100%;\n    border: none;\n    outline: none;\n    position: relative;\n}\n\n.arrow-color-picker-container {\n    width: 100%;\n    height: 40px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    gap: 4px;\n    flex-wrap: wrap;\n}\n\n.sticky-arrow-color-btn {\n    height: 24px;\n    width: 24px;\n    outline: none;\n    border: none;\n    cursor: pointer;\n    background-color: #444;\n    font-size: 36px;\n    line-height: 0px;\n    font-weight: 700;\n}\n\n.arrow-color-picker-header{\n    width: 100%;\n    border: none;\n    outline: none;\n    /* padding: 12px 24px; */\n    font-size: 20px;\n    font-weight: 500;\n    margin: 0px 0px 0px 0px;\n    position: relative;\n}\n\n.arrow-width-picker-container{\n    width: 100%;\n    height: 40px;\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    gap: 4px;\n    flex-wrap: wrap;\n}\n\n.arrow-width-picker{\n    width: 60%;\n    height: 40px;\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n    gap: 4px;\n    flex-wrap: wrap;\n}\n\n.shape-picker-container {\n    display: flex;\n    flex-direction: row;\n    justify-content: space-between;\n    align-items: center;\n    margin-bottom: 8px;\n    gap: 4px;\n}","abIgnore":true,"addSticky":"@\n\nconst dim = os.getCurrentDimension();\n\nconst botData = {\n    color: \"#f9c74f\",\n    labelColor: '#000000',\n    abIgnore: true,\n    sticky: true,\n    scaleX: 0.9,\n    scaleY: 0.9,\n    scaleZ: 0.125,\n    ...tags.stickyTags\n}\nbotData[dim] = true;\n\ncreate(botData);","appVersion":"0.2","getNoteEditor":"@const { useState, useEffect, useCallback } = os.appHooks;\nconst NOTE_COLORS = [\n    {color: \"#D46582\", labelColor: \"#000000\"}, // red\n    {color: \"#E99E5B\", labelColor: \"#000000\"}, // orange\n    {color: \"#ECD163\", labelColor: \"#000000\"}, // yellow\n    {color: \"#6DD35E\", labelColor: \"#000000\"}, // green\n    {color: \"#55C9A6\", labelColor: \"#000000\"}, // turquoise\n    {color: \"#77DFEA\", labelColor: \"#000000\"}, // cyan\n    {color: \"#8C97F4\", labelColor: \"#000000\"}, // lavender\n    {color: \"#B181C1\", labelColor: \"#000000\"}, // purple\n    {color: \"#D899C0\", labelColor: \"#000000\"}, // pink\n    {color: '#030303', labelColor: \"#ffffff\"}, // black\n]\n\nconst RecordPicker = ({ stickyRecord, botId }) => {\n\n    return;\n    const [input, setInput] = useState(stickyRecord);\n    const [address, setAddress] = useState(undefined);\n    const [editing, setEditing] = useState(false);\n\n    const handleCheck = () => {\n        os.showConfirm({\n            title: 'Pull stickies?',\n            content: 'This will get other sticky notes stored in this record.',\n            confirmText: 'Pull',\n            cancelText: \"Don't Pull\",\n        }).then(choice => {\n            if (choice) {\n                thisBot.pullStickies({recordName: input})\n            }\n            if (input !== stickyRecord) {\n                thisBot.moveSticky({botId: botId, newRecord: input, newAddress: address}).then((res) => {\n                    if (!res.success) {\n                        os.toast(\"Error moving sticky note\");\n                        setInput(stickyRecord);\n                    }\n                });\n            }\n            setEditing(false);\n        })\n    }\n\n    const handleAddRecord = () => {\n        os.requestAuthBot().then(authBot => {\n            os.showInput(`stickies-${authBot.id}`,\n                {title: 'Record Name'}\n            ).then(recordName => {\n                if (recordName) {\n                    getBot(byID(botId)).tags.stickyRecord = recordName;\n                    setInput(recordName);\n                    handleCheck();\n                }\n\n            })\n        })\n    }\n\n    if (!input) {\n        return (\n            <div style={{margin: '8px 0'}}>\n                <button\n                    className=\"md-button\"\n                    onClick={handleAddRecord}\n                    style={{\n                        color: 'var(--on-background)',\n                        background: 'var(--background)',\n                        padding: '4px 8px',\n                        border: '2px solid var(--on-background)',\n                        margin: '0',\n                        flexGrow: 1,\n                        textTransform: 'none',\n                        overflow: \"visible\",\n                        position: \"relative\"\n                    }}\n                >\n                    Save to Cloud\n                </button>\n            </div>\n        )\n    }\n\n    return (\n        <div style={{display: 'flex', margin: '8px 0', alignItems: 'center'}}>\n            <div\n                style={{\n                    marginRight: '4px',\n                    maxWidth: '196px',\n                    overflowX: 'hidden',\n                    textOverflow: 'ellipses'\n                }}\n            >record:</div>\n\n            {!editing && <div\n                style={{\n                    maxWidth: '196px',\n                    overflowX: 'hidden',\n                    textOverflow: 'ellipsis',\n                    whiteSpace: 'nowrap'\n                }}\n            >{input}</div>}\n\n            {editing && <input\n                className=\"md-input\"\n                value={input}\n                placeholder={`stickies-${authBot.id}`}\n                onChange={e => setInput(e.target.value)}\n                onKeyDown={e => {\n                    setInput(e.target.value);\n                    if (e.key === \"Enter\") {\n                        handleCheck();\n                    }\n                }}\n                style={{\n                    height: '24px',\n                    background: 'var(--background)',\n                    color: 'var(--on-background)',\n                    border: '2px solid var(--on-background)',\n                    outline: 'none',\n                    padding: '0 4px',\n                    flexGrow: 1,\n                    borderRadius: '4px',\n                    margin: '0 4px 0 0',\n                }}\n            />}\n\n            {!editing && <button\n                className=\"md-button\"\n                onClick={() => setEditing(true)}\n                style={{\n                    color: 'var(--on-background)',\n                    background: 'var(--background)',\n                    width: '24px',\n                    height: '24px',\n                    borderRadius: '4px',\n                    margin: '0 4px 0 4px',\n                    minWidth: '0',\n                }}\n            >\n                <span className=\"md-icon md-icon-font\"\n                    style={{\n                        transform: 'scale(0.75)'\n                    }}\n                >edit</span>\n            </button>}\n\n            {editing && <>\n                <button\n                    className=\"md-button\"\n                    onClick={handleCheck}\n                    style={{\n                        color: 'var(--on-background)',\n                        background: 'var(--background)',\n                        width: '24px',\n                        height: '24px',\n                        borderRadius: '4px',\n                        minWidth: '0',\n                        margin: '0',\n                    }}\n                >\n                    <span className=\"md-icon md-icon-font\"\n                        style={{transform: 'scale(0.75)'}}\n                    >\n                        check\n                    </span>\n                </button>\n\n                <button\n                    className=\"md-button\"\n                    onClick={() => {\n                        setEditing(false);\n                    }}\n                    style={{\n                        color: 'var(--on-background)',\n                        background: 'var(--background)',\n                        width: '24px',\n                        height: '24px',\n                        borderRadius: '4px',\n                        minWidth: '0',\n                        margin: '0',\n                    }}\n                >\n                    <span className=\"md-icon md-icon-font\"\n                        onClick={() => {\n                            setEditing(false);\n                            setInput(stickyRecord);\n                        }}\n                        style={{transform: 'scale(0.75)'}}\n                    >\n                        close\n                    </span>\n                </button>\n            </>}\n\n        </div>\n    )\n}\n\nconst ShapePicker = ({ botId }) => {\n\n    return; \n\n    const handleChange = (x, y) => {\n        const stickyBot = getBot(byID(botId))\n        stickyBot.tags.scaleX = x;\n        stickyBot.tags.scaleY = y;\n    }\n\n    return (\n        <div className=\"shape-picker-container\">\n            {false && <button\n                className=\"shape-btn md-button md-button-small\"\n                onClick={() => handleChange(0.9, 2.9)}\n                style={{\n                    color: 'var(--on-background)',\n                    background: 'var(--background)',\n                    border: '2px solid var(--on-background)',\n                    padding: '4px 8px',\n                    margin: '0',\n                    flexGrow: 1,\n                }}\n            >\n                Tall\n            </button>}\n            <button\n                className=\"shape-btn md-button\"\n                onClick={() => handleChange(0.9, 0.9)}\n                style={{\n                    color: 'var(--on-background)',\n                    background: 'var(--background)',\n                    padding: '4px 8px',\n                    border: '2px solid var(--on-background)',\n                    margin: '0',\n                    flexGrow: 1,\n                }}\n            >\n                Square\n            </button>\n            <button\n                className=\"shape-btn md-button\"\n                onClick={() => handleChange(2.9, 0.9)}\n                style={{\n                    color: 'var(--on-background)',\n                    background: 'var(--background)',\n                    padding: '4px 8px',\n                    border: '2px solid var(--on-background)',\n                    margin: '0',\n                    flexGrow: 1,\n                }}\n            >\n                Wide\n            </button>\n        </div>\n    )\n}\n\nconst ColorPicker = ( { onChange } ) => {\n    const handleUpdateColor = (color, labelColor) => {\n        onChange(color, labelColor);\n    }\n\n    return (\n        <div className=\"color-picker-container\">\n            {NOTE_COLORS.map(c => {\n                return (\n                    <button\n                        className=\"sticky-color-btn\"\n                        onClick={() => handleUpdateColor(c.color, c.labelColor)}\n                        style={{ backgroundColor: c.color }}\n                    />\n                )\n            })}\n        </div>\n    )\n}\n\nconst ArrowColorPicker = ( { onChange } ) => {\n    const handleUpdateArrowColor = (color) => {\n        onChange(color);\n    }\n\n    return (\n        <div className=\"arrow-color-picker-container\">\n            {NOTE_COLORS.map(c => {\n                return (\n                    <button\n                        className=\"sticky-arrow-color-btn\"\n                        onClick={() => handleUpdateArrowColor(c.color)}\n                        style={{ color: c.color }}\n                    >\n                    {\"-\"}\n                    </button>\n                )\n            })}\n        </div>\n    )\n}\n\nconst ArrowWidthPicker = ({botId, onChange, count} ) => {\n    const handleUpdateArrowWidth = (width) => {\n        onChange(width);\n    }\n    \n    let width = count;\n\n    // let width = getBot(\"id\", botId).tags.lineWidth;\n    if(width == undefined){\n        width = 4;\n    }\n\n    return (\n        <div className=\"arrow-width-picker-container\">\n            {\"Line Width: \" + width}\n            <input className=\"arrow-width-picker\" \n                type=\"range\" \n                min=\"1\" \n                max=\"20\" \n                value={width}\n                onInput={(event) => {\n                    let val = event.currentTarget.value;\n                    if(val < 1){\n                        val = 1\n                    }\n                    else if(val > 20){\n                        val = 20;\n                    }\n                    handleUpdateArrowWidth(val);\n                }}\n            >\n            </input>\n        </div>\n    )\n}\n\nconst ImportButton = () => {\n    const [recordAddressOptions, setRecordAddressOptions] = useState([]);\n    const [recordName, setRecordName] = useState();\n    const [showRecordOptions, setShowRecordOptions] = useState(false);\n\n    useEffect (() => {\n        recordOptions();\n    }, []);\n\n    const recordOptions = async () => {\n        const container = [];\n        const authBot = await os.requestAuthBot();\n        const data = await os.listData(`stickies-${authBot.id}`);\n        setRecordName(`stickies-${authBot.id}`);\n        for (let i = 0; i < data?.items?.length; ++i) {\n            container.push(data.items[i].address)\n        }\n        setRecordAddressOptions(container);\n    }\n\n    const addressOptions = useCallback(() => {\n        const container = [];\n        for (let i = 0; i < recordAddressOptions.length; ++i) {\n            container.push(\n                <div \n                    style={{\n                        borderBottom: '2px solid var(--on-background)',\n                        padding: '4px 8px',\n                    }}\n                    onClick={() => {\n                        thisBot.pullStickies({recordName: recordName, address: recordAddressOptions[i]});\n                    }}\n                > {recordAddressOptions[i]} </div>\n            )\n        }\n        return container;\n    }, [recordName])\n\n     return (\n            <div style={{margin: '8px 0'}}>\n                <button\n                    className=\"md-button\"\n                    onClick={async () => {\n                        await recordOptions();\n                        setShowRecordOptions(!showRecordOptions);\n                    }}\n                    style={{\n                        color: 'var(--on-background)',\n                        background: 'var(--background)',\n                        padding: '4px 8px',\n                        border: '2px solid var(--on-background)',\n                        margin: '0',\n                        flexGrow: 1,\n                        textTransform: 'none',\n                        overflow: \"visible\",\n                        position: \"relative\",\n                        marginBottom: \"10px\"\n                    }}\n                >\n                    Import Stickies\n                    {showRecordOptions && <div style={{\n                            display: \"flex\",\n                            color: 'var(--on-background)',\n                            background: 'var(--background)',\n                            border: '2px solid var(--on-background)',\n                            margin: '0',\n                            flexGrow: 1,\n                            textTransform: 'none',\n                            position: \"absolute\",\n                            zIndex: \"5\",\n                            flexDirection: \"column\",\n                            left: \"0\",\n                            top: \"100%\",\n                            maxHeight: \"500%\",\n                            overflow: \"auto\"\n                        }}>\n                        {addressOptions()}\n                    </div>}\n                </button>\n            </div>\n        )\n}\n\nconst SaveButton = ({ stickyRecord, address, botId, setRecordName, setAddress }) => {\n\n    const handleSaveClick = useCallback(async () => {\n        const authBot = await os.requestAuthBot();\n        const newRecordName = await os.showInput(stickyRecord || `stickies-${authBot.id}`, {title: 'Choose Record (Disregard for personal record)'}).then(async newRecordName => {\n            const newAddressName = await os.showInput(address || \"\", {title: 'Name your sticky'}).then(newAddressName => {\n                console.log(\"tymte\");\n                if (newRecordName && newRecordName != stickyRecord) {\n                    thisBot.moveSticky({botId: botId, newRecord: newRecordName, newAddress: newAddressName || address}).then((res) => {\n                        if (!res.success) {\n                            os.toast(\"Error moving sticky note\");\n                            setRecordName(newRecordName);\n                            setAddress(newAddressName);\n                        }\n                    });\n                }\n            })\n        })\n        \n    }, [stickyRecord, botId]);\n\n    return (\n        <img             \n            src=\"https://brandplayer-prod-filesbucket-458964701190.s3.amazonaws.com/6db28ddc-1835-4fb4-8ed3-5ccf26c02217/20fd9a39529055ee1f00b91aba4a21a485155682d81c7ddaaed8289ee75cf257.png\"\n            onClick={() => {\n                handleSaveClick()\n            }} \n        />\n    )\n}\n\nconst App = ( { botId, label, color, labelColor, lineColor, lineWidth } ) => {\n    const [content, setContent] = useState(label);\n    const [colorState, setColorState] = useState(color);\n    const [arrowColorState, setArrowColorState] = useState(lineColor);\n    const [arrowWidthState, setArrowWidthState] = useState(lineWidth);\n    const [labelColorState, setLabelColorState] = useState(labelColor);\n\n    const [recordName, setRecordName] = useState();\n    const [address, setAddress] = useState();\n\n    const handleNoteChange = (e) => {\n        setContent(e.target.value);\n    }\n\n    const handleUpdateColor = (newColor, newLabelColor) => {\n        setColorState(newColor);\n        setLabelColorState(newLabelColor);\n    }\n\n    const handleUpdateArrowColor = (newColor) => {\n        setArrowColorState(newColor);\n    }\n\n    const handleUpdateArrowWidth = (width) => {\n        setArrowWidthState(width);\n    }\n\n    useEffect(() => {\n        const stickyBot = getBot(byID(botId));\n        stickyBot.tags.color = colorState;\n    }, [colorState])\n\n    useEffect(() => {\n        const stickyBot = getBot(byID(botId));\n        stickyBot.tags.labelColor = labelColorState;\n    }, [labelColorState])\n\n    useEffect(() => {\n        if(arrowColorState != undefined){\n            const stickyBot = getBot(byID(botId));\n            stickyBot.tags.lineColor = arrowColorState;\n\n            const arrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"stickyBotID\",botId));\n            if(arrowBots){\n                for(let i = 0; i < arrowBots.length;i++){\n                    arrowBots[i].tags.lineColor = arrowColorState;\n                }\n            }\n        }\n    }, [arrowColorState])\n\n    useEffect(() => {\n        if(arrowWidthState != undefined){\n            const stickyBot = getBot(byID(botId));\n            stickyBot.tags.lineWidth = arrowWidthState;\n\n            const arrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"stickyBotID\",botId));\n            if(arrowBots){\n                for(let i = 0; i < arrowBots.length;i++){\n                    arrowBots[i].tags.lineWidth = arrowWidthState;\n                }\n            }\n        }\n    }, [arrowWidthState])\n\n    useEffect(() => {\n        const stickyBot = getBot(byID(botId));\n        stickyBot.tags.stickyRecord = recordName;\n    }, [recordName]);\n\n    useEffect(() => {\n        const stickyBot = getBot(byID(botId));\n        stickyBot.tags.stickyAddress = address;\n    }, [address]);\n\n    const handleClose = () => {\n        var noteBot = getBot(byID(botId));\n        if (noteBot) { noteBot.tags.label = content }\n\n        shout(\"hideNoteEditor\");\n    }\n\n    return (<>\n        <style>{tags['NoteEditor.css']}</style>\n        <div className=\"note-editor\">\n            <div className=\"note-edit-modal\">\n                <div style={{display: \"flex\", justifyContent: \"space-between\"}}>\n                    <h2 style={{margin: '0 0 4px 0'}}>Edit {address || \"Note\"}</h2>\n                </div>\n\n                <RecordPicker\n                    stickyRecord={getBot(byID(botId)).tags.stickyRecord}\n                    botId={botId}\n                />\n\n                <ShapePicker botId={botId} />\n                \n                <textarea\n                    className=\"note-edit-note\"\n                    onChange={handleNoteChange}\n                    onKeyDown={handleNoteChange}\n                    onBlur={handleNoteChange}\n                    style={{\n                        backgroundColor: colorState,\n                        color: labelColorState,\n                        fontFamily: 'inherit',\n                    }}\n                >{content}</textarea>\n\n                <ColorPicker botId={botId} onChange={handleUpdateColor} />\n\n                <ArrowWidthPicker botId={botId} onChange={handleUpdateArrowWidth} count={arrowWidthState}/>\n                <ArrowColorPicker botId={botId} onChange={handleUpdateArrowColor} />\n\n                <div\n                    className=\"arrow-color-section\"\n                    style={{\n                        backgroundColor: arrowColorState,\n                        fontFamily: 'inherit',\n                    }}\n                ></div>\n                \n            </div>\n\n            <div className=\"note-edit-bg\" onClick={handleClose}/>\n        </div>\n    </>)\n}\n\nreturn App\n               \n//<ImportButton/>\n//<SaveButton stickyRecord={recordName} address={address} botId={botId} setRecordName={setRecordName} setAddress={setAddress}/>\n","hideNoteEditor":"@await os.unregisterApp('note-editor');","moveSticky":"@const {botId, newRecord, newAddress} = that;\nconst stickyBot = getBot(byID(botId));\n\nif (!stickyBot) {\n    throw new Error(\"[stickies] Tried to update a sticky note, but could not find the bot with ID:\", botId);\n}\n\nconst oldRecord = stickyBot.tags.stickyRecord;\nconst oldAddress = stickyBot.tags.stickyAddress;\nconst address = newAddress;\n\nconst stickyApp = getBot(\"system\", \"stickies.app\")\nif (!Array.isArray(stickyApp.vars.recordPermissions)) {\n    stickyApp.vars.recordPermissions = [];\n}\n\nif (!stickyApp.vars.recordPermissions.includes(oldRecord)) {\n    if (await os.grantInstAdminPermission(oldRecord)) {\n        stickyApp.vars.recordPermissions.push(oldRecord)\n    } else {\n        return { success: false }\n    }\n}\n\nstickyBot.tags.stickyRecord = newRecord;\nstickyBot.tags.stickyAddress = newAddress;\nconst writeResult = await stickyBot.handleUpdate();\nconsole.log(\"Write result:\", writeResult)\nif (writeResult?.success) {\n    if (oldRecord) {\n        await os.eraseData(oldRecord, oldAddress);\n    }\n} else {\n    os.toast(\"Could not move sticky note\")\n    return { success: false }\n}\n\nreturn { success: true }","onBotAdded":"@whisper(thisBot, \"onInit\", true)","onClick":"@// whisper(thisBot, \"onInit\", true)\nwhisper(thisBot, 'updateStickyTagData')","onCreate":"@tags.abIgnore = true;\nwhisper(thisBot, \"onInit\", true);","onGridClick":"@\nconst dim = os.getCurrentDimension();\n\n// remove the highlight box bot\nlet highlightBot = getBot(\"botID\", \"highlightSticky\")\ndestroy(highlightBot);\n\n// remove the edit nodes around the highlight box bot\n// let editNodes = getBots(\"botID\", \"stickyScaleNode\");\n// destroy(editNodes);\n\nlet scaleBots = getBots(\"botID\", \"stickyScaleNode\");\ndestroy(scaleBots);\nlet arrowBots = getBots(\"botID\", \"stickyArrowNode\");\n// destroy(arrowBots);\n\nfor(let i = 0; i < arrowBots.length; i++){\n    arrowBots[i].tags.pointable = false;\n    // arrowBots[i].tags.color = \"red\";\n    arrowBots[i].tags.color = \"clear\";\n}","onInit":"@// Get a list of who is in the inst\nconst remotes = await os.remotes();\ntags.playerList = remotes;\n\nawait os.sleep(500);\n\nif(!configBot){\n    return;\n}\n\n// Move this player to the front if they are in the grid portal\n// (push other portals to the back to keep interactions in the grid)\nif (configBot.tags.gridPortal &&\n    !configBot.tags.sheetPortal &&\n    !configBot.tags.systemPortal\n    ) {\n    const myID = configBot.id\n    remotes.sort((a,b) => { return a === myID ? -1 : b === myID ? 1 : 0 });\n    tags.playerList = remotes;\n}\n\nshout(\"stickiesAppLoaded\");","onInstStreaming":"@whisper(thisBot, \"onInit\");","onRemoteLeave":"@whisper(thisBot, \"onInit\");","onStickyArrowDrag":"@\nos.enableCustomDragging();\n\nconst dim = thisBot.vars.dimension;\nconst deltaX = that.to.x - thisBot.vars.dragStart.x;\nconst deltaY = that.to.y - thisBot.vars.dragStart.y;\n\nlet arrowBot = getBot(\"botID\",\"editStickyNodeArrow\");\n\nif(!arrowBot){\n    return;\n}\n\narrowBot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\narrowBot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);","onStickyArrowDragStart":"@\nos.enableCustomDragging();\nabRemember.tags.abBotSnapState = false;\nabRemember.tags.abGridSnapState = false;\n\nconst dim = os.getCurrentDimension();\nthisBot.vars.dimension = dim;\n\nlet parent = getBot(\"id\", bot.tags.stickyHighlightID);\nparent.tags.pointable = false;\n\nlet stickyBot = getBot(\"id\", bot.tags.stickyBotID);\nstickyBot.tags.pointable = false;\n\nlet nodeScale = 0.1;\n\n// create a bot to pair the arrow to\nconst botData = {\n    space:\"tempLocal\",\n    botID: \"editStickyNodeArrow\",\n    stickyID: stickyBot.id,\n    nodeList: [],\n    color: 'clear',\n    abIgnore: true,\n    form: \"sphere\",\n    scaleX: nodeScale,\n    scaleY: nodeScale,\n    scaleZ: nodeScale,\n    pointable:false,\n}\n\nthisBot.vars.dragStart = {x: tags[`${dim}X`] ?? 0, y: tags[`${dim}Y`] ?? 0};\n\nbotData[`${dim}X`] = thisBot.vars.dragStart.x;\nbotData[`${dim}Y`] = thisBot.vars.dragStart.y;\nbotData[dim] = true;\nlet arrowTempBot = create(botData);\n\nbot.tags.lineStyle = \"line\";\nlet lineWidth = 4;\nif(stickyBot.tags.lineWidth != undefined){\n    lineWidth = stickyBot.tags.lineWidth;\n}\n\nbot.tags.lineWidth = lineWidth;\n\nlet lineColor = \"#000\";\nif(stickyBot.tags.lineColor != undefined){\n    lineColor = stickyBot.tags.lineColor;\n}\n\nbot.tags.lineColor = lineColor;\n\n\n// if this bot is not lined to any other node\nlet arrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"lineTo\"));\n\nlet existingConnection = false;\nlet nodeList = [];\n\nfor(let i = 0; i < arrowBots.length; i++){\n    // if the arrow node isn't this bot\n    if(arrowBots[i].id != bot.id){\n        let arr = [];\n        arr = arrowBots[i].tags.lineTo;\n\n        //if arrow node DOES have a lineTo\n        if(arr != undefined && arr.length > 0){\n            // check if it is a line to for this bot\n            for(let j = 0; j < arr.length; j++){\n                if(arr[j] == bot.id){\n                    existingConnection = true;\n                    nodeList.push(arrowBots[i].id);\n                    arr[j] = arrowTempBot.id;\n                    arrowBots[i].tags.lineTo = arr;\n                }\n            }\n        }\n    }\n}\n\nif(!existingConnection){\n    nodeList.push(bot.id);\n\n    if(bot.tags.lineTo != undefined && Array.isArray(bot.tags.lineTo)){\n        let arr = bot.tags.lineTo;\n        arr.push(arrowTempBot.id);\n        bot.tags.lineTo = arr;\n    }\n    else{\n        bot.tags.lineTo = [arrowTempBot.id];\n    }\n}\n\narrowTempBot.tags.nodeList = nodeList;","onStickyArrowDragStop":"@\nabRemember.tags.abBotSnapState = true;\nabRemember.tags.abGridSnapState = true;\n\nlet arrowBots = getBots(\"botID\", \"editStickyNodeArrow\");\nif(!arrowBots){\n    return;\n}\n\ndestroy(arrowBots);\n\nlet parent = getBot(\"id\", bot.tags.stickyHighlightID);\nif(!parent){\n    return;\n}\nparent.tags.pointable = true;\n\nlet selectedBot = getBot(\"id\", parent.tags.selectedBot);\nif(!selectedBot){\n    return;\n}\nselectedBot.tags.pointable = true;\n\nlet stickyBot = getBot(\"id\", bot.tags.stickyBotID);\nif(!stickyBot){\n    return;\n}\nstickyBot.tags.pointable = true;\n\nsetTagMask(thisBot.vars.selectedBots, 'pointable', null);\nthisBot.vars.selectedBots = null;\nthisBot.vars.dimension = null;\nthisBot.vars.startingPoints = null;\nthisBot.vars.dragStart = null;","onStickyArrowEnter":"@\nlet arrowTempBot = getBot(\"botID\", \"editStickyNodeArrow\");\n\nif(arrowTempBot){\n\n    // get all of the nodes that make an arrow to the temp arrow node\n    let arr = [];\n    arr = arrowTempBot.tags.nodeList;\n\n    // make sure it isn't null\n    if(arr != undefined){\n        // loop through all of the nodes connected to the temp\n        for(let i = 0; i < arr.length; i++){\n\n            // get the bot that is connected to the temp arrow from ids\n            let arrowNodeBot = getBot(\"id\", arr[i]);\n\n            // check arrow bot exists, that this bot is not the same as the bot an arrow is coming from\n            if(arrowNodeBot && arr[i] != bot.id){\n                let lines = [];\n                lines = arrowNodeBot.tags.lineTo;\n\n                if(lines != undefined && lines.length > 0){\n                    // swap the line to to this bot\n                    for(let j = 0; j < lines.length; j++){\n                        if(lines[j] == arrowTempBot.id){\n                            lines[j] = bot.id;\n                            arrowNodeBot.tags.lineTo = lines;\n                        }\n                    }\n                }else{\n                    arrowNodeBot.tags.lineTo = [bot.id];\n                }\n            }\n        }\n    }\n}","onStickyArrowExit":"@\nlet arrowTempBot = getBot(\"botID\", \"editStickyNodeArrow\");\n\nif(arrowTempBot){\n\n    // get all of the nodes that make an arrow to the temp arrow node\n    let arr = [];\n    arr = arrowTempBot.tags.nodeList;\n\n    // make sure it isn't null\n    if(arr != undefined){\n        // loop through all of the nodes connected to the temp\n        for(let i = 0; i < arr.length; i++){\n\n            // get the bot that is connected to the temp arrow from ids\n            let arrowNodeBot = getBot(\"id\", arr[i]);\n\n            // check arrow bot exists, that this bot is not the same as the bot an arrow is coming from\n            if(arrowNodeBot){\n                let lines = [];\n                lines = arrowNodeBot.tags.lineTo;\n\n                if(lines != undefined && lines.length > 0){\n                    // swap the line to to this bot\n                    for(let j = 0; j < lines.length; j++){\n                        if(lines[j] == bot.id){\n                            lines[j] = arrowTempBot.id;\n                            arrowNodeBot.tags.lineTo = lines;\n                        }\n                    }\n                }else{\n                    arrowNodeBot.tags.lineTo = [arrowTempBot.id];\n                }\n            }\n        }\n    }\n}","onStickyScaleDrag":"@\nos.enableCustomDragging();\n\nlet parent = getBot(\"id\", bot.tags.stickyHighlightID);\n\nconst dim = thisBot.vars.dimension;\nlet deltaX = that.to.x - thisBot.vars.dragStart.x;\nlet deltaY = that.to.y - thisBot.vars.dragStart.y;\n\nlet isSnapping = true;\n\nlet selBots = getBots(\"selected\", true);\n\nif(selBots.length == 1){\n\n// adjust for changes to BOTTOM LEFT scale node\n    if(bot.tags.stickyNodeID == 0){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.45;\n            deltaY -= 0.55;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x - deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y - deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to BOTTOM RIGHT scale node\n    else if(bot.tags.stickyNodeID == 1){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.55;\n            deltaY -= 0.55;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x + deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y - deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to TOP RIGHT scale node\n    else if(bot.tags.stickyNodeID == 2){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.55;\n            deltaY -= 0.45;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x + deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y + deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to TOP LEFT scale node\n    else if(bot.tags.stickyNodeID == 3){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.45;\n            deltaY -= 0.45;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x - deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y + deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n    }\n\n\n    // set the sticky note to matche the hightlight scale\n    let stickyBot = getBot(\"id\", parent.tags.selectedBot);\n\n    stickyBot.tags.scaleX = parent.tags.scaleX - 0.2;\n    stickyBot.tags[`${dim}X`] = parent.tags[`${dim}X`];\n\n    stickyBot.tags.scaleY = parent.tags.scaleY - 0.2;\n    stickyBot.tags[`${dim}Y`] = parent.tags[`${dim}Y`];\n\n\n\n    // whisper(bot, \"onUpdateNodePositions\");\n\n    // adjust other nodes to match changes\n    let scaleBots = getBots(byTag(\"botID\", \"stickyScaleNode\"), byTag(\"stickyBotID\", bot.tags.stickyBotID));\n    let arrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"stickyBotID\", bot.tags.stickyBotID));\n\n    // console.log(\"dragging still, \", nodeBots);\n    for(let i = 0; i < scaleBots.length; i++){\n        let id = scaleBots[i].tags.stickyNodeID;\n        // console.log(\"1dddddddddddd: \", id);\n        // let test = true;\n        if(bot.tags.stickyNodeID != id){\n            // console.log(\"2dddddddddddd: \", id);\n            let x = 0;\n            let y = 0;\n\n            if(id < 4){\n                if(id == 0){\n                    x = -parent.tags.scaleX/2;\n                    y = -parent.tags.scaleY/2;\n                }\n                else if(id == 1){\n                    x = parent.tags.scaleX/2;\n                    y = -parent.tags.scaleY/2;\n                }\n                else if(id == 2){\n                    x = parent.tags.scaleX/2;\n                    y = parent.tags.scaleY/2;\n                }\n                else if(id == 3){\n                    x = -parent.tags.scaleX/2;\n                    y = parent.tags.scaleY/2;\n                }\n            \n                scaleBots[i].tags[`${dim}X`] = parent.tags[`${dim}X`] + x;\n                scaleBots[i].tags[`${dim}Y`] = parent.tags[`${dim}Y`] + y;\n            }    \n        }\n    }\n\n    for(let i = 0; i < arrowBots.length; i++){\n        let id = arrowBots[i].tags.stickyNodeID;\n        // console.log(\"1dddddddddddd: \", id);\n\n        let arrowOffset = 0.25;\n\n        let stickyBot = getBot(\"id\", arrowBots[i].tags.stickyBotID);\n\n        let test = true;\n        if(bot.tags.stickyNodeID != id){\n            // console.log(\"2dddddddddddd: \", id);\n            let x = 0;\n            let y = 0;\n\n            let arrowOffset = 0.25;\n\n            if(id == \"N\"){\n                x = 0;\n                y = stickyBot.tags.scaleY/2 + arrowOffset;\n            }\n            else if(id == \"E\"){\n                x = stickyBot.tags.scaleX/2 + arrowOffset;\n                y = 0;\n            }\n            else if(id == \"S\"){\n                x = 0;\n                y = -stickyBot.tags.scaleY/2 - arrowOffset;\n            }\n            else if(id == \"W\"){\n                x = -stickyBot.tags.scaleX/2 - arrowOffset;\n                y = 0;\n            }\n\n            // set the nodes to be the cardinal arrow making nodes\n            arrowBots[i].tags[`${dim}X`] = stickyBot.tags[`${dim}X`] + x;\n            arrowBots[i].tags[`${dim}Y`] = stickyBot.tags[`${dim}Y`] + y;\n        }\n    }\n\n}\nelse{\n\n    selBots = thisBot.vars.selectedSticky;\n    if(bot.tags.stickyNodeID == 0){\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.45;\n            deltaY -= 0.55;\n        }\n\n        // move the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x - deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y - deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n\n        for(let i = 0; i < selBots.length; i++){\n            let selectedBot = selBots[i];\n\n            selectedBot.tags.scaleX = thisBot.vars.selectScaleStart[i].x - deltaX;\n            selectedBot.tags[`${dim}X`] = thisBot.vars.selectPosStart[i].x + deltaX/2;\n\n            selectedBot.tags.scaleY = thisBot.vars.selectScaleStart[i].y - deltaY;\n            selectedBot.tags[`${dim}Y`] = thisBot.vars.selectPosStart[i].y + deltaY/2;\n        }\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to BOTTOM RIGHT scale node\n    else if(bot.tags.stickyNodeID == 1){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.55;\n            deltaY -= 0.55;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x + deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y - deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n\n        for(let i = 0; i < selBots.length; i++){\n            let selectedBot = selBots[i];\n\n            selectedBot.tags.scaleX = thisBot.vars.selectScaleStart[i].x + deltaX;\n            selectedBot.tags[`${dim}X`] = thisBot.vars.selectPosStart[i].x + deltaX/2;\n\n            selectedBot.tags.scaleY = thisBot.vars.selectScaleStart[i].y - deltaY;\n            selectedBot.tags[`${dim}Y`] = thisBot.vars.selectPosStart[i].y + deltaY/2;\n        }\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to TOP RIGHT scale node\n    else if(bot.tags.stickyNodeID == 2){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.55;\n            deltaY -= 0.45;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x + deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y + deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n\n        for(let i = 0; i < selBots.length; i++){\n            let selectedBot = selBots[i];\n\n            selectedBot.tags.scaleX = thisBot.vars.selectScaleStart[i].x + deltaX;\n            selectedBot.tags[`${dim}X`] = thisBot.vars.selectPosStart[i].x + deltaX/2;\n\n            selectedBot.tags.scaleY = thisBot.vars.selectScaleStart[i].y + deltaY;\n            selectedBot.tags[`${dim}Y`] = thisBot.vars.selectPosStart[i].y + deltaY/2;\n        }\n\n        // adjust other nodes to match changes\n    }\n    // adjust for changes to TOP LEFT scale node\n    else if(bot.tags.stickyNodeID == 3){\n\n        // adjust position for the node to remain at proper distance\n        if(isSnapping){\n            deltaX += 0.45;\n            deltaY -= 0.45;\n        }\n\n        // not the node to new grid position\n        bot.tags[`${dim}X`] = Number(thisBot.vars.dragStart.x + deltaX);\n        bot.tags[`${dim}Y`] = Number(thisBot.vars.dragStart.y + deltaY);\n\n        // scale the hightlight bot and shift it to match scale changes on X and Y\n        parent.tags.scaleX = thisBot.vars.parentScaleStart.x - deltaX;\n        parent.tags[`${dim}X`] = thisBot.vars.parentPosStart.x + deltaX/2;\n\n        parent.tags.scaleY = thisBot.vars.parentScaleStart.y + deltaY;\n        parent.tags[`${dim}Y`] = thisBot.vars.parentPosStart.y + deltaY/2;\n\n\n        for(let i = 0; i < selBots.length; i++){\n            let selectedBot = selBots[i];\n\n            selectedBot.tags.scaleX = thisBot.vars.selectScaleStart[i].x - deltaX;\n            selectedBot.tags[`${dim}X`] = thisBot.vars.selectPosStart[i].x + deltaX/2;\n\n            selectedBot.tags.scaleY = thisBot.vars.selectScaleStart[i].y + deltaY;\n            selectedBot.tags[`${dim}Y`] = thisBot.vars.selectPosStart[i].y + deltaY/2;\n        }\n    }\n\n    // whisper(bot, \"onUpdateNodePositions\");\n\n    for(let i = 0; i < selBots.length; i++){\n        let stickyArrowBots = getBots(byTag(\"botID\", \"stickyArrowNode\"), byTag(\"stickyBotID\",selBots[i].id));\n        whisper(stickyArrowBots, \"onStickyUpdated\", selBots[i].id);\n\n        let stickyScaleBots = getBots(byTag(\"botID\", \"stickyScaleNode\"), byTag(\"stickyBotID\",selBots[i].id));\n        whisper(stickyScaleBots, \"onStickyUpdated\", selBots[i].id);\n    }\n}\n\n\n\n","onStickyScaleDragStart":"@\nos.enableCustomDragging();\n\n// abRemember.tags.abBotSnapState = false;\n// abRemember.tags.abGridSnapState = false;\n\nconst dim = os.getCurrentDimension();\nthisBot.vars.dimension = dim;\n\nlet selBots = getBots(\"selected\", true);\n\nif(selBots.length == 1){\n    let parent = getBot(\"id\", bot.tags.stickyHighlightID);\n\n    let stickyBot = getBot(\"id\", parent.tags.selectedBot);\n    stickyBot.tags.pointable = false;\n\n    thisBot.vars.parentScaleStart = {x: parent.tags.scaleX, y: parent.tags.scaleY};\n    thisBot.vars.parentPosStart = {x: parent.tags[`${dim}X`] ?? 0, y: parent.tags[`${dim}Y`] ?? 0};\n\n    thisBot.vars.dragStart = {x: tags[`${dim}X`] ?? 0, y: tags[`${dim}Y`] ?? 0};\n}\nelse{\n    let parent = getBot(\"id\", bot.tags.stickyHighlightID);\n\n    thisBot.vars.selectScaleStart = [];\n    thisBot.vars.selectPosStart = [];\n\n    for(let i = 0; i < selBots.length; i++){\n        selBots[i].tags.pointable = false;\n\n        thisBot.vars.selectScaleStart.push({x: selBots[i].tags.scaleX, y: selBots[i].tags.scaleY});\n        thisBot.vars.selectPosStart.push({x: selBots[i].tags[`${dim}X`] ?? 0, y: selBots[i].tags[`${dim}Y`] ?? 0});\n    }\n\n    thisBot.vars.selectedSticky = selBots;\n    thisBot.vars.parentScaleStart = {x: parent.tags.scaleX, y: parent.tags.scaleY};\n    thisBot.vars.parentPosStart = {x: parent.tags[`${dim}X`] ?? 0, y: parent.tags[`${dim}Y`] ?? 0};\n\n    thisBot.vars.dragStart = {x: tags[`${dim}X`] ?? 0, y: tags[`${dim}Y`] ?? 0};\n}\n","onStickyScaleDragStop":"@\n// abRemember.tags.abBotSnapState = true;\n// abRemember.tags.abGridSnapState = true;\n\nlet selBots = getBots(\"selected\", true);\n\nif(selBots.length == 1){\n    let parent = getBot(\"id\", bot.tags.stickyHighlightID);\n\n    let stickyBot = getBot(\"id\", parent.tags.selectedBot);\n    stickyBot.tags.pointable = true;\n\n    setTagMask(thisBot.vars.selectedBots, 'pointable', null);\n    thisBot.vars.selectedBots = null;\n    thisBot.vars.dimension = null;\n    thisBot.vars.startingPoints = null;\n    thisBot.vars.dragStart = null;\n}else{\n    let parent = getBot(\"id\", bot.tags.stickyHighlightID);\n\n    for(let i = 0; i < selBots.length; i++){\n        selBots[i].tags.pointable = true;\n    }\n\n    setTagMask(thisBot.vars.selectedBots, 'pointable', null);\n    thisBot.vars.selectedBots = null;\n    thisBot.vars.dimension = null;\n    thisBot.vars.startingPoints = null;\n    thisBot.vars.dragStart = null;\n    thisBot.vars.selectedSticky = null;\n}","onStickyUpdate":"@\n// onStickyUpdate\n\nif(that == bot.tags.stickyBotID){\n    const dim = os.getCurrentDimension();\n\n    let x = 0;\n    let y = 0;\n\n    if(bot.tags.botID == \"stickyArrowNode\"){\n        let arrowOffset = 0.25;\n        let stickyBot = getBot(\"id\", that);\n\n        if(bot.tags[\"stickyNodeID\"] == \"N\"){\n            x = 0;\n            y = stickyBot.tags.scaleY/2 + arrowOffset;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == \"E\"){\n            x = stickyBot.tags.scaleX/2 + arrowOffset;\n            y = 0;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == \"S\"){\n            x = 0;\n            y = -stickyBot.tags.scaleY/2 - arrowOffset;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == \"W\"){\n            x = -stickyBot.tags.scaleX/2 - arrowOffset;\n            y = 0;\n        }\n\n        bot.tags[`${dim}X`] = stickyBot.tags[`${dim}X`] + x;\n        bot.tags[`${dim}Y`] = stickyBot.tags[`${dim}Y`] + y;\n    }\n    else if(bot.tags.botID == \"stickyScaleNode\"){\n        let highlightNode = getBot(\"id\", bot.tags.highlightBotID);\n        let stickyBot = getBot(\"id\", highlightNode.tags.selectedBot);\n\n\n        let selBots = getBots(\"selected\", true);\n\n        if(selBots.length == 1){\n            highlightNode.tags[`${dim}X`] = stickyBot.tags[`${dim}X`] + x;\n            highlightNode.tags[`${dim}Y`] = stickyBot.tags[`${dim}Y`] + y;\n        }\n        else{\n\n            let padding = 0.2;\n\n            // get info from the multi select\n            let minX = 0;\n            let minY = 0;\n            let maxX = 0;\n            let maxY = 0;\n\n            for(let i = 0; i < selBots.length; i++){\n                let sticky = selBots[i];\n\n                let x = sticky.tags[`${dim}X`];\n                let y = sticky.tags[`${dim}Y`];\n\n                let stickyScaleX = sticky.tags.scaleX + padding;\n                let stickyScaleY = sticky.tags.scaleY + padding;\n\n                let left = x - stickyScaleX/2;\n                let right = x + stickyScaleX/2;\n                let top = y + stickyScaleY/2;\n                let bottom = y - stickyScaleY/2;\n\n                if(i == 0 || left < minX){\n                    minX = left;\n                }\n\n                if(i == 0 || right > maxX){\n                    maxX = right;\n                }\n\n                if(i == 0 || top > maxY){\n                    maxY = top;\n                }\n\n                if(i == 0 || bottom < minY){\n                    minY = bottom;\n                }\n            }\n\n            let sx = (maxX - minX);\n            let sy = (maxY - minY);\n\n            // console.log(\"111xxxxxxxxxxxxxxxx: \", minY);\n            // console.log(\"222xxxxxxxxxxxxxxxx: \", maxY);\n            // console.log(\"333xxxxxxxxxxxxxxxx: \", sy);\n            // botData[\"scaleX\"] = sx;\n            // botData[\"scaleY\"] = sy;\n\n            let xx = (minX) + sx/2;\n            let yy = (minY) + sy/2;\n\n            // botData[`${dim}X`] = xx;\n            // botData[`${dim}Y`] = yy;\n\n            highlightNode.tags[`${dim}X`] = xx;\n            highlightNode.tags[`${dim}Y`] = yy;\n        }\n\n        if(bot.tags[\"stickyNodeID\"] == 0){\n            x = -highlightNode.tags.scaleX/2;\n            y = -highlightNode.tags.scaleY/2;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == 1){\n            x = highlightNode.tags.scaleX/2;\n            y = -highlightNode.tags.scaleY/2;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == 2){\n            x = highlightNode.tags.scaleX/2;\n            y = highlightNode.tags.scaleY/2;\n        }\n        else if(bot.tags[\"stickyNodeID\"] == 3){\n            x = -highlightNode.tags.scaleX/2;\n            y = highlightNode.tags.scaleY/2;\n        }\n\n        bot.tags[`${dim}X`] = highlightNode.tags[`${dim}X`] + x;\n        bot.tags[`${dim}Y`] = highlightNode.tags[`${dim}Y`] + y;\n    }\n}","playerList":["93265931-8092-43a0-a213-2c0c09c05f58","9e5de104-b493-4820-b594-a95941bd3110"],"pullStickies":"@const {recordName, address} = that;\nif (!recordName) { throw new Error(\"Did not specify a record when pulling stickies\") }\nos.toast(`Pulling stickies for record ${recordName}`)\n\nconst stickyApp = getBot(\"system\", \"stickies.app\")\nif (!Array.isArray(stickyApp.vars.recordPermissions)) {\n    stickyApp.vars.recordPermissions = [];\n}\n\ntags.pullingStickies = true;\nsetTimeout(() => {\n    tags.pullingStickies = null;\n}, 15000)\n\nif (!stickyApp.vars.recordPermissions.includes(recordName)) {\n    if (await os.grantInstAdminPermission(recordName)) {\n        stickyApp.vars.recordPermissions.push(recordName)\n    }\n}\n\nlet lastAddress;\nif (address) {\n    lastAddress = address;\n}\nlet stickyNotes = [];\n\nwhile (true) {\n    const result = await os.listData(recordName, lastAddress);\n    if (result.success) {\n        console.log(\"[stickies] Found stickyNotes\", result.items);\n        if (result.items.length) {\n            stickyNotes.push(...result.items);\n            lastAddress = result.items[result.items.length - 1].address;\n            \n        } else {\n            break;\n        }\n    } else {\n        os.toast(\"Failed to get sticky notes\");\n        console.log(\"[stickies] Failed to get sticky notes:\", result.errorMessage);\n        break;\n    }\n}\n\nconsole.log(\"[stickies] Found sticky notes:\", stickyNotes)\n\nshout(\"interruptSync\");\n\nconst stickyBots = getBots(b => {\n    return b.tags.sticky &&\n           !b.tags.abTool\n});\n\nsetTag(stickyBots, 'avoidDelete', true);\ndestroy(stickyBots, true);\n\nfor (var sticky of stickyNotes) {\n    var botData = {\n        stickyAddress: sticky.address,\n        stickyRecord: recordName,\n        ...sticky.data,\n        ...tags.stickyTags,\n        sticky: true,\n    }\n    delete botData['avoidDelete']\n    create(botData)\n}\n\ntags.pullingStickies = null;\nshout(\"hideNoteEditor\");","selectedStickies":[],"setStickyHighlight":"@\n// that = [botid, botid]\n\nif(that == undefined){\n    // hide highlight\n    return;\n}\n\nawait os.sleep(100);\n\nlet selBots = getBots(\"selected\", true);\n// console.log(\"mmmmmmmmmmmmmmm: \", selBots);\n\n// let selectedArray = [];\n// selectedArray = bot.tags.selectedStickies;\n\nlet padding = 0.2;\nconst dim = os.getCurrentDimension();\n\n// console.log(\"bbbbbbbbbbbbb: \", selectedArray);\n// bot.tags.selectedStickies = selectedArray;\n\nif(selBots.length == 1){\n    // slinge select\n\n    let selectedBot = getBot(\"id\", that[0]);\n\n    let highlightNode = getBot(\"botID\", \"highlightSticky\");\n    destroy(highlightNode);\n\n    let scaleBots = getBots(\"botID\", \"stickyScaleNode\");\n    destroy(scaleBots);\n\n    // create the highlight box bot\n    const botData = {\n        space:\"tempLocal\",\n        botID: \"highlightSticky\",\n        labelColor: '#000000',\n        abIgnore: true,\n        pointable:false,\n        color:\"clear\",\n        strokeColor: \"#3F58F6\",\n        strokeWidth: 4,\n        scaleZ: 0.1,\n        selectedBot:that[0],\n    }\n\n    botData[`${dim}X`] = selectedBot.tags[`${dim}X`];\n    botData[`${dim}Y`] = selectedBot.tags[`${dim}Y`];\n\n    botData[\"scaleX\"] = selectedBot.tags.scaleX + padding;\n    botData[\"scaleY\"] = selectedBot.tags.scaleY + padding;\n\n    botData[dim] = true;\n    create(botData);\n\n    // create the edit modes around the hightlight box bot\n    whisper(bot, \"setStickyNodes\", that);\n\n    let arrowBots = getBots(\"botID\", \"stickyArrowNode\");\n    // destroy(arrowBots);\n\n    for(let i = 0; i < arrowBots.length; i++){\n        arrowBots[i].tags.pointable = true;\n        arrowBots[i].tags.color = \"#3f58f6\";\n    }\n}\nelse if(selBots.length > 1){\n    // multi select\n\n    // get info from the multi select\n    let minX = 0;\n    let minY = 0;\n    let maxX = 0;\n    let maxY = 0;\n\n    for(let i = 0; i < selBots.length; i++){\n        let sticky = selBots[i];\n\n        let x = sticky.tags[`${dim}X`];\n        let y = sticky.tags[`${dim}Y`];\n\n        let stickyScaleX = sticky.tags.scaleX + padding;\n        let stickyScaleY = sticky.tags.scaleY + padding;\n\n        let left = x - stickyScaleX/2;\n        let right = x + stickyScaleX/2;\n        let top = y + stickyScaleY/2;\n        let bottom = y - stickyScaleY/2;\n\n        if(i == 0 || left < minX){\n            minX = left;\n        }\n\n        if(i == 0 || right > maxX){\n            maxX = right;\n        }\n\n        if(i == 0 || top > maxY){\n            maxY = top;\n        }\n\n        if(i == 0 || bottom < minY){\n            minY = bottom;\n        }\n    }\n\n    let highlightNode = getBot(\"botID\", \"highlightSticky\");\n    destroy(highlightNode);\n\n    let scaleBots = getBots(\"botID\", \"stickyScaleNode\");\n    destroy(scaleBots);\n\n\n    // create the highlight box bot\n    const botData = {\n        space:\"tempLocal\",\n        botID: \"highlightSticky\",\n        labelColor: '#000000',\n        abIgnore: true,\n        pointable:false,\n        color:\"clear\",\n        strokeColor: \"#3F58F6\",\n        strokeWidth: 4,\n        scaleZ: 0.1,\n        selectedBot:that[0],\n    }\n\n    let sx = (maxX - minX);\n    let sy = (maxY - minY);\n\n    // console.log(\"111xxxxxxxxxxxxxxxx: \", minY);\n    // console.log(\"222xxxxxxxxxxxxxxxx: \", maxY);\n    // console.log(\"333xxxxxxxxxxxxxxxx: \", sy);\n    botData[\"scaleX\"] = sx;\n    botData[\"scaleY\"] = sy;\n\n    let xx = (minX) + sx/2;\n    let yy = (minY) + sy/2;\n\n    botData[`${dim}X`] = xx;\n    botData[`${dim}Y`] = yy;\n\n    botData[dim] = true;\n    create(botData);\n\n    whisper(bot, \"setStickyNodes\", that);\n\n    // do not show arrows on multi select\n    let arrowBots = getBots(\"botID\", \"stickyArrowNode\");\n\n    for(let i = 0; i < arrowBots.length; i++){\n        arrowBots[i].tags.pointable = false;\n        arrowBots[i].tags.color = \"clear\";\n    }\n}","setStickyNodes":"@\nconst dim = os.getCurrentDimension();\nlet nodeScale = 0.1;\n\n// let editNodes = getBots(\"botID\", \"stickyScaleNode\");\n// destroy(editNodes);\n\nlet highlightNode = getBot(\"botID\", \"highlightSticky\");\n// let stickyNodes = getBots(\"stickyHighlightID\", highlightNode.id);\n\nconst botData = {\n    space:\"tempLocal\",\n    stickyHighlightID: highlightNode.id,\n    labelColor: '#000000',\n    abIgnore: true,\n    form: \"sphere\",\n    scaleX: nodeScale,\n    scaleY: nodeScale,\n    scaleZ: nodeScale,\n}\n\nlet x = 0;\nlet y = 0;\nlet z = 0.1;\n\n// generate the scale nodes (spheres) of the highlight\nfor(let i = 0; i < 4; i++){\n    if(i == 0){\n        x = -highlightNode.tags.scaleX/2;\n        y = -highlightNode.tags.scaleY/2;\n    }\n    else if(i == 1){\n        x = highlightNode.tags.scaleX/2;\n        y = -highlightNode.tags.scaleY/2;\n    }\n    else if(i == 2){\n        x = highlightNode.tags.scaleX/2;\n        y = highlightNode.tags.scaleY/2;\n    }\n    else if(i == 3){\n        x = -highlightNode.tags.scaleX/2;\n        y = highlightNode.tags.scaleY/2;\n    }\n\n    botData[\"botID\"] = \"stickyScaleNode\";\n    botData[\"stickyNodeID\"] = i;\n    botData[\"highlightBotID\"] = highlightNode.id;\n    botData[\"stickyBotID\"] = highlightNode.tags.selectedBot;\n\n    // set the nodes to be the corner scaling nodes\n    botData[\"color\"] = \"#fff\";\n    botData[`${dim}X`] = highlightNode.tags[`${dim}X`] + x;\n    botData[`${dim}Y`] = highlightNode.tags[`${dim}Y`] + y;\n    botData[`${dim}Z`] = z;\n\n    botData[\"onDrag\"] = bot.tags.onStickyScaleDragStart;\n    botData[\"onDragging\"] = bot.tags.onStickyScaleDrag;\n    botData[\"onDrop\"] = bot.tags.onStickyScaleDragStop;\n    botData[\"onStickyUpdated\"] = bot.tags.onStickyUpdate;\n\n    botData[dim] = true;\n    create(botData);\n}\n\nlet stickyBots = getBots(\"sticky\", true);\n\nfor(let j = 0; j < stickyBots.length; j++){\n\n    // set arrow nodes for sticky if they don't exist\n    for(let i = 0; i < 4; i++){\n        let directionArray = [\"N\", \"E\", \"S\", \"W\"];\n\n        let checkBot = getBot(byTag(\"stickyBotID\", stickyBots[j].id), byTag(\"stickyNodeID\", directionArray[i]))\n        if(checkBot){\n            checkBot.tags.color = \"#3f58f6\";\n            checkBot.tags.pointable = true;\n            checkBot.tags.stickyHighlightID = highlightNode.id;\n            continue;\n        }\n\n        botData[\"space\"] = \"shared\";\n        botData[\"botID\"] = \"stickyArrowNode\";\n        botData[\"stickyNodeID\"] = directionArray[i];\n\n        let stickyBot = stickyBots[j];\n        let arrowOffset = 0.25;\n\n        if(i == 0){\n            x = 0;\n            y = stickyBot.tags.scaleY/2 + arrowOffset;\n        }\n        else if(i == 1){\n            x = stickyBot.tags.scaleX/2 + arrowOffset;\n            y = 0;\n        }\n        else if(i == 2){\n            x = 0;\n            y = -stickyBot.tags.scaleY/2 - arrowOffset;\n        }\n        else if(i == 3){\n            x = -stickyBot.tags.scaleX/2 - arrowOffset;\n            y = 0;\n        }\n\n        botData[\"stickyBotID\"] = stickyBot.id;\n        // set the nodes to be the cardinal arrow making nodes\n        botData[\"color\"] = \"#3f58f6\";\n        botData[`${dim}X`] = stickyBot.tags[`${dim}X`] + x;\n        botData[`${dim}Y`] = stickyBot.tags[`${dim}Y`] + y;\n        botData[`${dim}Z`] = z;\n\n        botData[\"onDrag\"] = bot.tags.onStickyArrowDragStart;\n        botData[\"onDragging\"] = bot.tags.onStickyArrowDrag;\n        botData[\"onDrop\"] = bot.tags.onStickyArrowDragStop;\n        botData[\"onPointerEnter\"] = bot.tags.onStickyArrowEnter;\n        botData[\"onPointerExit\"] = bot.tags.onStickyArrowExit;\n        botData[\"onStickyUpdated\"] = bot.tags.onStickyUpdate;\n        \n        botData[dim] = true;\n        create(botData);\n    }\n}","showNoteEditor":"@await os.unregisterApp('note-editor');\n\nconst App = thisBot.getNoteEditor();\n\nawait os.registerApp('note-editor', thisBot);\nos.compileApp('note-editor', <App\n    botId={that.id}\n    label={that.tags.label}\n    color={that.tags.color}\n    labelColor={that.tags.labelColor ?? '#000000'}\n    lineColor={that.tags.lineColor ?? '#000000'}\n    lineWidth={that.tags.lineWidth ?? 4}\n/>);\n","stickyTags":"🧬{\"abToolbox\":true,\"abVersion\":\"9.65.1.1728323928059\",\"avoidDelete\":true,\"checkForUI\":\"@if (tags.checkingForStickyUI) return;\\n\\ntags.checkingForStickyUI = true;\\n\\nconst stickyAppBot = getBot(\\\"system\\\", \\\"stickies.app\\\");\\nif (!stickyAppBot) {\\n    await links.search.abLoadTool({ toolName: 'stickiesApp' });\\n} else {\\n    if (tags.firstLoad) {\\n        tags.firstLoad = false;\\n        let stickyAppBot = getBot(\\\"system\\\", \\\"stickies.app\\\");\\n        whisper(stickyAppBot, \\\"showNoteEditor\\\", thisBot);\\n        \\n    }  \\n}\\n\\ntags.checkingForStickyUI = null;\",\"deselect\":\"@masks.formOpacity = null;\\nmasks.homeZ = null;\\nmasks.selected = null;\\nmasks.strokeColor = 'clear';\\nmasks.strokeWidth = null;\",\"dimension\":\"home\",\"firstLoad\":true,\"handleUpdate\":\"@// Initialize updatesNeeded array if it doesn't exist\\nconst stickyApp = getBot(\\\"system\\\", \\\"stickies.app\\\")\\nif (!Array.isArray(stickyApp.tags.updatesNeeded)) { stickyApp.tags.updatesNeeded = [] }\\n// Add this bot to the updatesNeeded array\\nstickyApp.tags.updatesNeeded.push(thisBot.id);\\n\\nif (configBot.id !== stickyApp.tags.playerList[0]) {\\n    console.log(\\\"[stickies] Avoiding update\\\")\\n    os.sleep(5000).then(async () => {\\n        console.log(\\\"[stickies] checking that update happened\\\")\\n        if (getBot(\\\"system\\\", \\\"stickies.app\\\").tags.updatesNeeded.includes(thisBot.id)) {\\n            console.log(\\\"[stickies] update was lost, updating list of players\\\")\\n            // Reset the list of remotes\\n            await whisper(stickyApp, \\\"onInit\\\");\\n            // Re-try the update\\n            whisper(thisBot, \\\"handleUpdate\\\");\\n            return;\\n        }\\n        console.log(\\\"[stickies] update was successful\\\")\\n    })\\n    return\\n}\\n\\nconsole.log(\\\"[stickies] claiming update\\\")\\nstickyApp.tags.updatesNeeded = stickyApp.tags.updatesNeeded.filter(u => u !== thisBot.id);\\n\\n// Add address if it doesn't exist yet\\nconst authBot = await os.requestAuthBot();\\nif (!tags.stickyAddress) tags.stickyAddress = thisBot.id + '-' + new Date().toISOString();\\n\\nconst stickyRecord = tags.stickyRecord;\\nif (!stickyRecord) {\\n    os.toast(\\\"Error updating sticky note\\\");\\n    throw new Error(\\\"Tried to update a sticky note, but no record is selected\\\");\\n}\\n\\n// Grant record permission\\nif (!Array.isArray(stickyApp.vars.recordPermissions)) {\\n    stickyApp.vars.recordPermissions = [];\\n}\\n\\nif (!stickyApp.vars.recordPermissions.includes(stickyRecord)) {\\n    if (await os.grantInstAdminPermission(stickyRecord)) {\\n        stickyApp.vars.recordPermissions.push(stickyRecord)\\n    }\\n}\\n\\n// Trim data\\nconst payload = {...thisBot.tags};\\nconst tagsToDelete = tags.unstoredTags;\\nfor (var t of tagsToDelete) {\\n    delete payload[t];\\n}\\n\\n// Check if changed\\nconst hash = crypto.hash(\\\"sha256\\\", \\\"base64\\\", JSON.stringify(payload));\\nif (hash === tags.lastUpdateHash) { return };\\ntags.lastUpdateHash = hash;\\n\\n// Record definition\\nconst stickyRecordName = stickyRecord;\\nlet address = tags.stickyAddress\\nif (!address) {\\n    address = thisBot.id + '-' + new Date().toISOString();\\n    tags.stickyAddress = address;\\n}\\n\\n// Update in records\\nconst result = await os.recordData(stickyRecord, address, payload);\\nif (result.success) {\\n    console.log(\\\"[stickies] [stickies] Updated sticky note!\\\")\\n    return { success: true }\\n} else if (result.errorCode === \\\"record_not_found\\\") {\\n    const createResult = await os.getPublicRecordKey(stickyRecord);\\n    if (createResult.success) {\\n        whisper(thisBot, 'handleUpdate')\\n    }\\n} else if (result.errorCode === \\\"not_authorized\\\") {\\n    if (await os.grantInstAdminPermission(stickyRecord)) {\\n        whisper(thisBot, 'handleUpdate');\\n    }\\n} else {\\n    os.toast(\\\"Failed to update sticky note\\\");\\n    console.log(\\\"[stickies] [stickies] Failed to update sticky note:\\\", result)\\n    return { success: false }\\n}\\n\",\"interruptSync\":\"@if (thisBot.vars.cancelTimeout) {\\n    clearTimeout(thisBot.vars.cancelTimeout);\\n}\",\"labelPaddingX\":0.24,\"labelPaddingY\":0.12,\"lineColor\":\"#000000\",\"lineWidth\":4,\"listening\":true,\"onAnyBotClicked\":\"@if (\\n    that.bot.id !== thisBot.id &&\\n    !(configBot.tags.keyboard_Shift === 'held')\\n) {\\n    whisper(thisBot, 'onDeselect');\\n}\",\"onBotChanged\":\"@// Don't track if no record\\nif (!tags.stickyRecord) { return }\\n\\n// Don't update for masks\\nif (masks) {\\n    if (Object.keys(masks).some(m => that.tags.indexOf(m) >= 0)) {\\n        return\\n    }\\n}\\n\\n// Don't update unstored tags\\nif (tags.unstoredTags.some(m => that.tags.indexOf(m) >= 0)) {\\n    return\\n}\\n\\n// Clear previous timer\\nif (thisBot.vars.cancelTimeout) {\\n    clearTimeout(thisBot.vars.cancelTimeout);\\n}\\n\\n// Start 5s timer to update\\nthisBot.vars.cancelTimeout = setTimeout(() => {\\n    thisBot.vars.cancelTimeout = null;\\n    whisper(thisBot, \\\"handleUpdate\\\");\\n}, 5000);\",\"onClick\":\"@// First click\\nif (!thisBot.vars.doubleClickTimer) {\\n    if (masks.selected && !masks.justSelected) {\\n        const selectedBots = getBots(\\\"selected\\\");\\n        if (selectedBots.length === 1 || configBot.tags.keyboard_Shift) {\\n            whisper(thisBot, \\\"onDeselect\\\");\\n        }\\n    }\\n    thisBot.vars.doubleClickTimer = true;\\n    thisBot.vars.clickTimeout = setTimeout(() => {\\n        thisBot.vars.doubleClickTimer = null;\\n    }, 500);\\n\\n    let stickyAppBot = getBot(\\\"system\\\", \\\"stickies.app\\\");\\n    whisper(stickyAppBot, \\\"setStickyHighlight\\\", [bot.id]);\\n\\n    return;\\n}\\n\\n// Second click\\nif (!configBot.tags.keyboard_Shift) {\\n    whisper(thisBot, 'onDeselect');\\n\\n    let stickyAppBot = getBot(\\\"system\\\", \\\"stickies.app\\\");\\n    whisper(stickyAppBot, \\\"showNoteEditor\\\", thisBot);\\n}\",\"onCreate\":\"@if (tags.abIDOrigin == \\\"sticky\\\" && tags.system != \\\"toolbox1.tool.sticky\\\") {\\n    tags.firstLoad = true;\\n}\\n\\nwhisper(thisBot, 'checkForUI');\\n\\nconst stickyData = {...thisBot.tags};\\nconst unstoredTags = tags.unstoredTags;\\nfor (var t of unstoredTags) {\\n    delete stickyData[t];\\n}\\n\\ntags.abIgnore = true;\\n\\ntags.lastUpdateHash = crypto.hash(\\\"sha256\\\", \\\"base64\\\", JSON.stringify(stickyData));\",\"onDeselect\":\"@masks.formOpacity = null;\\nmasks.startingZ = null;\\nmasks.homeZ = null;\\nmasks.selected = null;\\nmasks.strokeColor = 'clear';\\nmasks.strokeWidth = null;\",\"onDestroy\":\"@if (tags.avoidDelete) return;\\n\\nconst result = os.eraseData(tags.stickyRecord, tags.stickyAddress);\\n\\nif (!result.success) {\\n    return\\n}\",\"onDrag\":\"@os.enableCustomDragging();\\nlet selectedBots = [];\\nif (masks.justSelected && !configBot.tags.keyboard_Shift) {\\n    shout('onDeselect');\\n    whisper(thisBot, 'onSelect');\\n    selectedBots.push(thisBot);\\n} else {\\n    selectedBots = getBots(\\\"selected\\\");\\n}\\n\\nthisBot.vars.selectedBots = selectedBots;\\nsetTagMask(selectedBots, 'pointable', false);\\n\\nconst dim = os.getCurrentDimension();\\nthisBot.vars.dimension = dim;\\n\\nthisBot.vars.dragStart = {x: tags[`${dim}X`] ?? 0, y: tags[`${dim}Y`] ?? 0};\\n\\nconst startingPoints = {};\\nfor (var b of selectedBots) {\\n    startingPoints[b.id] = {x: b.tags[`${dim}X`] ?? 0, y: b.tags[`${dim}Y`] ?? 0}\\n}\\nthisBot.vars.startingPoints = startingPoints;\",\"onDragging\":\"@const dim = thisBot.vars.dimension;\\nconst deltaX = that.to.x - thisBot.vars.dragStart.x;\\nconst deltaY = that.to.y - thisBot.vars.dragStart.y;\\n\\nfor (var b of thisBot.vars.selectedBots) {\\n    b.tags[`${dim}X`] = Number(thisBot.vars.startingPoints[b.id].x + deltaX);\\n    b.tags[`${dim}Y`] = Number(thisBot.vars.startingPoints[b.id].y + deltaY);\\n}\\n\\n\\nlet selBots = getBots(\\\"selected\\\", true);\\n\\nif(selBots.length == 1){\\n    let stickyArrowBots = getBots(\\\"botID\\\", \\\"stickyArrowNode\\\");\\n    whisper(stickyArrowBots, \\\"onStickyUpdated\\\", bot.id);\\n\\n    let stickyScaleBots = getBots(\\\"botID\\\", \\\"stickyScaleNode\\\");\\n    whisper(stickyScaleBots, \\\"onStickyUpdated\\\", bot.id);\\n}\\nelse{\\n    for(let i = 0; i < selBots.length; i++){\\n        let stickyArrowBots = getBots(byTag(\\\"botID\\\", \\\"stickyArrowNode\\\"), byTag(\\\"stickyBotID\\\",selBots[i].id));\\n        whisper(stickyArrowBots, \\\"onStickyUpdated\\\", selBots[i].id);\\n\\n        let stickyScaleBots = getBots(byTag(\\\"botID\\\", \\\"stickyScaleNode\\\"), byTag(\\\"stickyBotID\\\",selBots[i].id));\\n        whisper(stickyScaleBots, \\\"onStickyUpdated\\\", selBots[i].id);\\n    }\\n}\",\"onDrop\":\"@setTagMask(thisBot.vars.selectedBots, 'pointable', null);\\nthisBot.vars.selectedBots = null;\\nthisBot.vars.dimension = null;\\nthisBot.vars.startingPoints = null;\\nthisBot.vars.dragStart = null;\\n\\nif (masks.justSelected) {\\n    whisper(thisBot, \\\"onDeselect\\\")\\n}\",\"onDuplicate\":\"@if (tags.selected) {\\n    const payload = {...tags};\\n    delete payload.stickyAddress;\\n    delete payload[`${os.getCurrentDimension()}Z`];\\n    delete payload.strokeColor;\\n    delete payload.strokeWidth;\\n    delete payload.selected;\\n\\n    payload[`${os.getCurrentDimension()}X`] += 1;\\n    const newSticky = create(payload);\\n    whisper(newSticky, 'onPointerDown');\\n    whisper(newSticky, 'onSelect');\\n    whisper(newSticky, 'handleUpdate');\\n}\",\"onEggHatch\":\"@if (that.eggParameters) {\\n    const dimension = that.eggParameters.gridInformation?.dimension ?? 'home';\\n    const dimensionX = that.eggParameters.gridInformation?.position?.x ?? 0;\\n    const dimensionY = that.eggParameters.gridInformation?.position?.y ?? 0;\\n\\n    tags[dimension] = true;\\n    tags[dimension + 'X'] = dimensionX;\\n    tags[dimension + 'Y'] = dimensionY;\\n}\\n\",\"onGridClick\":\"@whisper(thisBot, 'onDeselect');\",\"onKeyDown\":\"@if (configBot.tags.keyboard_Meta === 'held' ||\\n    configBot.tags.keyboard_Control === 'held'\\n) {\\n    // Duplicate\\n    if (that.keys.includes('d')) {\\n        whisper(thisBot, 'onDuplicate')\\n    }\\n}\\n\",\"onPointerDown\":\"@if (!masks.selected) {\\n    whisper(thisBot, \\\"onSelect\\\");\\n    masks.justSelected = true;\\n}\",\"onPointerEnter\":\"@if (!masks.selected) {\\n    masks.formOpacity = 0.85\\n}\",\"onPointerExit\":\"@masks.formOpacity = null\",\"onPointerUp\":\"@masks.justSelected = null;\\nif (!masks.selected) {\\n    masks.homeZ = null;\\n}\",\"onSelect\":\"@masks.selected = true;\\nmasks.formOpacity = null;\\nmasks.strokeColor = \\\"#4bb1db\\\";\\nmasks.strokeWidth = 2;\\n\\nif (!masks.startingZ) masks.startingZ = tags.homeZ ?? 0;\\nmasks.homeZ = masks.startingZ + 0.15;\",\"pointable\":true,\"position\":{\"x\":7,\"y\":2},\"select\":\"@masks.selected = true;\\nmasks.formOpacity = null;\\nmasks.strokeColor = \\\"#4bb1db\\\"\\nmasks.strokeWidth = 2;\",\"sim_toolbox\":true,\"sim_toolboxX\":-0.5000000000000003,\"sim_toolboxY\":-7.500000000000001,\"startingZ\":0,\"stickiesAppLoaded\":\"@if (tags.firstLoad) {\\r\\n    tags.firstLoad = false;\\r\\n    shout(\\\"showNoteEditor\\\", thisBot);\\r\\n}\",\"toolbox1\":true,\"unstoredTags\":[\"abIDOrigin\",\"avoidDelete\",\"checkForUI\",\"creator\",\"handleUpdate\",\"interruptSync\",\"lastUpdateHash\",\"onAnyBotClicked\",\"onBotChanged\",\"onClick\",\"onCreate\",\"onDeselect\",\"onDestroy\",\"onDrag\",\"onDragging\",\"onDrop\",\"onDuplicate\",\"onGridClick\",\"onKeyDown\",\"onPointerDown\",\"onPointerEnter\",\"onPointerExit\",\"onPointerUp\",\"onSelect\",\"strokeColor\",\"strokeWidth\",\"selected\"],\"version\":0.2,\"search\":\"🔗d8371444-9158-4436-8fc7-84cc91b7f525\"}","system":"stickies.app","updateStickyTagData":"@const stickyBot = getBot('sticky', true);\nconst ignoredTags = [\n    'abIgnore',\n    'color',\n    'home',\n    'homeX',\n    'homeY',\n    'homeZ',\n    'label',\n    'labelColor',\n    'lastUpdateHash',\n    'sticky',\n    'stickyAddress',\n    'selected',\n    'strokeColor',\n    'strokeWidth',\n    'scaleX',\n    'scaleY',\n    'scaleZ',\n    'system',\n]\n\nconst payload = {...stickyBot.tags};\nfor (var t of ignoredTags) {\n    delete payload[t];\n}\n\ntags.stickyTags = `🧬${JSON.stringify(payload)}`;\nos.toast(\"Updated note data for future notes\");\n","updatesNeeded":["2ab72db0-1642-4de2-a320-5ceb108bdf08","68add269-df3a-4739-9ae3-c3c1ef8a0262","68add269-df3a-4739-9ae3-c3c1ef8a0262","68add269-df3a-4739-9ae3-c3c1ef8a0262","68add269-df3a-4739-9ae3-c3c1ef8a0262","68add269-df3a-4739-9ae3-c3c1ef8a0262","68add269-df3a-4739-9ae3-c3c1ef8a0262","0d82b55c-41df-4c1d-9f85-7b520a5de4fe","324d9182-9d77-46ba-82fb-d22f7c0672ba","0d82b55c-41df-4c1d-9f85-7b520a5de4fe","324d9182-9d77-46ba-82fb-d22f7c0672ba"],"stickiesApp":"true"}}}}