{"version":1,"state":{"4e451f26-832b-4533-9e06-c7044f0d8a49":{"id":"4e451f26-832b-4533-9e06-c7044f0d8a49","space":"shared","tags":{"system":"story_toolbox.storyCycle","basePrompt":"ðŸ“„`You are a state handler in a world with story elements and a narrator.\r\nYour job is to return the next logical state that targets might change to, given the current story.\r\nA given target is not required to change state every time, but you can change the state of more than one target at once.\r\nYou will recieve a message log to look through, a list of targets to include in your story and their editable data, and a current place the story is taking place in as well as what unit of positions are.\r\nIf the current place is undefined, disregard it.\r\nYou must not change a story element that is not in your list of possible targets.\r\nIf units are longitude, latitude do not exceed .0005 units of positional movement in any direction.\r\nIf units are in yards do not exceed 20 units of positional movement in any direction. \r\nZ is the height above the ground of the target.\r\nYou must always change the state of at least one target.\r\n\r\nYou MUST ONLY respond with an array, containing a list of valid JSON blocks for each target you want to change.\r\nDo not return only a string.\r\nEach position or scale MUST be a number, and MUST NOT include +, -, /, *, or %.\r\nDo not increase a scale larger than 4.0.\r\n\r\nEXAMPLES:\r\n\r\ngiven targets: \r\n[\r\n    {\r\n        label: \"Small Fox\",\r\n        positionX: 2,\r\n        positionY: 3,\r\n        positionZ: 0,\r\n        color: \"#e36f4c\",\r\n        scaleX: 1.5,\r\n        scaleY: 0.5,\r\n        scaleZ: 1\r\n    },\r\n    {\r\n        label: \"Old Tree\",\r\n        positionX: 0,\r\n        positionY: 0,\r\n        positionZ: 0,\r\n        color: \"#228B22\",\r\n        scaleX: 1.5,\r\n        scaleY: 1.5,\r\n        scaleZ: 3\r\n    }\r\n]\r\n\r\nRESPONSES:\r\n\r\n[\r\n    {\r\n        \"label\": \"Small Fox\",\r\n        \"positionX\": 6,\r\n        \"positionY\": 4,\r\n        \"positionZ\": 0,\r\n        \"color\": \"#e36f4c\",\r\n        \"scaleX\": 1.5,\r\n        \"scaleY\": 0.5,\r\n        \"scaleZ\": 1\r\n    },\r\n    {\r\n        \"label\": \"Old Tree\",\r\n        \"positionX\": 1,\r\n        \"positionY\": 0,\r\n        \"positionZ\": 0,\r\n        \"color\": \"#228B22\",\r\n        \"scaleX\": 1.5,\r\n        \"scaleY\": 1.5,\r\n        \"scaleZ\": 4\r\n    }\r\n]\r\n\r\nor (EXAMPLE: if the fox jumped in a river)\r\n\r\nRESPONSE: \r\n\r\n[\r\n    {\r\n        \"label\": \"Wet Small Fox\",\r\n        \"positionX\": 2,\r\n        \"positionY\": 10,\r\n        \"positionZ\": 0,\r\n        \"color\": \"#703625\",\r\n        \"scaleX\": 1.5,\r\n        \"scaleY\": 0.5,\r\n        \"scaleZ\": 1\r\n    }\r\n]\r\n\r\n`","onClick":"@const aiMessageArr = await thisBot.compileMessages();\r\n\r\nthisBot.askCycle(aiMessageArr);","compileMessages":"@const currentDim = ab.links.remember.tags.abActiveDimension;\r\nconst currentPortal = configBot.tags.mapPortal ? \"map\" : configBot.tags.gridPortal == \"blueprint\" ? \"blueprint\" :\"grid\";\r\n\r\n//Grab elements\r\nconst targetsArr = [];\r\nconst targets = getBots(\"storyElement\");\r\nfor (const bot of targets) {\r\n    targetsArr.push({\r\n        label: bot?.tags?.bbLabel,\r\n        positionX: bot?.tags[currentDim + 'X'],\r\n        positionY: bot?.tags[currentDim + 'Y'],\r\n        positionZ: bot?.tags[currentDim + 'Z'],\r\n        color: bot?.tags.color,\r\n        scaleX: bot?.tags.scaleX,\r\n        scaleY: bot?.tags.scaleY,\r\n        scaleZ: bot?.tags.scaleZ\r\n    });\r\n}\r\n\r\nconst aiMessageArr = [];\r\n\r\n//Get message log\r\nconst messageLogArr = [];\r\nif (links.console.vars.messageBotIds) {\r\n    const messageBots = links.console.vars.messageBotIds;\r\n\r\n    for (const botID of messageBots) {\r\n        const messageBot = getBot(\"id\", botID);\r\n        if (messageBot && messageBot.tags.space == \"shared\") {\r\n            messageLogArr.push({\r\n                message: messageBot.tags.message || \"\",\r\n                timestamp: messageBot.tags.timestamp,\r\n                name: messageBot.tags.name\r\n            })\r\n        }\r\n    }\r\n\r\n    messageLogArr.sort( (a, b) => new Date(a.timestamp) < new Date(b.timestamp) ? 1 : -1 );\r\n    messageLogArr.reverse();\r\n}\r\n\r\nfor (let i = 0; i < messageLogArr.length; ++i) {\r\n    aiMessageArr.push({\r\n        role: messageLogArr[i].name == tags.bbLabel ? \"assistant\" : \"user\",\r\n        content: messageLogArr[i].name == tags.bbLabel ? messageLogArr[i].message : messageLogArr[i].name + \": \" + messageLogArr[i].message\r\n    })\r\n}\r\n\r\n//Push system messages\r\naiMessageArr.push({\r\n    role: \"system\",\r\n    content: tags.basePrompt\r\n});\r\n\r\naiMessageArr.push({\r\n    role: \"system\",\r\n    content: \"possible targets: \" + JSON.stringify(targetsArr)\r\n});\r\n\r\naiMessageArr.push({\r\n    role: \"system\",\r\n    content: `current place: ${tags.currentStoryPlace}`\r\n});\r\n\r\naiMessageArr.push({\r\n    role: \"system\",\r\n    content: `position units are: ${currentPortal == \"map\" ? \"longitude, latitude\" : \"yards\"}`\r\n});\r\n\r\nconsole.log(\"aiMessageArr\", aiMessageArr);\r\n\r\nreturn aiMessageArr;","onStorySceneChange":"@tags.currentStoryPlace = that;\r\n","askCycle":"@if (!that) {\r\n    os.toast(\"[Story Cycle]: Could not find messages\");\r\n    return;\r\n}\r\n\r\nconst aiChatOptions: AIChatOptions = {\r\n    preferredModel: ab.links.personality.tags.abPreferredAIModel\r\n}\r\n\r\nlet response = await ai.chat(that, aiChatOptions);\r\nresponse = response.content.replace(/```json\\n?|```/g, '');\r\n\r\ntry {\r\n    response = JSON.parse(response);\r\n} catch (e) {\r\n    console.log(\"Error responding as story cycle: \", e, response);\r\n    return;\r\n}\r\n\r\nif (!response) {\r\n    return;\r\n}\r\n\r\nconsole.log(\"[Story Cycle]: \", response);\r\nif (Array.isArray(response)) {\r\n    const currentDim = ab.links.remember.tags.abActiveDimension;\r\n\r\n    for(const element of response) {\r\n        const elBot = getBot(\"bbLabel\", element?.label);\r\n        if (elBot) {\r\n            elBot.tags[currentDim + 'X'] = element?.positionX ?? elBot.tags[currentDim + 'X'];\r\n            elBot.tags[currentDim + 'Y'] = element?.positionY ?? elBot.tags[currentDim + 'Y']; \r\n            elBot.tags[currentDim + 'Z'] = element?.positionZ ?? elBot.tags[currentDim + 'Z'];\r\n            elBot.tags.bbLabel = element?.label ?? elBot.tags.bbLabel;\r\n            elBot.tags.color = element?.color ?? elBot.tags.color;\r\n            elBot.tags.scaleX = element?.scaleX ?? elBot.tags.scaleX;\r\n            elBot.tags.scaleY = element?.scaleY ?? elBot.tags.scaleY;\r\n            elBot.tags.scaleZ = element?.scaleZ ?? elBot.tags.scaleZ;\r\n        }\r\n    }\r\n} else {\r\n    console.log(\"[Story Cycle]: Response is not an array\");\r\n}","console":"ðŸ”—24b7e66f-0d5b-4064-bf48-b562b9e6e3eb","storyCycle":"true","abVersion":"10.10","abIDOrigin":"storyCycle","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n        dimensionData: {\r\n            dimension: ab.links.remember.tags.abActiveDimension,\r\n            [ab.links.remember.tags.abActiveDimension]: tags[ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension + 'X']: tags[ab.links.remember.tags.abActiveDimension + 'X'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Y']: tags[ab.links.remember.tags.abActiveDimension + 'Y'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: tags[ab.links.remember.tags.abActiveDimension + 'Z'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationX']: tags[ab.links.remember.tags.abActiveDimension + 'RotationX'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationY']: tags[ab.links.remember.tags.abActiveDimension + 'RotationY'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationZ']: tags[ab.links.remember.tags.abActiveDimension + 'RotationZ'],\r\n        },\r\n        color: tags.color,\r\n        labelFloatingBackgroundColor: tags.bbLabelFloatingBackgroundColor,\r\n        labelColor: tags.bbLabelColor\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'storyCycle'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","bbLabel":"story cycle","onABArtifactReconstitute":"@const data = that.data;\r\ntags.color = data.color ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD';\r\ntags.bbLabelFloatingBackgroundColor = data.labelFloatingBackgroundColor ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD'; \r\ntags.bbLabelColor = data.labelColor ?? 'white';\r\n\r\n//Place bot correctly\r\nif (data.dimensionData) {\r\n    for (const tagName in data.dimensionData) {\r\n        tags[tagName] = data.dimensionData[tagName];\r\n    }\r\n}\r\n\r\n//If new action\r\nif (data.eggParameters) {\r\n    const dimension = data.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = data.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = data.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags.dimension = dimension;\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n\r\n    const activeSkybox = getBot(byTag(\"storyPlace\", true), byTag(\"activeSkybox\", true));\r\n    if (activeSkybox) {\r\n        tags.currentStoryPlace = activeSkybox.tags.bbLabel;\r\n    } else {\r\n        tags.currentStoryPlace = undefined;\r\n    }\r\n}\r\n\r\nif (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;\r\n\r\ndelete data.tags.bbLabelColor;\r\ndelete data.tags.bbLabelFloatingBackgroundColor;\r\ndelete data.tags.color;\r\ndelete data.tags[data.tags.dimension + \"X\"];\r\ndelete data.tags[data.tags.dimension + \"Y\"];\r\ndelete data.tags[data.tags.dimension + \"Z\"];\r\ndelete data.tags[data.tags.dimension + \"RotationX\"];\r\ndelete data.tags[data.tags.dimension + \"RotationY\"];\r\ndelete data.tags[data.tags.dimension + \"RotationZ\"];\r\ndelete data.tags[data.tags.dimension];\r\ndelete data.tags.dimension;\r\ndelete data.tags.currentStoryPlace;","strokeColor":"white","abArtifactName":"storyCycle","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;\r\n\r\nthisBot.updateBillboardLabel();","onBotChanged":"@const needUpdateBillboardLabel = that.tags.some(t => t === 'bbLabel' || t === 'bbLabelFloatingBackgroundColor' || t === 'bbLabelColor');\r\n\r\nif (needUpdateBillboardLabel && tags.ready) {\r\n    thisBot.updateBillboardLabel();\r\n}","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\r\n    destroy(thisBot.vars.billboardLabelBot);\r\n    thisBot.vars.billboardLabelBot = null;\r\n}\r\n\r\nthisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \r\n    bot: thisBot, \r\n    label: tags.bbLabel,\r\n    color: tags.bbLabelFloatingBackgroundColor,\r\n    dimension: tags.dimension,\r\n    // botLabelMargin: 0,\r\n    labelColor: tags.bbLabelColor,\r\n    space: 'tempLocal',\r\n})","cursor":"pointer"}}}}