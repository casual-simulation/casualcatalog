{"version":1,"state":{"035ba7be-fd67-4ec7-a8a5-697dea09515e":{"id":"035ba7be-fd67-4ec7-a8a5-697dea09515e","space":"shared","tags":{"system":"story_toolbox.storyElement","storyElement":"true","abIDOrigin":"storyElement","onClick":"@if (that?.modality == 'mouse' && that?.buttonId == 'right') {\r\n    thisBot.generateStoryElementEditMenu();\r\n    return;\r\n}\r\n\r\nif (!tags.elementPrompt) {\r\n    thisBot.aiGenerateStoryElement();\r\n    return;\r\n}\r\n\r\nif (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n\r\nos.tip(\"thinking...\", null, null, 4);\r\n\r\nconst prompt = thisBot.logPrompt();\r\n\r\nconst aiChatOptions: AIChatOptions = {\r\n    preferredModel: ab.links.personality.tags.abPreferredAIModel\r\n}\r\n\r\nlet response = await ai.chat(prompt, aiChatOptions);\r\n\r\nif (!response) {\r\n    return;\r\n}\r\n\r\nab.log({message: response?.content, name: tags.bbLabel, space: \"shared\"});\r\n// thisBot.aiGenerateStoryElement();","onGridClick":"@shout(\"clearStoryElementMenu\");","onPointerEnter":"@if (tags.elementQuip) {\r\n    os.tip(tags.elementQuip);\r\n}","generateStoryElementEditMenu":"@shout(\"clearStoryElementMenu\");\r\n\r\nshout(\"abMenuRefresh\");\r\nconfigBot.tags.menuPortal = \"storyElementEditMenu\";\r\n\r\nif (tags.storyElementLocked) {\r\n    const titleButton = {\r\n        label: thisBot.tags.bbLabel,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        color: abPersonality.tags.abBaseMenuColor,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    const lockButton = {\r\n        label: \"locked\",\r\n        element: getLink(thisBot),\r\n        formAddress: \"lock\",\r\n        onClick: `@\r\n            links.element.tags.storyElementLocked = false;\r\n            links.element.generateStoryElementEditMenu();\r\n        `,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    await ab.links.menu.abCreateMenuText(titleButton);\r\n    await ab.links.menu.abCreateMenuButton(lockButton);\r\n} else {\r\n    const titleEditButton = {\r\n        label: \"edit title\",\r\n        element: getLink(thisBot),\r\n        onClick: `@\r\n            const newTitle = await os.showInput(links.element.tags.bbLabel, {\r\n                title: \"Edit title\"\r\n            });\r\n\r\n            links.element.tags.bbLabel = newTitle;\r\n            links.element.generateStoryElementEditMenu();\r\n        `,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    const promptEditButton = {\r\n        label: \"edit prompt\",\r\n        element: getLink(thisBot),\r\n        onClick: `@\r\n            const newPrompt = await os.showInput(links.element.tags.elementPrompt, {\r\n                title: \"Edit prompt\"\r\n            });\r\n\r\n            links.element.tags.elementPrompt = newPrompt;\r\n            links.element.generateStoryElementEditMenu();\r\n        `,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    const quipEditButton = {\r\n        label: \"edit quip\",\r\n        element: getLink(thisBot),\r\n        onClick: `@\r\n            const newQuip = await os.showInput(links.element.tags.elementQuip, {\r\n                title: \"Edit quip\"\r\n            });\r\n\r\n            links.element.tags.elementQuip = newQuip;\r\n            links.element.generateStoryElementEditMenu();\r\n        `,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    const lockButton = {\r\n        label: \"unlocked\",\r\n        element: getLink(thisBot),\r\n        formAddress: \"lock\",\r\n        onClick: `@\r\n            links.element.tags.storyElementLocked = true;\r\n            links.element.generateStoryElementEditMenu();\r\n        `,\r\n        clearStoryElementMenu: `@destroy(this);`,\r\n        storyElementEditMenu: true\r\n    } \r\n\r\n    await ab.links.menu.abCreateMenuButton(titleEditButton);\r\n    await ab.links.menu.abCreateMenuButton(promptEditButton);\r\n    await ab.links.menu.abCreateMenuButton(quipEditButton);\r\n    await ab.links.menu.abCreateMenuButton(lockButton);\r\n\r\n}\r\n","abRightClickIgnore":"true","aiGenerateStoryElement":"@let prompt;\r\n\r\nif (that) {\r\n    prompt = that.prompt;\r\n} else {\r\n    prompt = await os.showInput(\"\", {\r\n        title: \"What would you like to add to this story?\"\r\n    });\r\n}\r\n\r\nif (!prompt) {\r\n    return;\r\n}\r\n\r\nconfigBot.tags.menuPortal = \"storyElementLoading\";\r\nconst loadingBar = ab.links.menu.abCreateMenuBusyIndicator({\r\n    label: \"Generating story element\",\r\n    storyElementLoading: true\r\n});\r\n\r\nconst aiChatOptions: AIChatOptions = {\r\n    preferredModel: ab.links.personality.tags.abPreferredAIModel\r\n}\r\n\r\nlet response = await ai.chat([\r\n    {\r\n        role: \"system\",\r\n        content: tags.basePrompt\r\n    },\r\n    {\r\n        role: \"user\",\r\n        content: prompt\r\n    }\r\n], aiChatOptions)\r\n\r\ndestroy(loadingBar);\r\n\r\nresponse = response.content.replace(/```json\\n?|```/g, '');\r\n\r\ntry {\r\n    response = JSON.parse(response);\r\n} catch (e) {\r\n    console.log(\"Error generating story block: \", e, response);\r\n    return;\r\n}\r\n\r\nif (!response) {\r\n    return;\r\n}\r\n\r\nconst activeDimension = configBot.tags.gridPortal;\r\ntags.color = response?.color;\r\ntags.bbLabel = that?.target ?? response?.name;\r\ntags.elementPrompt = prompt;\r\ntags.elementQuip = response?.expression;\r\ntags[activeDimension] = true;\r\ntags.scaleX = response?.scale?.x;\r\ntags.scaleY = response?.scale?.y;\r\ntags.scaleZ = response?.scale?.z;\r\n\r\nshout(\"onStoryElementAdded\", thisBot);","basePrompt":"ðŸ“„`You are a story block in a world with many other story blocks.\r\nYou will recieve a prompt from the user.\r\nReturn pure JSON with a name for your story block, an appropriate color in hex format, a short 'expression' that makes sense for what you are (example: if you were a cow, your expression might be \"moo\"),\r\nand an x,y,z scaling that represents what you are in a physical space, z is height, units are in yards, decimals are allowed, do not exceed 4.0 for any scale.\r\nYour response must only include valid JSON, starting with a { and ending with a }. You MUST NOT return only a string.\r\n\r\nEXAMPLE:\r\nprompt: \"a happy cow\"\r\nresponse: \r\n{\r\n    name: \"Mooney the happy cow\",\r\n    color: \"#f7f7f7\",\r\n    expression: \"moo!\",\r\n    scale: {\r\n        x: 5,\r\n        y: 3,\r\n        z: 3\r\n    }\r\n}`","logPrompt":"@const aiMessageArr = [];\r\n\r\nconst messages = getBots(byTag(\"consoleLogMessageBot\", true), byTag(\"space\", \"shared\"));\r\nfor (let i = 0; i < messages.length; ++i) {\r\n    aiMessageArr.push({\r\n        role: messages[i].tags.name == tags.bbLabel ? \"assistant\" : \"user\",\r\n        content: messages[i].tags.name == tags.bbLabel ? messages[i].tags.message : messages[i].tags.name + \": \" + messages[i].tags.message\r\n    })\r\n}\r\n\r\naiMessageArr.push({\r\n    role: \"system\",\r\n    content: `You are ${tags.bbLabel} in a story. With this description of what you are (${tags.elementPrompt}), continue the story with what you do or say next.\r\n     Keep it simple and short, no more than a sentence or two, inpired by picture books, fables and fairytales. \r\n     You are allowed to improvise, create new plot points, and generally make the story interesting.\r\n     You cannot speak for other story elements. Your response should be a string only.\r\n     \r\n     EXAMPLE SCENARIO:\r\n     a sheep and a cow are in a field, you are the sheep. The cow says \"it is a beautiful day out\".\r\n\r\n     RESPONSE: \r\n     \"Yes! the sun is shining very brightly today! I may go on a walk.\"\r\n     `\r\n});\r\n\r\nconsole.log(\"prompt\", aiMessageArr);\r\nreturn aiMessageArr;","abVersion":"10.10","respond":"@const prompt = thisBot.logPrompt();\r\n\r\nos.tip(\"thinking ...\");\r\n\r\nprompt.push(\r\n    {\r\n        role: \"assistant\",\r\n        content: \"Narrator: \" + that\r\n    }\r\n)\r\n\r\nconst aiChatOptions: AIChatOptions = {\r\n    preferredModel: ab.links.personality.tags.abPreferredAIModel\r\n}\r\nconst response = await ai.chat(prompt, aiChatOptions);\r\n\r\nif (!response) {\r\n    return;\r\n}\r\n\r\nab.log({message: response?.content, name: tags.bbLabel, space: \"shared\"});\r\n\r\nreturn response?.content;","storyTarget":"true","onABArtifactReconstitute":"@const data = that.data;\r\ntags.bbLabel = data.label ?? 'story element';\r\ntags.color = data.color ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD';\r\ntags.bbLabelFloatingBackgroundColor = data.labelFloatingBackgroundColor ?? abPersonality?.tags?.abBaseColor ?? '#00D9CD'; \r\ntags.bbLabelColor = data.labelColor ?? 'white';\r\ntags.elementQuip = data.elementQuip;\r\ntags.storyElementLocked = data.storyElementLocked;\r\ntags.elementPrompt = data.elementPrompt;\r\ntags.scaleX = data.scaleX;\r\ntags.scaleY = data.scaleY;\r\ntags.scaleZ = data.scaleZ;\r\n\r\n//Place bot correctly\r\nif (data.dimensionData) {\r\n    for (const tagName in data.dimensionData) {\r\n        tags[tagName] = data.dimensionData[tagName];\r\n    }\r\n}\r\n\r\n//If new action\r\nif (data.eggParameters) {\r\n    const dimension = data.eggParameters.gridInformation?.dimension ?? 'home';\r\n    const dimensionX = data.eggParameters.gridInformation?.position?.x ?? 0;\r\n    const dimensionY = data.eggParameters.gridInformation?.position?.y ?? 0;\r\n\r\n    tags.dimension = dimension;\r\n    tags[dimension] = true;\r\n    tags[dimension + 'X'] = dimensionX;\r\n    tags[dimension + 'Y'] = dimensionY;\r\n\r\n     if (data.eggParameters && data.eggParameters.storyParameters) {\r\n        thisBot.aiGenerateStoryElement({\"prompt\": data.eggParameters.storyParameters.prompt, \"target\": data.eggParameters.storyParameters.target});\r\n    } else {\r\n        thisBot.aiGenerateStoryElement();\r\n    }\r\n}\r\n\r\nif (!ab.links.console.masks.open) {\r\n    whisper(ab.links.console, \"showConsole\");\r\n    ab.links.console.masks.open = true;\r\n}\r\n","onABArtifactCollectShards":"@const shard: ABArtifactShard = {\r\n    data: {\r\n        label: tags.bbLabel,\r\n        dimensionData: {\r\n            dimension: [ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension]: tags[ab.links.remember.tags.abActiveDimension],\r\n            [ab.links.remember.tags.abActiveDimension + 'X']: tags[ab.links.remember.tags.abActiveDimension + 'X'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Y']: tags[ab.links.remember.tags.abActiveDimension + 'Y'],\r\n            [ab.links.remember.tags.abActiveDimension + 'Z']: tags[ab.links.remember.tags.abActiveDimension + 'Z'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationX']: tags[ab.links.remember.tags.abActiveDimension + 'RotationX'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationY']: tags[ab.links.remember.tags.abActiveDimension + 'RotationY'],\r\n            [ab.links.remember.tags.abActiveDimension + 'RotationZ']: tags[ab.links.remember.tags.abActiveDimension + 'RotationZ'],\r\n        },\r\n        color: tags.color,\r\n        labelFloatingBackgroundColor: tags.bbLabelFloatingBackgroundColor,\r\n        labelColor: tags.bbLabelColor,\r\n        elementQuip: tags.elementQuip,\r\n        storyElementLocked: tags.storyElementLocked,\r\n        elementPrompt: tags.elementPrompt,\r\n        scaleX: tags.scaleX,\r\n        scaleY: tags.scaleY,\r\n        scaleZ: tags.scaleZ\r\n    },\r\n    dependencies: [\r\n        {\r\n            askID: 'storyElement'\r\n        }\r\n    ]\r\n}\r\n\r\nreturn shard;","onABStripArtifactInstanceDataFromBotData":"@const { data } = that;\r\n\r\ndelete data.tags.bbLabel;\r\ndelete data.tags.bbLabelColor;\r\ndelete data.tags.bbLabelFloatingBackgroundColor;\r\ndelete data.tags.color;\r\ndelete data.tags[data.tags.dimension + \"X\"];\r\ndelete data.tags[data.tags.dimension + \"Y\"];\r\ndelete data.tags[data.tags.dimension + \"Z\"];\r\ndelete data.tags[data.tags.dimension + \"RotationX\"];\r\ndelete data.tags[data.tags.dimension + \"RotationY\"];\r\ndelete data.tags[data.tags.dimension + \"RotationZ\"];\r\ndelete data.tags[data.tags.dimension];\r\ndelete data.tags.dimension;\r\ndelete data.tags.elementQuip;\r\ndelete data.tags.storyElementLocked;\r\ndelete data.tags.elementPrompt;\r\ndelete data.tags.scaleX;\r\ndelete data.tags.scaleY;\r\ndelete data.tags.scaleZ;","abArtifactName":"storyElement","onBotAdded":"@let waitTime = 0;\r\n\r\nwhile(!globalThis.ab?.links.bot_factory) {\r\n    if (waitTime >= 5000) {\r\n        return;\r\n    }\r\n    \r\n    await os.sleep(250);\r\n    waitTime += 250;\r\n}\r\n\r\nmasks.ready = true;\r\n\r\nthisBot.updateBillboardLabel();","onBotChanged":"@const needUpdateBillboardLabel = that.tags.some(t => t === 'bbLabel' || t === 'bbLabelFloatingBackgroundColor' || t === 'bbLabelColor');\r\n\r\nif (needUpdateBillboardLabel && tags.ready) {\r\n    thisBot.updateBillboardLabel();\r\n}","updateBillboardLabel":"@if (thisBot.vars.billboardLabelBot) {\r\n    destroy(thisBot.vars.billboardLabelBot);\r\n    thisBot.vars.billboardLabelBot = null;\r\n}\r\n\r\nthisBot.vars.billboardLabelBot = ab.links.bot_factory.abCreateBillboardLabel({ \r\n    bot: thisBot, \r\n    label: tags.bbLabel,\r\n    color: tags.bbLabelFloatingBackgroundColor,\r\n    dimension: tags.dimension,\r\n    // botLabelMargin: 0,\r\n    labelColor: tags.bbLabelColor,\r\n    space: 'tempLocal',\r\n})","strokeColor":"white","cursor":"pointer"}}}}